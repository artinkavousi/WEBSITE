Directory structure:
└── examples/
    ├── webgpu_animation_retargeting.html
    ├── webgpu_animation_retargeting_readyplayer.html
    ├── webgpu_backdrop.html
    ├── webgpu_backdrop_area.html
    ├── webgpu_backdrop_water.html
    ├── webgpu_camera.html
    ├── webgpu_camera_array.html
    ├── webgpu_camera_logarithmicdepthbuffer.html
    ├── webgpu_caustics.html
    ├── webgpu_centroid_sampling.html
    ├── webgpu_clearcoat.html
    ├── webgpu_clipping.html
    ├── webgpu_compute_audio.html
    ├── webgpu_compute_birds.html
    ├── webgpu_compute_cloth.html
    ├── webgpu_compute_geometry.html
    ├── webgpu_compute_particles.html
    ├── webgpu_compute_particles_fluid.html
    ├── webgpu_compute_particles_rain.html
    ├── webgpu_compute_particles_snow.html
    ├── webgpu_compute_points.html
    ├── webgpu_compute_reduce.html
    ├── webgpu_compute_sort_bitonic.html
    ├── webgpu_compute_texture.html
    ├── webgpu_compute_texture_3d.html
    ├── webgpu_compute_texture_pingpong.html
    ├── webgpu_compute_water.html
    ├── webgpu_cubemap_adjustments.html
    ├── webgpu_cubemap_dynamic.html
    ├── webgpu_cubemap_mix.html
    ├── webgpu_custom_fog.html
    ├── webgpu_custom_fog_background.html
    ├── webgpu_depth_texture.html
    ├── webgpu_display_stereo.html
    ├── webgpu_equirectangular.html
    ├── webgpu_hdr.html
    ├── webgpu_instance_mesh.html
    ├── webgpu_instance_path.html
    ├── webgpu_instance_points.html
    ├── webgpu_instance_sprites.html
    ├── webgpu_instance_uniform.html
    ├── webgpu_instancing_morph.html
    ├── webgpu_layers.html
    ├── webgpu_lensflares.html
    ├── webgpu_lightprobe.html
    ├── webgpu_lightprobe_cubecamera.html
    ├── webgpu_lights_custom.html
    ├── webgpu_lights_ies_spotlight.html
    ├── webgpu_lights_phong.html
    ├── webgpu_lights_physical.html
    ├── webgpu_lights_pointlights.html
    ├── webgpu_lights_projector.html
    ├── webgpu_lights_rectarealight.html
    ├── webgpu_lights_selective.html
    ├── webgpu_lights_spotlight.html
    ├── webgpu_lights_tiled.html
    ├── webgpu_lines_fat.html
    ├── webgpu_lines_fat_raycasting.html
    ├── webgpu_lines_fat_wireframe.html
    ├── webgpu_loader_gltf.html
    ├── webgpu_loader_gltf_anisotropy.html
    ├── webgpu_loader_gltf_compressed.html
    ├── webgpu_loader_gltf_dispersion.html
    ├── webgpu_loader_gltf_iridescence.html
    ├── webgpu_loader_gltf_sheen.html
    ├── webgpu_loader_gltf_transmission.html
    ├── webgpu_loader_materialx.html
    ├── webgpu_loader_texture_ktx2.html
    ├── webgpu_materials.html
    ├── webgpu_materials_alphahash.html
    ├── webgpu_materials_arrays.html
    ├── webgpu_materials_basic.html
    ├── webgpu_materials_cubemap_mipmaps.html
    ├── webgpu_materials_displacementmap.html
    ├── webgpu_materials_envmaps.html
    ├── webgpu_materials_envmaps_bpcem.html
    ├── webgpu_materials_lightmap.html
    ├── webgpu_materials_matcap.html
    ├── webgpu_materials_sss.html
    ├── webgpu_materials_texture_manualmipmap.html
    ├── webgpu_materials_toon.html
    ├── webgpu_materials_transmission.html
    ├── webgpu_materials_video.html
    ├── webgpu_materialx_noise.html
    ├── webgpu_mesh_batch.html
    ├── webgpu_mirror.html
    ├── webgpu_modifier_curve.html
    ├── webgpu_morphtargets.html
    ├── webgpu_morphtargets_face.html
    ├── webgpu_mrt.html
    ├── webgpu_mrt_mask.html
    ├── webgpu_multiple_canvas.html
    ├── webgpu_multiple_elements.html
    ├── webgpu_multiple_rendertargets.html
    ├── webgpu_multiple_rendertargets_readback.html
    ├── webgpu_multisampled_renderbuffers.html
    ├── webgpu_occlusion.html
    ├── webgpu_ocean.html
    ├── webgpu_parallax_uv.html
    ├── webgpu_particles.html
    ├── webgpu_performance.html
    ├── webgpu_performance_renderbundle.html
    ├── webgpu_pmrem_cubemap.html
    ├── webgpu_pmrem_equirectangular.html
    ├── webgpu_pmrem_scene.html
    ├── webgpu_pmrem_test.html
    ├── webgpu_portal.html
    ├── webgpu_postprocessing.html
    ├── webgpu_postprocessing_3dlut.html
    ├── webgpu_postprocessing_afterimage.html
    ├── webgpu_postprocessing_anamorphic.html
    ├── webgpu_postprocessing_ao.html
    ├── webgpu_postprocessing_bloom.html
    ├── webgpu_postprocessing_bloom_emissive.html
    ├── webgpu_postprocessing_bloom_selective.html
    ├── webgpu_postprocessing_ca.html
    ├── webgpu_postprocessing_difference.html
    ├── webgpu_postprocessing_dof.html
    ├── webgpu_postprocessing_dof_basic.html
    ├── webgpu_postprocessing_fxaa.html
    ├── webgpu_postprocessing_lensflare.html
    ├── webgpu_postprocessing_masking.html
    ├── webgpu_postprocessing_motion_blur.html
    ├── webgpu_postprocessing_outline.html
    ├── webgpu_postprocessing_pixel.html
    ├── webgpu_postprocessing_smaa.html
    ├── webgpu_postprocessing_sobel.html
    ├── webgpu_postprocessing_ssaa.html
    ├── webgpu_postprocessing_ssgi.html
    ├── webgpu_postprocessing_ssr.html
    ├── webgpu_postprocessing_sss.html
    ├── webgpu_postprocessing_traa.html
    ├── webgpu_postprocessing_transition.html
    ├── webgpu_procedural_texture.html
    ├── webgpu_reflection.html
    ├── webgpu_reflection_blurred.html
    ├── webgpu_reflection_roughness.html
    ├── webgpu_refraction.html
    ├── webgpu_rendertarget_2d-array_3d.html
    ├── webgpu_rtt.html
    ├── webgpu_sandbox.html
    ├── webgpu_shadertoy.html
    ├── webgpu_shadowmap.html
    ├── webgpu_shadowmap_array.html
    ├── webgpu_shadowmap_csm.html
    ├── webgpu_shadowmap_opacity.html
    ├── webgpu_shadowmap_progressive.html
    ├── webgpu_shadowmap_vsm.html
    ├── webgpu_skinning.html
    ├── webgpu_skinning_instancing.html
    ├── webgpu_skinning_points.html
    ├── webgpu_sky.html
    ├── webgpu_sprites.html
    ├── webgpu_storage_buffer.html
    ├── webgpu_struct_drawindirect.html
    ├── webgpu_texturegrad.html
    ├── webgpu_textures_2d-array.html
    ├── webgpu_textures_2d-array_compressed.html
    ├── webgpu_textures_anisotropy.html
    ├── webgpu_textures_partialupdate.html
    ├── webgpu_tonemapping.html
    ├── webgpu_tsl_angular_slicing.html
    ├── webgpu_tsl_compute_attractors_particles.html
    ├── webgpu_tsl_earth.html
    ├── webgpu_tsl_editor.html
    ├── webgpu_tsl_galaxy.html
    ├── webgpu_tsl_halftone.html
    ├── webgpu_tsl_interoperability.html
    ├── webgpu_tsl_procedural_terrain.html
    ├── webgpu_tsl_raging_sea.html
    ├── webgpu_tsl_transpiler.html
    ├── webgpu_tsl_vfx_flames.html
    ├── webgpu_tsl_vfx_linkedparticles.html
    ├── webgpu_tsl_vfx_tornado.html
    ├── webgpu_tsl_wood.html
    ├── webgpu_video_frame.html
    ├── webgpu_video_panorama.html
    ├── webgpu_volume_caustics.html
    ├── webgpu_volume_cloud.html
    ├── webgpu_volume_lighting.html
    ├── webgpu_volume_lighting_rectarea.html
    ├── webgpu_volume_perlin.html
    ├── webgpu_water.html
    ├── webgpu_xr_cubes.html
    ├── webgpu_xr_native_layers.html
    └── webgpu_xr_rollercoaster.html

================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_animation_retargeting.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - animation retargeting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Animation Retargeting</span>
			</div>

			<small>
				Basic Animation Retargeting demo.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, screenUV, hue, reflector, time, Fn, vec2, length, atan, float, sin, cos, vec3, sub, mul, pow, blendDodge, normalWorldGeometry } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

			const [ sourceModel, targetModel ] = await Promise.all( [

				new Promise( ( resolve, reject ) => {

					new GLTFLoader().load( './models/gltf/Michelle.glb', resolve, undefined, reject );

				} ),

				new Promise( ( resolve, reject ) => {

					new GLTFLoader().load( './models/gltf/Soldier.glb', resolve, undefined, reject );

				} )

			] );

			//

			const clock = new THREE.Clock();

			export const lightSpeed = /*#__PURE__*/ Fn( ( [ suv_immutable ] ) => {

				// forked from https://www.shadertoy.com/view/7ly3D1

				const suv = vec2( suv_immutable );
				const uv = vec2( length( suv ), atan( suv.y, suv.x ) );
				const offset = float( float( .1 ).mul( sin( uv.y.mul( 10. ).sub( time.mul( .6 ) ) ) ).mul( cos( uv.y.mul( 48. ).add( time.mul( .3 ) ) ) ).mul( cos( uv.y.mul( 3.7 ).add( time ) ) ) );
				const rays = vec3( vec3( sin( uv.y.mul( 150. ).add( time ) ).mul( .5 ).add( .5 ) ).mul( vec3( sin( uv.y.mul( 80. ).sub( time.mul( 0.6 ) ) ).mul( .5 ).add( .5 ) ) ).mul( vec3( sin( uv.y.mul( 45. ).add( time.mul( 0.8 ) ) ).mul( .5 ).add( .5 ) ) ).mul( vec3( sub( 1., cos( uv.y.add( mul( 22., time ).sub( pow( uv.x.add( offset ), .3 ).mul( 60. ) ) ) ) ) ) ).mul( vec3( uv.x.mul( 2. ) ) ) );

				return rays;

			} ).setLayout( {
				name: 'lightSpeed',
				type: 'vec3',
				inputs: [
					{ name: 'suv', type: 'vec2' }
				]
			} );

			// scene

			const scene = new THREE.Scene();

			// background

			const coloredVignette = screenUV.distance( .5 ).mix( hue( color( 0x0175ad ), time.mul( .1 ) ), hue( color( 0x02274f ), time.mul( .5 ) ) );
			const lightSpeedEffect = lightSpeed( normalWorldGeometry ).clamp();
			const lightSpeedSky = normalWorldGeometry.y.remapClamp( - .1, 1 ).mix( 0, lightSpeedEffect );
			const composedBackground = blendDodge( coloredVignette, lightSpeedSky );

			scene.backgroundNode = composedBackground;

			//

			const helpers = new THREE.Group();
			helpers.visible = false;
			scene.add( helpers );

			const light = new THREE.HemisphereLight( 0xe9c0a5, 0x0175ad, 5 );
			scene.add( light );

			const dirLight = new THREE.DirectionalLight( 0xfff9ea, 4 );
			dirLight.position.set( 2, 5, 2 );
			scene.add( dirLight );

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, .25, 50 );
			camera.position.set( 0, 1, 4 );

			// add models to scene
			scene.add( sourceModel.scene );
			scene.add( targetModel.scene );

			// reposition models
			sourceModel.scene.position.x -= .8;
			targetModel.scene.position.x += .7;

			targetModel.scene.position.z -= .1;

			// reajust model
			targetModel.scene.scale.setScalar( .01 );

			// flip model
			sourceModel.scene.rotation.y = Math.PI / 2;
			targetModel.scene.rotation.y = - Math.PI / 2;

			// retarget
			const source = getSource( sourceModel );
			const mixer = retargetModel( source, targetModel );

			// floor
			const reflection = reflector();
			reflection.target.rotateX( - Math.PI / 2 );
			scene.add( reflection.target );

			const floorMaterial = new THREE.NodeMaterial();
			floorMaterial.colorNode = reflection;
			floorMaterial.opacity = .2;
			floorMaterial.transparent = true;

			const floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );
			floor.receiveShadow = true;

			floor.position.set( 0, 0, 0 );
			scene.add( floor );

			// renderer
			const renderer = new THREE.WebGPURenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.toneMapping = THREE.NeutralToneMapping;
			renderer.inspector = new Inspector();
			document.body.appendChild( renderer.domElement );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.minDistance = 3;
			controls.maxDistance = 12;
			controls.target.set( 0, 1, 0 );
			controls.maxPolarAngle = Math.PI / 2;

			const gui = renderer.inspector.createParameters( 'Scene settings' );
			gui.add( helpers, 'visible' ).name( 'show helpers' );

			//

			function getSource( sourceModel ) {

				const clip = sourceModel.animations[ 0 ];

				const helper = new THREE.SkeletonHelper( sourceModel.scene );
				helpers.add( helper );

				const skeleton = new THREE.Skeleton( helper.bones );

				const mixer = new THREE.AnimationMixer( sourceModel.scene );
				mixer.clipAction( sourceModel.animations[ 0 ] ).play();

				return { clip, skeleton, mixer };

			}

			function retargetModel( sourceModel, targetModel ) {

				const targetSkin = targetModel.scene.children[ 0 ].children[ 0 ];

				const targetSkelHelper = new THREE.SkeletonHelper( targetModel.scene );
				helpers.add( targetSkelHelper );

				const rotateCW45 = new THREE.Matrix4().makeRotationY( THREE.MathUtils.degToRad( 45 ) );
				const rotateCCW180 = new THREE.Matrix4().makeRotationY( THREE.MathUtils.degToRad( - 180 ) );
				const rotateCW180 = new THREE.Matrix4().makeRotationY( THREE.MathUtils.degToRad( 180 ) );
				const rotateFoot = new THREE.Matrix4().makeRotationFromEuler( new THREE.Euler( THREE.MathUtils.degToRad( 45 ), THREE.MathUtils.degToRad( 180 ), THREE.MathUtils.degToRad( 0 ) ) );

				const retargetOptions = {

					// specify the name of the source's hip bone.
					hip: 'mixamorigHips',

					// specify the influence of the source's hip bone.
					// use ( 0, 1, 0 ) to ignore xz hip movement.
					//hipInfluence: new THREE.Vector3( 0, 1, 0 ),

					// specify an animation range in seconds.
					//trim: [ 3.0, 4.0 ],

					// preserve the scale of the target model
					scale: 1 / targetModel.scene.scale.y,

					// offset target bones -> { targetBoneName: offsetMatrix }
					localOffsets: {

						mixamorigLeftShoulder: rotateCW45,
						mixamorigRightShoulder: rotateCCW180,
						mixamorigLeftArm: rotateCW45,
						mixamorigRightArm: rotateCCW180,
						mixamorigLeftForeArm: rotateCW45,
						mixamorigRightForeArm: rotateCCW180,
						mixamorigLeftHand: rotateCW45,
						mixamorigRightHand: rotateCCW180,

						mixamorigLeftUpLeg: rotateCW180,
						mixamorigRightUpLeg: rotateCW180,
						mixamorigLeftLeg: rotateCW180,
						mixamorigRightLeg: rotateCW180,
						mixamorigLeftFoot: rotateFoot,
						mixamorigRightFoot: rotateFoot,
						mixamorigLeftToeBase: rotateCW180,
						mixamorigRightToeBase: rotateCW180

					},

					// Map of target's bone names to source's bone names -> { targetBoneName: sourceBoneName }
					names: {

						mixamorigHips: 'mixamorigHips',

						mixamorigSpine: 'mixamorigSpine',
						mixamorigSpine2: 'mixamorigSpine2',
						mixamorigHead: 'mixamorigHead',

						mixamorigLeftShoulder: 'mixamorigLeftShoulder',
						mixamorigRightShoulder: 'mixamorigRightShoulder',
						mixamorigLeftArm: 'mixamorigLeftArm',
						mixamorigRightArm: 'mixamorigRightArm',
						mixamorigLeftForeArm: 'mixamorigLeftForeArm',
						mixamorigRightForeArm: 'mixamorigRightForeArm',
						mixamorigLeftHand: 'mixamorigLeftHand',
						mixamorigRightHand: 'mixamorigRightHand',

						mixamorigLeftUpLeg: 'mixamorigLeftUpLeg',
						mixamorigRightUpLeg: 'mixamorigRightUpLeg',
						mixamorigLeftLeg: 'mixamorigLeftLeg',
						mixamorigRightLeg: 'mixamorigRightLeg',
						mixamorigLeftFoot: 'mixamorigLeftFoot',
						mixamorigRightFoot: 'mixamorigRightFoot',
						mixamorigLeftToeBase: 'mixamorigLeftToeBase',
						mixamorigRightToeBase: 'mixamorigRightToeBase'

					}

				};

				const retargetedClip = SkeletonUtils.retargetClip( targetSkin, sourceModel.skeleton, sourceModel.clip, retargetOptions );

				// Apply the mixer directly to the SkinnedMesh, not any
				// ancestor node, because that's what
				// SkeletonUtils.retargetClip outputs the clip to be
				// compatible with.
				const mixer = new THREE.AnimationMixer( targetSkin );
				mixer.clipAction( retargetedClip ).play();

				return mixer;

			}

			window.onresize = function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			};

			function animate() {

				const delta = clock.getDelta();

				source.mixer.update( delta );
				mixer.update( delta );

				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_animation_retargeting_readyplayer.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - animation retargeting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Animation Retargeting</span>
			</div>

			<small>
				Animation Retargeting from <a href="https://www.mixamo.com/" target="_blank" rel="noopener">Mixamo</a> to <a href="https://readyplayer.me/" target="_blank" rel="noopener">readyplayer.me</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { screenUV, color, vec2, vec4, reflector, positionWorld } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

			const [ sourceModel, targetModel ] = await Promise.all( [

				new Promise( ( resolve, reject ) => {

					new FBXLoader().load( './models/fbx/mixamo.fbx', resolve, undefined, reject );

				} ),

				new Promise( ( resolve, reject ) => {

					new GLTFLoader().load( './models/gltf/readyplayer.me.glb', resolve, undefined, reject );

				} )

			] );

			//

			const clock = new THREE.Clock();

			// scene

			const scene = new THREE.Scene();

			// background

			const horizontalEffect = screenUV.x.mix( color( 0x13172b ), color( 0x311649 ) );
			const lightEffect = screenUV.distance( vec2( 0.5, 1.0 ) ).oneMinus().mul( color( 0x0c5d68 ) );

			scene.backgroundNode = horizontalEffect.add( lightEffect );

			//

			const light = new THREE.HemisphereLight( 0x311649, 0x0c5d68, 10 );
			scene.add( light );

			const backLight = new THREE.DirectionalLight( 0xffffff, 10 );
			backLight.position.set( 0, 5, - 5 );
			scene.add( backLight );

			const keyLight = new THREE.DirectionalLight( 0xfff9ea, 4 );
			keyLight.position.set( 3, 5, 3 );
			scene.add( keyLight );

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, .25, 50 );
			camera.position.set( 0, 3, 5 );

			// add models to scene
			scene.add( sourceModel );
			scene.add( targetModel.scene );

			// reposition models
			sourceModel.position.x -= .9;
			targetModel.scene.position.x += .9;

			// reajust model - mixamo use centimeters, readyplayer.me use meters (three.js scale is meters)
			sourceModel.scale.setScalar( .01 );

			// retarget
			const source = getSource( sourceModel );
			const mixer = retargetModel( source, targetModel );

			// renderer
			const renderer = new THREE.WebGPURenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.inspector = new Inspector();
			renderer.toneMapping = THREE.NeutralToneMapping;
			document.body.appendChild( renderer.domElement );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.minDistance = 3;
			controls.maxDistance = 12;
			controls.target.set( 0, 1, 0 );
			controls.maxPolarAngle = Math.PI / 2;

			// floor
			const reflection = reflector();
			reflection.target.rotateX( - Math.PI / 2 );
			scene.add( reflection.target );

			const reflectionMask = positionWorld.xz.distance( 0 ).mul( .1 ).clamp().oneMinus();

			const floorMaterial = new THREE.NodeMaterial();
			floorMaterial.colorNode = vec4( reflection.rgb, reflectionMask );
			floorMaterial.opacity = .2;
			floorMaterial.transparent = true;

			const floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );
			floor.receiveShadow = true;

			floor.position.set( 0, 0, 0 );
			scene.add( floor );

			//

			function getSource( sourceModel ) {

				const clip = sourceModel.animations[ 0 ];

				const helper = new THREE.SkeletonHelper( sourceModel );
				const skeleton = new THREE.Skeleton( helper.bones );

				const mixer = new THREE.AnimationMixer( sourceModel );
				mixer.clipAction( sourceModel.animations[ 0 ] ).play();

				return { clip, skeleton, mixer };

			}

			function retargetModel( sourceModel, targetModel ) {

				const targetSkin = targetModel.scene.children[ 0 ].children[ 1 ];

				const retargetOptions = {

					// specify the name of the source's hip bone.
					hip: 'mixamorigHips',

					// preserve the scale of the target model
					scale: .01,

					// use ( 0, 1, 0 ) to ignore xz hip movement.
					//hipInfluence: new THREE.Vector3( 0, 1, 0 ),

					// Map of target's bone names to source's bone names -> { targetBoneName: sourceBoneName }
					getBoneName: function ( bone ) {

						return 'mixamorig' + bone.name;

					}

				};

				const retargetedClip = SkeletonUtils.retargetClip( targetSkin, sourceModel.skeleton, sourceModel.clip, retargetOptions );

				const mixer = new THREE.AnimationMixer( targetSkin );
				mixer.clipAction( retargetedClip ).play();

				return mixer;

			}

			window.onresize = function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			};

			function animate() {

				const delta = clock.getDelta();

				source.mixer.update( delta );
				mixer.update( delta );

				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_backdrop.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - WebGPU - Backdrop</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Backdrop</span>
			</div>

			<small>Backdrop objects can apply blend, overlay or filter effects on occluded 3D objects.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { float, vec3, color, viewportSharedTexture, hue, blendOverlay, posterize, grayscale, saturation, viewportSafeUV, screenUV, checker, uv, time, oscSine, output } from 'three/tsl';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;
			let portals, rotate = true;
			let mixer, clock;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.set( 1, 2, 3 );

				scene = new THREE.Scene();
				scene.backgroundNode = screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) );
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				// lights

				const light = new THREE.SpotLight( 0xffffff, 1 );
				light.power = 2000;
				camera.add( light );
				scene.add( camera );

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					const object = gltf.scene;
					mixer = new THREE.AnimationMixer( object );

					const material = object.children[ 0 ].children[ 0 ].material;
					material.outputNode = oscSine( time.mul( .1 ) ).mix( output, posterize( output.add( .1 ), 4 ).mul( 2 ) );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					scene.add( object );

				} );

				// portals

				const geometry = new THREE.SphereGeometry( .3, 32, 16 );

				portals = new THREE.Group();
				scene.add( portals );

				function addBackdropSphere( backdropNode, backdropAlphaNode = null ) {

					const distance = 1;
					const id = portals.children.length;
					const rotation = THREE.MathUtils.degToRad( id * 45 );

					const material = new THREE.MeshStandardNodeMaterial( { color: 0x0066ff } );
					material.roughnessNode = float( .2 );
					material.metalnessNode = float( 0 );
					material.backdropNode = backdropNode;
					material.backdropAlphaNode = backdropAlphaNode;
					material.transparent = true;

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.set(
						Math.cos( rotation ) * distance,
						1,
						Math.sin( rotation ) * distance
					);

					portals.add( mesh );

				}

				addBackdropSphere( hue( viewportSharedTexture().bgr, oscSine().mul( Math.PI ) ) );
				addBackdropSphere( viewportSharedTexture().rgb.oneMinus() );
				addBackdropSphere( grayscale( viewportSharedTexture().rgb ) );
				addBackdropSphere( saturation( viewportSharedTexture().rgb, 10 ), oscSine() );
				addBackdropSphere( blendOverlay( viewportSharedTexture().rgb, checker( uv().mul( 10 ) ) ) );
				addBackdropSphere( viewportSharedTexture( viewportSafeUV( screenUV.mul( 40 ).floor().div( 40 ) ) ) );
				addBackdropSphere( viewportSharedTexture( viewportSafeUV( screenUV.mul( 80 ).floor().div( 80 ) ) ).add( color( 0x0033ff ) ) );
				addBackdropSphere( vec3( 0, 0, viewportSharedTexture().b ) );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 0.3;
				document.body.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 1, 0 );
				controls.addEventListener( 'start', () => rotate = false );
				controls.addEventListener( 'end', () => rotate = true );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				if ( mixer ) mixer.update( delta );

				if ( rotate ) portals.rotation.y += delta * 0.5;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_backdrop_area.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - WebGPU - Backdrop Area</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Backdrop Area</span>
			</div>

			<small>
				Backdrop area effect.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, positionWorld, linearDepth, viewportLinearDepth, viewportSharedTexture, screenUV, hue, time, checker, uv, modelScale } from 'three/tsl';
			import { hashBlur } from 'three/addons/tsl/display/hashBlur.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;
			let mixer, clock;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 25 );
				camera.position.set( 3, 2, 3 );

				scene = new THREE.Scene();
				scene.backgroundNode = hue( screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) ), time.mul( 0.1 ) );
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				const ambient = new THREE.AmbientLight( 0xffffff, 2.5 );
				scene.add( ambient );
			
				// model

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					const object = gltf.scene;
					mixer = new THREE.AnimationMixer( object );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					scene.add( object );

				} );

				// volume

				// compare depth from viewportLinearDepth with linearDepth() to create a distance field
				// viewportLinearDepth return the linear depth of the scene
				// linearDepth() returns the linear depth of the mesh
				const depthDistance = viewportLinearDepth.distance( linearDepth() );

				const depthAlphaNode = depthDistance.oneMinus().smoothstep( .90, 2 ).mul( 10 ).saturate();
				const depthBlurred = hashBlur( viewportSharedTexture(), depthDistance.smoothstep( 0, .6 ).mul( 40 ).clamp().mul( .1 ) );

				const blurredBlur = new THREE.MeshBasicNodeMaterial();
				blurredBlur.backdropNode = depthBlurred.add( depthAlphaNode.mix( color( 0x003399 ).mul( .3 ), 0 ) );
				blurredBlur.transparent = true;
				blurredBlur.side = THREE.DoubleSide;

				const depthMaterial = new THREE.MeshBasicNodeMaterial();
				depthMaterial.backdropNode = depthAlphaNode;
				depthMaterial.transparent = true;
				depthMaterial.side = THREE.DoubleSide;

				const checkerMaterial = new THREE.MeshBasicNodeMaterial();
				checkerMaterial.backdropNode = hashBlur( viewportSharedTexture(), .05 );
				checkerMaterial.backdropAlphaNode = checker( uv().mul( 3 ).mul( modelScale.xy ) );
				checkerMaterial.opacityNode = checkerMaterial.backdropAlphaNode;
				checkerMaterial.transparent = true;
				checkerMaterial.side = THREE.DoubleSide;

				const pixelMaterial = new THREE.MeshBasicNodeMaterial();
				pixelMaterial.backdropNode = viewportSharedTexture( screenUV.mul( 100 ).floor().div( 100 ) );
				pixelMaterial.transparent = true;

				// box / floor

				const box = new THREE.Mesh( new THREE.BoxGeometry( 2, 2, 2 ), blurredBlur );
				box.position.set( 0, 1, 0 );
				box.renderOrder = 1;
				scene.add( box );

				const floor = new THREE.Mesh( new THREE.BoxGeometry( 5, .01, 5 ), new THREE.MeshBasicNodeMaterial( {
					color: 0xff6600,
					opacityNode: positionWorld.xz.distance( 0 ).oneMinus().clamp(),
					transparent: true,
					depthWrite: false
				} ) );
				floor.position.set( 0, 0, 0 );
				scene.add( floor );

				// renderer

				renderer = new THREE.WebGPURenderer( /*{ antialias: true }*/ );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = .9;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 1, 0 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const materials = {
					'blurred': blurredBlur,
					'depth': depthMaterial,
					'checker': checkerMaterial,
					'pixel': pixelMaterial
				};

				const options = { material: 'blurred' };
				box.material = materials[ options.material ];

				const gui = renderer.inspector.createParameters( 'Scene settings' );
				gui.add( box.scale, 'x', 0.1, 2, 0.01 ).name( 'box scale x' );
				gui.add( box.scale, 'y', 0.1, 2, 0.01 ).name( 'box scale y' );
				gui.add( options, 'material', Object.keys( materials ) ).onChange( name => {

					box.material = materials[ name ];

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				if ( mixer ) mixer.update( delta );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_backdrop_water.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - backdrop water</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Backdrop Water</span>
			</div>

			<small>Water refraction with depth effect.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, vec2, pass, linearDepth, normalWorld, triplanarTexture, texture, objectPosition, screenUV, viewportLinearDepth, viewportDepthTexture, viewportSharedTexture, mx_worley_noise_float, positionWorld, time } from 'three/tsl';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;
			let mixer, objects, clock;
			let model, floor, floorPosition;
			let postProcessing;
			let controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );
				camera.position.set( 3, 2, 4 );

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x0487e2, 7, 25 );
				scene.backgroundNode = normalWorld.y.mix( color( 0x0487e2 ), color( 0x0066ff ) );
				camera.lookAt( 0, 1, 0 );

				const sunLight = new THREE.DirectionalLight( 0xFFE499, 5 );
				sunLight.castShadow = true;
				sunLight.shadow.camera.near = .1;
				sunLight.shadow.camera.far = 5;
				sunLight.shadow.camera.right = 2;
				sunLight.shadow.camera.left = - 2;
				sunLight.shadow.camera.top = 1;
				sunLight.shadow.camera.bottom = - 2;
				sunLight.shadow.mapSize.width = 2048;
				sunLight.shadow.mapSize.height = 2048;
				sunLight.shadow.bias = - 0.001;
				sunLight.position.set( .5, 3, .5 );

				const waterAmbientLight = new THREE.HemisphereLight( 0x333366, 0x74ccf4, 5 );
				const skyAmbientLight = new THREE.HemisphereLight( 0x74ccf4, 0, 1 );

				scene.add( sunLight );
				scene.add( skyAmbientLight );
				scene.add( waterAmbientLight );

				clock = new THREE.Clock();

				// animated model

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					model = gltf.scene;
					model.children[ 0 ].children[ 0 ].castShadow = true;

					mixer = new THREE.AnimationMixer( model );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					scene.add( model );

				} );

				// objects

				const textureLoader = new THREE.TextureLoader();
				const iceDiffuse = textureLoader.load( './textures/water.jpg' );
				iceDiffuse.wrapS = THREE.RepeatWrapping;
				iceDiffuse.wrapT = THREE.RepeatWrapping;
				iceDiffuse.colorSpace = THREE.NoColorSpace;

				const iceColorNode = triplanarTexture( texture( iceDiffuse ) ).add( color( 0x0066ff ) ).mul( .8 );

				const geometry = new THREE.IcosahedronGeometry( 1, 3 );
				const material = new THREE.MeshStandardNodeMaterial( { colorNode: iceColorNode } );

				const count = 100;
				const scale = 3.5;
				const column = 10;

				objects = new THREE.Group();

				for ( let i = 0; i < count; i ++ ) {

					const x = i % column;
					const y = i / column;

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.set( x * scale, 0, y * scale );
					mesh.rotation.set( Math.random(), Math.random(), Math.random() );
					objects.add( mesh );

				}

				objects.position.set(
					( ( column - 1 ) * scale ) * - .5,
					- 1,
					( ( count / column ) * scale ) * - .5
				);

				scene.add( objects );

				// water

				const timer = time.mul( .8 );
				const floorUV = positionWorld.xzy;

				const waterLayer0 = mx_worley_noise_float( floorUV.mul( 4 ).add( timer ) );
				const waterLayer1 = mx_worley_noise_float( floorUV.mul( 2 ).add( timer ) );

				const waterIntensity = waterLayer0.mul( waterLayer1 );
				const waterColor = waterIntensity.mul( 1.4 ).mix( color( 0x0487e2 ), color( 0x74ccf4 ) );

				// linearDepth() returns the linear depth of the mesh
				const depth = linearDepth();
				const depthWater = viewportLinearDepth.sub( depth ).toInspector( 'Water / Depth', ( node ) => node.oneMinus() );
				const depthEffect = depthWater.remapClamp( - .002, .04 );

				const refractionUV = screenUV.add( vec2( 0, waterIntensity.mul( .1 ) ) ).toInspector( 'Water / Refraction UV' );

				// linearDepth( viewportDepthTexture( uv ) ) return the linear depth of the scene
				const depthTestForRefraction = linearDepth( viewportDepthTexture( refractionUV ) ).sub( depth );

				const depthRefraction = depthTestForRefraction.remapClamp( 0, .1 );

				const finalUV = depthTestForRefraction.lessThan( 0 ).select( screenUV, refractionUV );

				const viewportTexture = viewportSharedTexture( finalUV ).toInspector( 'Water / Viewport Texture + Refraction UV' );

				const waterMaterial = new THREE.MeshBasicNodeMaterial();
				waterMaterial.colorNode = waterColor.toInspector( 'Water / Color' );
				waterMaterial.backdropNode = depthEffect.mix( viewportSharedTexture(), viewportTexture.mul( depthRefraction.mix( 1, waterColor ) ) );
				waterMaterial.backdropAlphaNode = depthRefraction.oneMinus();
				waterMaterial.transparent = true;

				const water = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), waterMaterial );
				water.position.set( 0, 0, 0 );
				scene.add( water );

				// floor

				floor = new THREE.Mesh( new THREE.CylinderGeometry( 1.1, 1.1, 10 ), new THREE.MeshStandardNodeMaterial( { colorNode: iceColorNode } ) );
				floor.position.set( 0, - 5, 0 );
				scene.add( floor );

				// caustics

				const waterPosY = positionWorld.y.sub( water.position.y );

				let transition = waterPosY.add( .1 ).saturate().oneMinus();
				transition = waterPosY.lessThan( 0 ).select( transition, normalWorld.y.mix( transition, 0 ) ).toVar();

				const colorNode = transition.mix( material.colorNode, material.colorNode.add( waterLayer0 ) );

				//material.colorNode = colorNode;
				floor.material.colorNode = colorNode;

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI * 0.9;
				controls.autoRotate = true;
				controls.autoRotateSpeed = 1;
				controls.target.set( 0, .2, 0 );
				controls.update();

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );

				floorPosition = new THREE.Vector3( 0, .2, 0 );

				gui.add( floorPosition, 'y', - 1, 1, .001 ).name( 'floor position' );

				// post processing

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode();
				const scenePassDepth = scenePass.getLinearDepthNode().remapClamp( .3, .5 );

				const waterMask = objectPosition( camera ).y.greaterThan( screenUV.y.sub( .5 ).mul( camera.near ) ).toInspector( 'Post-Processing / Water Mask' );

				const scenePassColorBlurred = gaussianBlur( scenePassColor );
				scenePassColorBlurred.directionNode = waterMask.select( scenePassDepth, scenePass.getLinearDepthNode().mul( 5 ) ).toInspector( 'Post-Processing / Blur Strength [ Depth ]', ( node ) => node.toFloat() );

				const vignette = screenUV.distance( .5 ).mul( 1.35 ).clamp().oneMinus().toInspector( 'Post-Processing / Vignette' );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = waterMask.select( scenePassColorBlurred, scenePassColorBlurred.mul( color( 0x74ccf4 ) ).mul( vignette ) );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				const delta = clock.getDelta();

				floor.position.y = floorPosition.y - 5;

				if ( model ) {

					mixer.update( delta );

					model.position.y = floorPosition.y;

				}

				for ( const object of objects.children ) {

					object.position.y = Math.sin( clock.elapsedTime + object.id ) * .3;
					object.rotation.y += delta * .3;

				}

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_camera.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - cameras</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Camera</span>
			</div>

			<small>Press the "O" key for using an orthographic and "P" key for a perspective camera.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;
			let aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

			let container;
			let camera, scene, renderer, mesh;
			let cameraRig, activeCamera, activeHelper;
			let cameraPerspective, cameraOrtho;
			let cameraPerspectiveHelper, cameraOrthoHelper;
			const frustumSize = 600;

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();

				//

				camera = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 1, 10000 );
				camera.position.z = 2500;

				cameraPerspective = new THREE.PerspectiveCamera( 50, 0.5 * aspect, 150, 1000 );

				cameraPerspectiveHelper = new THREE.CameraHelper( cameraPerspective );
				scene.add( cameraPerspectiveHelper );

				//
				cameraOrtho = new THREE.OrthographicCamera( 0.5 * frustumSize * aspect / - 2, 0.5 * frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 150, 1000 );

				cameraOrthoHelper = new THREE.CameraHelper( cameraOrtho );
				scene.add( cameraOrthoHelper );

				//

				activeCamera = cameraPerspective;
				activeHelper = cameraPerspectiveHelper;


				// counteract different front orientation of cameras vs rig

				cameraOrtho.rotation.y = Math.PI;
				cameraPerspective.rotation.y = Math.PI;

				cameraRig = new THREE.Group();

				cameraRig.add( cameraPerspective );
				cameraRig.add( cameraOrtho );

				scene.add( cameraRig );

				//

				mesh = new THREE.Mesh(
					new THREE.SphereGeometry( 100, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } )
				);
				scene.add( mesh );

				const mesh2 = new THREE.Mesh(
					new THREE.SphereGeometry( 50, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } )
				);
				mesh2.position.y = 150;
				mesh.add( mesh2 );

				const mesh3 = new THREE.Mesh(
					new THREE.SphereGeometry( 5, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true } )
				);
				mesh3.position.z = 150;
				cameraRig.add( mesh3 );

				//

				const geometry = new THREE.BufferGeometry();
				const vertices = [];

				for ( let i = 0; i < 10000; i ++ ) {

					vertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // x
					vertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // y
					vertices.push( THREE.MathUtils.randFloatSpread( 2000 ) ); // z

				}

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

				const particles = new THREE.Points( geometry, new THREE.PointsMaterial( { color: 0xffffff } ) );
				scene.add( particles );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				renderer.setScissorTest( true );
				renderer.setClearColor( 0x000000, 1 );

				//

				window.addEventListener( 'resize', onWindowResize );
				document.addEventListener( 'keydown', onKeyDown );

			}

			//

			function onKeyDown( event ) {

				switch ( event.keyCode ) {

					case 79: /*O*/

						activeCamera = cameraOrtho;
						activeHelper = cameraOrthoHelper;

						break;

					case 80: /*P*/

						activeCamera = cameraPerspective;
						activeHelper = cameraPerspectiveHelper;

						break;

				}

			}

			//

			function onWindowResize() {

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;
				aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				camera.aspect = 0.5 * aspect;
				camera.updateProjectionMatrix();

				cameraPerspective.aspect = 0.5 * aspect;
				cameraPerspective.updateProjectionMatrix();

				cameraOrtho.left = - 0.5 * frustumSize * aspect / 2;
				cameraOrtho.right = 0.5 * frustumSize * aspect / 2;
				cameraOrtho.top = frustumSize / 2;
				cameraOrtho.bottom = - frustumSize / 2;
				cameraOrtho.updateProjectionMatrix();

			}

			//

			function animate() {

				render();

			}


			function render() {

				const r = Date.now() * 0.0005;

				mesh.position.x = 700 * Math.cos( r );
				mesh.position.z = 700 * Math.sin( r );
				mesh.position.y = 700 * Math.sin( r );

				mesh.children[ 0 ].position.x = 70 * Math.cos( 2 * r );
				mesh.children[ 0 ].position.z = 70 * Math.sin( r );

				if ( activeCamera === cameraPerspective ) {

					cameraPerspective.fov = 35 + 30 * Math.sin( 0.5 * r );
					cameraPerspective.far = mesh.position.length();
					cameraPerspective.updateProjectionMatrix();

					cameraPerspectiveHelper.update();
					cameraPerspectiveHelper.visible = true;

					cameraOrthoHelper.visible = false;

				} else {

					cameraOrtho.far = mesh.position.length();
					cameraOrtho.updateProjectionMatrix();

					cameraOrthoHelper.update();
					cameraOrthoHelper.visible = true;

					cameraPerspectiveHelper.visible = false;

				}

				cameraRig.lookAt( mesh.position );

				//

				activeHelper.visible = false;

				renderer.setClearColor( 0x000000, 1 );
				renderer.setScissor( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );
				renderer.setViewport( 0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );
				renderer.render( scene, activeCamera );

				//

				activeHelper.visible = true;

				renderer.setClearColor( 0x111111, 1 );
				renderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );
				renderer.setViewport( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_camera_array.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - arraycamera</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Array Camera</span>
			</div>

			<small>Array cameras allow to render the scene with multiple sub cameras but with a single render call.</small>
		</div>


		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			let camera, scene, renderer;
			let mesh;

			const AMOUNT = 6;

			init();

			function init() {

				const subCameras = [];

				for ( let i = 0; i < AMOUNT * AMOUNT; i ++ ) {

					const subCamera = new THREE.PerspectiveCamera( 40, 1, 0.1, 10 );
					subCamera.viewport = new THREE.Vector4();

					subCameras.push( subCamera );

				}

				camera = new THREE.ArrayCamera( subCameras );
				camera.position.z = 3;

				updateCameras();

				scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0x999999 ) );

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 0.5, 0.5, 1 );
				light.castShadow = true;
				light.shadow.bias = - 0.001;
				light.shadow.camera.zoom = 4; // tighter shadow map
				scene.add( light );

				const geometryBackground = new THREE.PlaneGeometry( 100, 100 );
				const materialBackground = new THREE.MeshPhongMaterial( { color: 0x000066 } );

				const background = new THREE.Mesh( geometryBackground, materialBackground );
				background.receiveShadow = true;
				background.position.set( 0, 0, - 1 );
				scene.add( background );

				const geometryCylinder = new THREE.CylinderGeometry( 0.5, 0.5, 1, 32 );
				const materialCylinder = new THREE.MeshPhongMaterial( { color: 0xff0000 } );

				mesh = new THREE.Mesh( geometryCylinder, materialCylinder );
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				scene.add( mesh );

				renderer = new THREE.WebGPURenderer( /*{ forceWebGL: true }*/ );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function updateCameras() {

				const ASPECT_RATIO = window.innerWidth / window.innerHeight;
				const WIDTH = window.innerWidth / AMOUNT;
				const HEIGHT = window.innerHeight / AMOUNT;

				camera.aspect = ASPECT_RATIO;
				camera.updateProjectionMatrix();

				for ( let y = 0; y < AMOUNT; y ++ ) {

					for ( let x = 0; x < AMOUNT; x ++ ) {

						const subcamera = camera.cameras[ AMOUNT * y + x ];
						subcamera.copy( camera ); // copy fov, aspect ratio, near, far from the root camera

						subcamera.viewport.set( Math.floor( x * WIDTH ), Math.floor( y * HEIGHT ), Math.ceil( WIDTH ), Math.ceil( HEIGHT ) );
						subcamera.updateProjectionMatrix();

						subcamera.position.x = ( x / AMOUNT ) - 0.5;
						subcamera.position.y = 0.5 - ( y / AMOUNT );
						subcamera.position.z = 1.5 + ( ( x + y ) * .5 );
						subcamera.position.multiplyScalar( 2 );

						subcamera.lookAt( 0, 0, 0 );
						subcamera.updateMatrixWorld();

					}

				}

			}

			function onWindowResize() {

				updateCameras();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				mesh.rotation.x += 0.005;
				mesh.rotation.z += 0.01;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_camera_logarithmicdepthbuffer.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - logarithmic depth buffer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>

			body{
				touch-action: none;
			}

			.renderer_label {
				position: absolute;
				bottom: 1em;
				width: 100%;
				color: white;
				z-index: 10;
				display: block;
				text-align: center;
			}

			#container {
				display: flex;
			}

			#container_normal {
				width: 50%;
				display: inline-block;
				position: relative;
			}

			#container_logzbuf {
				width: 50%;
				display: inline-block;
				position: relative;
			}

			#renderer_border {
				position: absolute;
				top: 0;
				left: 25%;
				bottom: 0;
				width: 2px;
				z-index: 10;
				opacity: .8;
				background: #ccc;
				border: 1px inset #ccc;
				cursor: col-resize;
			}

		</style>

	</head>
	<body>

		<div id="container">
			<div id="container_normal"><h2 class="renderer_label">normal z-buffer</h2></div>
			<div id="container_logzbuf"><h2 class="renderer_label">logarithmic z-buffer</h2></div>
			<div id="renderer_border"></div>
		</div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Logarithmic Depth Buffer</span>
			</div>

			<small>Mousewheel to dolly out.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

			// 1 micrometer to 100 billion light years in one scene, with 1 unit = 1 meter?  preposterous!  and yet...
			const NEAR = 1e-6, FAR = 1e27;
			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;
			let screensplit = .25, screensplit_right = 0;
			const mouse = [ .5, .5 ];
			let zoompos = - 100, minzoomspeed = .015;
			let zoomspeed = minzoomspeed;

			let container, border;
			const objects = {};

			// Generate a number of text labels, from 1µm in size up to 100,000,000 light years
			// Try to use some descriptive real-world examples of objects at each scale

			const labeldata = [
				{ size: .01, scale: 0.0001, label: 'microscopic (1µm)' }, // FIXME - triangulating text fails at this size, so we scale instead
				{ size: .01, scale: 0.1, label: 'minuscule (1mm)' },
				{ size: .01, scale: 1.0, label: 'tiny (1cm)' },
				{ size: 1, scale: 1.0, label: 'child-sized (1m)' },
				{ size: 10, scale: 1.0, label: 'tree-sized (10m)' },
				{ size: 100, scale: 1.0, label: 'building-sized (100m)' },
				{ size: 1000, scale: 1.0, label: 'medium (1km)' },
				{ size: 10000, scale: 1.0, label: 'city-sized (10km)' },
				{ size: 3400000, scale: 1.0, label: 'moon-sized (3,400 Km)' },
				{ size: 12000000, scale: 1.0, label: 'planet-sized (12,000 km)' },
				{ size: 1400000000, scale: 1.0, label: 'sun-sized (1,400,000 km)' },
				{ size: 7.47e12, scale: 1.0, label: 'solar system-sized (50Au)' },
				{ size: 9.4605284e15, scale: 1.0, label: 'gargantuan (1 light year)' },
				{ size: 3.08567758e16, scale: 1.0, label: 'ludicrous (1 parsec)' },
				{ size: 1e19, scale: 1.0, label: 'mind boggling (1000 light years)' }
			];

			init().then( animate );

			async function init() {

				container = document.getElementById( 'container' );

				const loader = new FontLoader();
				const font = await loader.loadAsync( 'fonts/helvetiker_regular.typeface.json' );

				const scene = initScene( font );

				// Initialize two copies of the same scene, one with normal z-buffer and one with logarithmic z-buffer
				objects.normal = await initView( scene, 'normal', false );
				objects.logzbuf = await initView( scene, 'logzbuf', true );

				// Resize border allows the user to easily compare effects of logarithmic depth buffer over the whole scene
				border = document.getElementById( 'renderer_border' );
				border.addEventListener( 'pointerdown', onBorderPointerDown );

				window.addEventListener( 'mousemove', onMouseMove );
				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'wheel', onMouseWheel );

			}

			async function initView( scene, name, logDepthBuf ) {

				const framecontainer = document.getElementById( 'container_' + name );

				const camera = new THREE.PerspectiveCamera( 50, screensplit * SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
				scene.add( camera );

				const renderer = new THREE.WebGPURenderer( { antialias: true, logarithmicDepthBuffer: logDepthBuf } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH / 2, SCREEN_HEIGHT );
				renderer.domElement.style.position = 'relative';
				renderer.domElement.id = 'renderer_' + name;
				renderer.inspector = new Inspector();
				framecontainer.appendChild( renderer.domElement );

				await renderer.init();

				return { container: framecontainer, renderer: renderer, scene: scene, camera: camera };

			}

			function initScene( font ) {

				const scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0x777777 ) );

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 100, 100, 100 );
				scene.add( light );

				const materialargs = {
					color: 0xffffff,
					specular: 0x050505,
					shininess: 50,
					emissive: 0x000000
				};

				const geometry = new THREE.SphereGeometry( 0.5, 24, 12 );

				for ( let i = 0; i < labeldata.length; i ++ ) {

					const scale = labeldata[ i ].scale || 1;

					const labelgeo = new TextGeometry( labeldata[ i ].label, {
						font: font,
						size: labeldata[ i ].size,
						depth: labeldata[ i ].size / 2
					} );

					labelgeo.computeBoundingSphere();

					// center text
					labelgeo.translate( - labelgeo.boundingSphere.radius, 0, 0 );

					materialargs.color = new THREE.Color().setHSL( Math.random(), 0.5, 0.5 );

					const material = new THREE.MeshPhongMaterial( materialargs );

					const group = new THREE.Group();
					group.position.z = - labeldata[ i ].size * scale;
					scene.add( group );

					const textmesh = new THREE.Mesh( labelgeo, material );
					textmesh.scale.set( scale, scale, scale );
					textmesh.position.z = - labeldata[ i ].size * scale;
					textmesh.position.y = labeldata[ i ].size / 4 * scale;
					group.add( textmesh );

					const dotmesh = new THREE.Mesh( geometry, material );
					dotmesh.position.y = - labeldata[ i ].size / 4 * scale;
					dotmesh.scale.multiplyScalar( labeldata[ i ].size * scale );
					group.add( dotmesh );

				}

				return scene;

			}

			function updateRendererSizes() {

				// Recalculate size for both renderers when screen size or split location changes

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;

				screensplit_right = 1 - screensplit;

				objects.normal.renderer.setSize( screensplit * SCREEN_WIDTH, SCREEN_HEIGHT );
				objects.normal.camera.aspect = screensplit * SCREEN_WIDTH / SCREEN_HEIGHT;
				objects.normal.camera.updateProjectionMatrix();
				objects.normal.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH * screensplit, SCREEN_HEIGHT );
				objects.normal.container.style.width = ( screensplit * 100 ) + '%';

				objects.logzbuf.renderer.setSize( screensplit_right * SCREEN_WIDTH, SCREEN_HEIGHT );
				objects.logzbuf.camera.aspect = screensplit_right * SCREEN_WIDTH / SCREEN_HEIGHT;
				objects.logzbuf.camera.updateProjectionMatrix();
				objects.logzbuf.camera.setViewOffset( SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_WIDTH * screensplit, 0, SCREEN_WIDTH * screensplit_right, SCREEN_HEIGHT );
				objects.logzbuf.container.style.width = ( screensplit_right * 100 ) + '%';

				border.style.left = ( screensplit * 100 ) + '%';

			}

			function animate() {

				requestAnimationFrame( animate );

				// Put some limits on zooming
				const minzoom = labeldata[ 0 ].size * labeldata[ 0 ].scale * 1;
				const maxzoom = labeldata[ labeldata.length - 1 ].size * labeldata[ labeldata.length - 1 ].scale * 100;
				let damping = ( Math.abs( zoomspeed ) > minzoomspeed ? .95 : 1.0 );

				// Zoom out faster the further out you go
				const zoom = THREE.MathUtils.clamp( Math.pow( Math.E, zoompos ), minzoom, maxzoom );
				zoompos = Math.log( zoom );

				// Slow down quickly at the zoom limits
				if ( ( zoom == minzoom && zoomspeed < 0 ) || ( zoom == maxzoom && zoomspeed > 0 ) ) {

					damping = .85;

				}

				zoompos += zoomspeed;
				zoomspeed *= damping;

				objects.normal.camera.position.x = Math.sin( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;
				objects.normal.camera.position.y = Math.sin( .25 * Math.PI * ( mouse[ 1 ] - .5 ) ) * zoom;
				objects.normal.camera.position.z = Math.cos( .5 * Math.PI * ( mouse[ 0 ] - .5 ) ) * zoom;
				objects.normal.camera.lookAt( objects.normal.scene.position );

				// Clone camera settings across both scenes
				objects.logzbuf.camera.position.copy( objects.normal.camera.position );
				objects.logzbuf.camera.quaternion.copy( objects.normal.camera.quaternion );

				// Update renderer sizes if the split has changed
				if ( screensplit_right != 1 - screensplit ) {

					updateRendererSizes();

				}

				objects.normal.renderer.render( objects.normal.scene, objects.normal.camera );
				objects.logzbuf.renderer.render( objects.logzbuf.scene, objects.logzbuf.camera );

			}

			function onWindowResize() {

				updateRendererSizes();

			}

			function onBorderPointerDown() {

				// activate draggable window resizing bar
				window.addEventListener( 'pointermove', onBorderPointerMove );
				window.addEventListener( 'pointerup', onBorderPointerUp );

			}

			function onBorderPointerMove( ev ) {

				screensplit = Math.max( 0, Math.min( 1, ev.clientX / window.innerWidth ) );

			}

			function onBorderPointerUp() {

				window.removeEventListener( 'pointermove', onBorderPointerMove );
				window.removeEventListener( 'pointerup', onBorderPointerUp );

			}

			function onMouseMove( ev ) {

				mouse[ 0 ] = ev.clientX / window.innerWidth;
				mouse[ 1 ] = ev.clientY / window.innerHeight;

			}

			function onMouseWheel( ev ) {

				const amount = ev.deltaY;
				if ( amount === 0 ) return;
				const dir = amount / Math.abs( amount );
				zoomspeed = dir / 10;

				// Slow down default zoom speed after user starts zooming, to give them more control
				minzoomspeed = 0.001;

			}
		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_caustics.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - caustics</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Caustics</span>
			</div>

			<small>Realtime caustics effect.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { uniform, refract, div, positionViewDirection, positionLocal, normalView, texture, Fn, vec2, vec3, vec4 } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, controls;
			let gltf;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.025, 5 );
				camera.position.set( - 0.5, 0.35, 0.2 );

				scene = new THREE.Scene();

				// light

				const spotLight = new THREE.SpotLight( 0xffffff, 1 );
				spotLight.position.set( .2, .3, .2 );
				spotLight.castShadow = true;
				spotLight.angle = Math.PI / 6;
				spotLight.penumbra = 1;
				spotLight.decay = 2;
				spotLight.distance = 0;
				spotLight.shadow.mapType = THREE.HalfFloatType; // For HDR Caustics
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = .1;
				spotLight.shadow.camera.far = 1;
				spotLight.shadow.bias = - .003;
				spotLight.shadow.intensity = .95;
				scene.add( spotLight );

				// model / textures

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/' );
				dracoLoader.setDecoderConfig( { type: 'js' } );

				gltf = ( await new GLTFLoader().setDRACOLoader( dracoLoader ).loadAsync( './models/gltf/duck.glb' ) ).scene;
				gltf.scale.setScalar( .5 );
				scene.add( gltf );

				const causticMap = new THREE.TextureLoader().load( './textures/opengameart/Caustic_Free.jpg' );
				causticMap.wrapS = causticMap.wrapT = THREE.RepeatWrapping;
				causticMap.colorSpace = THREE.SRGBColorSpace;

				// objects / material

				const duck = gltf.children[ 0 ];
				duck.material = new THREE.MeshPhysicalNodeMaterial();
				duck.material.side = THREE.DoubleSide;
				duck.material.transparent = true;
				duck.material.color = new THREE.Color( 0xFFD700 );
				duck.material.transmission = 1;
				duck.material.thickness = .25;
				duck.material.ior = 1.5;
				duck.material.metalness = 0;
				duck.material.roughness = .1;
				duck.castShadow = true;

				// tsl shader

				const causticOcclusion = uniform( 20 );

				duck.material.castShadowPositionNode = Fn( () => {

					// optional: add some distortion to the geometry shadow position if needed

					return positionLocal;

				} )();

				duck.material.castShadowNode = Fn( () => {

					const refractionVector = refract( positionViewDirection.negate(), normalView, div( 1.0, duck.material.ior ) ).normalize();
					const viewZ = normalView.z.pow( causticOcclusion );

					const textureUV = refractionVector.xy.mul( .6 );

					const causticColor = uniform( duck.material.color );
					const chromaticAberrationOffset = normalView.z.pow( - .9 ).mul( .004 );

					const causticProjection = vec3(
						texture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x.negate(), 0 ) ) ).r,
						texture( causticMap, textureUV.add( vec2( 0, chromaticAberrationOffset.y.negate() ) ) ).g,
						texture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x, chromaticAberrationOffset.y ) ) ).b
					);

					return causticProjection.mul( viewZ.mul( 25 ) ).add( viewZ ).mul( causticColor );

				} )();

				//

				const textureLoader = new THREE.TextureLoader();

				// glass

				const colorMap = textureLoader.load( 'textures/colors.png' );
				colorMap.wrapS = colorMap.wrapT = THREE.RepeatWrapping;
				colorMap.colorSpace = THREE.SRGBColorSpace;

				const glassMaterial = new THREE.MeshPhysicalNodeMaterial();
				glassMaterial.map = colorMap;
				glassMaterial.side = THREE.DoubleSide;
				glassMaterial.transparent = true;
				glassMaterial.color = new THREE.Color( 0xffffff );
				glassMaterial.transmission = 1;
				glassMaterial.ior = 1.5;
				glassMaterial.metalness = 0;
				glassMaterial.roughness = .1;
				glassMaterial.castShadowNode = vec4( texture( colorMap ).rgb, .8 );

				const glass = new THREE.Mesh( new THREE.PlaneGeometry( .2, .2 ), glassMaterial );
				glass.position.y = .1;
				glass.castShadow = true;
				glass.visible = false;
				scene.add( glass );

				// ground

				const map = textureLoader.load( 'textures/hardwood2_diffuse.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.repeat.set( 10, 10 );

				const geometry = new THREE.PlaneGeometry( 2, 2 );
				const material = new THREE.MeshStandardMaterial( { color: 0x999999, map } );

				const ground = new THREE.Mesh( geometry, material );
				ground.rotation.x = - Math.PI / 2;
				ground.receiveShadow = true;
				scene.add( ground );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( causticOcclusion, 'value', 0, 20 ).name( 'caustic occlusion' );
				gui.addColor( duck.material, 'color' ).name( 'material color' );
				gui.add( { model: 'duck' }, 'model', [
					'duck',
					'glass'
				] ).onChange( model => {

					duck.visible = glass.visible = false;

					if ( model === 'duck' ) {

						duck.visible = true;

					} else if ( model === 'glass' ) {

						glass.visible = true;

					}

				} );


				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxDistance = 3;
				controls.maxPolarAngle = Math.PI / 2;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				for ( const mesh of gltf.children ) {

					mesh.rotation.y -= .01;

				}

				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_centroid_sampling.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - centroid sampling</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<style>

		body {
			margin: 0;
			overflow: hidden;
			width: 100vw;
			height: 100vh;
		}

		#demo {
			display: flex;
			flex-direction: row;
			align-items: center;
		}

		.renderer-wrapper {
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		#antialiasing-disabled {
			border-right: 1px solid black;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

	</style>
	<body>

		<div id="demo">
			<div id="antialiasing-disabled" class="renderer-wrapper">
				<div>antialiasing disabled</div>
			</div>
			<div id="antialiasing-enabled" class="renderer-wrapper">
				<div>antialiasing enabled</div>
			</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { varying, uv, texture, Fn } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let rendererAntialiasingEnabled;
			let rendererAntialiasingDisabled;
			let camera;
			let scene;
			let gui;

			const effectController = {
				sampling: 'normal'
			};

			const atlasCanvas = document.createElement( 'canvas' );
			atlasCanvas.width = 16;
			atlasCanvas.height = 16;

			const ctx = atlasCanvas.getContext( '2d' );
			ctx.fillStyle = 'red';
			ctx.fillRect( 0, 0, 8, 8 );

			const redUVs = [ 0, 1, 0.5, 1, 0.5, 0.5, 0, 0.5 ];
			ctx.fillStyle = 'green';
			ctx.fillRect( 8, 0, 8, 8 );

			const greenUVs = [ 1, 1, 0.5, 1, 0.5, 0.5, 1, 0.5 ];

			ctx.fillStyle = 'blue';
			ctx.fillRect( 0, 8, 8, 8 );

			const blueUVs = [ 0, 0, 0.5, 0, 0.5, 0.5, 0, 0.5 ];

			ctx.fillStyle = 'yellow';
			ctx.fillRect( 8, 8, 8, 8 );

			const yellowUVs = [ 1, 0, 0.5, 0, 0.5, 0.5, 1, 0.5 ];

			const faces = [ redUVs, greenUVs, blueUVs, yellowUVs ];

			const canvasTexture = new THREE.CanvasTexture( atlasCanvas );
			canvasTexture.colorSpace = THREE.SRGBColorSpace;
			canvasTexture.mapping = THREE.UVMapping;
			canvasTexture.wrapS = THREE.RepeatWrapping;
			canvasTexture.wrapT = THREE.RepeatWrapping;
			canvasTexture.magFilter = THREE.NearestFilter;
			canvasTexture.minFilter = THREE.NearestFilter;
			canvasTexture.format = THREE.RGBAFormat;
			canvasTexture.type = THREE.UnsignedByteType;

			const forceWebGL = false;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera();
				camera.fov = 60;
				camera.near = 1;
				camera.far = 2100;
				camera.position.z = 50;

				scene = new THREE.Scene();

				const makeFaceGeometry = ( uvs ) => {

					const geometry = new THREE.BufferGeometry();
					const positions = [ - 1, - 1, 0, 1, - 1, 0, 1, 1, 0, - 1, 1, 0 ];
					geometry.setAttribute(
						'position',
						new THREE.BufferAttribute( new Float32Array( positions ), 3 )
					);

					const indices = [ 0, 1, 2, 2, 3, 0 ];
					geometry.setIndex( indices );

					geometry.setAttribute(
						'uv',
						new THREE.BufferAttribute( new Float32Array( uvs ), 2 )
					);

					return geometry;

				};

				const material = new THREE.MeshBasicNodeMaterial();
				const testUV = varying( uv(), 'testUV' );

				const createShader = ( type, sampling ) => {

					return Fn( () => {

						testUV.setInterpolation( type, sampling );

						return texture( canvasTexture, testUV ).rgb;

					} );

				};

				const withFlatFirstShader = createShader( THREE.InterpolationSamplingType.FLAT, THREE.InterpolationSamplingMode.FIRST );
				const withFlatEitherShader = createShader( THREE.InterpolationSamplingType.FLAT, THREE.InterpolationSamplingMode.EITHER );

				const withSampleShader = Fn( () => {

					testUV.setInterpolation( THREE.InterpolationSamplingType.PERSPECTIVE, THREE.InterpolationSamplingMode.SAMPLE );

					return texture( canvasTexture, testUV ).rgb;

				} );

				const withInterpolationShader = Fn( () => {

					testUV.setInterpolation( THREE.InterpolationSamplingType.PERSPECTIVE, THREE.InterpolationSamplingMode.CENTROID );

					return texture( canvasTexture, testUV ).rgb;

				} );

				const withoutInterpolationShader = Fn( () => {

					return texture( canvasTexture, uv() ).rgb;

				} );

				material.colorNode = withoutInterpolationShader();

				const faceMeshes = [];

				for ( let x = - 5; x < 5; x ++ ) {

					for ( let y = - 5; y < 5; y ++ ) {

						const face = faces[ Math.floor( Math.random() * faces.length ) ];
						const geometry = makeFaceGeometry( face );
						const mesh = new THREE.Mesh( geometry, material );
						mesh.position.set( x * 2, y * 2, 0 );
						faceMeshes.push( mesh );
						scene.add( mesh );

					}

				}

				// Create Standard Renderer
				rendererAntialiasingDisabled = new THREE.WebGPURenderer( {
					antialias: false,
					forceWebGL: forceWebGL
				} );

				rendererAntialiasingDisabled.setPixelRatio( window.devicePixelRatio );
				rendererAntialiasingDisabled.setSize( window.innerWidth / 2, window.innerHeight );
				rendererAntialiasingDisabled.setAnimationLoop( animateStandard );

				// Create antialiased renderer
				rendererAntialiasingEnabled = new THREE.WebGPURenderer( {
					antialias: true,
					forceWebGL: forceWebGL
				} );

				document.body.querySelector( '#antialiasing-enabled' ).appendChild( rendererAntialiasingEnabled.domElement );
				rendererAntialiasingEnabled.setPixelRatio( window.devicePixelRatio );
				rendererAntialiasingEnabled.setSize( window.innerWidth / 2, window.innerHeight );
				rendererAntialiasingEnabled.setAnimationLoop( animateAliased );
				rendererAntialiasingEnabled.inspector = new Inspector();

				document.body.querySelector( '#antialiasing-disabled' ).appendChild( rendererAntialiasingDisabled.domElement );
				document.body.querySelector( '#antialiasing-disabled' ).appendChild( rendererAntialiasingDisabled.domElement );

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize );

				gui = rendererAntialiasingEnabled.inspector.createParameters( 'Settings' );
				gui.add( effectController, 'sampling', [
					THREE.InterpolationSamplingMode.NORMAL,
					THREE.InterpolationSamplingMode.CENTROID,
					THREE.InterpolationSamplingMode.SAMPLE,
					'flat first',
					'flat either'
				] ).onChange( () => {

					const interpolationShaderLib = {
						[ THREE.InterpolationSamplingMode.NORMAL ]: withoutInterpolationShader,
						[ THREE.InterpolationSamplingMode.CENTROID ]: withInterpolationShader,
						[ THREE.InterpolationSamplingMode.SAMPLE ]: withSampleShader,
						[ 'flat first' ]: withFlatFirstShader,
						[ 'flat either' ]: withFlatEitherShader
					};

					const shader = interpolationShaderLib[ effectController.sampling ];

					for ( let i = 0; i < faceMeshes.length; i ++ ) {

						faceMeshes[ i ].material.colorNode = shader();
						faceMeshes[ i ].material.needsUpdate = true;

					}


				} );

			}

			function onWindowResize() {

				const halfWidth = window.innerWidth / 2;
				rendererAntialiasingDisabled.setSize( halfWidth, window.innerHeight );
				rendererAntialiasingEnabled.setSize( halfWidth, window.innerHeight );
				const aspect = ( halfWidth ) / window.innerHeight;

				camera.aspect = aspect;
				camera.updateProjectionMatrix();

			}

			function animateStandard() {

				rendererAntialiasingDisabled.render( scene, camera );

			}

			function animateAliased() {

				rendererAntialiasingEnabled.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_clearcoat.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - materials - clearcoat</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Clearcoat</span>
			</div>

			<small>PBR Clearcoat effect.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';

			import { FlakesTexture } from 'three/addons/textures/FlakesTexture.js';

			let camera, scene, renderer;

			let particleLight;
			let group;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.25, 50 );
				camera.position.z = 10;

				scene = new THREE.Scene();

				group = new THREE.Group();
				scene.add( group );

				new HDRCubeTextureLoader()
					.setPath( 'textures/cube/pisaHDR/' )
					.load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],
						function ( texture ) {

							const geometry = new THREE.SphereGeometry( .8, 64, 32 );

							const textureLoader = new THREE.TextureLoader();

							const diffuse = textureLoader.load( 'textures/carbon/Carbon.png' );
							diffuse.colorSpace = THREE.SRGBColorSpace;
							diffuse.wrapS = THREE.RepeatWrapping;
							diffuse.wrapT = THREE.RepeatWrapping;
							diffuse.repeat.x = 10;
							diffuse.repeat.y = 10;

							const normalMap = textureLoader.load( 'textures/carbon/Carbon_Normal.png' );
							normalMap.wrapS = THREE.RepeatWrapping;
							normalMap.wrapT = THREE.RepeatWrapping;
							normalMap.repeat.x = 10;
							normalMap.repeat.y = 10;

							const normalMap2 = textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );

							const normalMap3 = new THREE.CanvasTexture( new FlakesTexture() );
							normalMap3.wrapS = THREE.RepeatWrapping;
							normalMap3.wrapT = THREE.RepeatWrapping;
							normalMap3.repeat.x = 10;
							normalMap3.repeat.y = 6;
							normalMap3.anisotropy = 16;

							const normalMap4 = textureLoader.load( 'textures/golfball.jpg' );

							const clearcoatNormalMap = textureLoader.load( 'textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png' );

							// car paint

							let material = new THREE.MeshPhysicalMaterial( {
								clearcoat: 1.0,
								clearcoatRoughness: 0.1,
								metalness: 0.9,
								roughness: 0.5,
								color: 0x0000ff,
								normalMap: normalMap3,
								normalScale: new THREE.Vector2( 0.15, 0.15 )
							} );
							let mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = - 1;
							mesh.position.y = 1;
							group.add( mesh );

							// fibers

							material = new THREE.MeshPhysicalMaterial( {
								roughness: 0.5,
								clearcoat: 1.0,
								clearcoatRoughness: 0.1,
								map: diffuse,
								normalMap: normalMap
							} );
							mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = 1;
							mesh.position.y = 1;
							group.add( mesh );

							// golf

							material = new THREE.MeshPhysicalMaterial( {
								metalness: 0.0,
								roughness: 0.1,
								clearcoat: 1.0,
								normalMap: normalMap4,
								clearcoatNormalMap: clearcoatNormalMap,

								// y scale is negated to compensate for normal map handedness.
								clearcoatNormalScale: new THREE.Vector2( 2.0, - 2.0 )
							} );
							mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = - 1;
							mesh.position.y = - 1;
							group.add( mesh );

							// clearcoat + normalmap

							material = new THREE.MeshPhysicalMaterial( {
								clearcoat: 1.0,
								metalness: 1.0,
								color: 0xff0000,
								normalMap: normalMap2,
								normalScale: new THREE.Vector2( 0.15, 0.15 ),
								clearcoatNormalMap: clearcoatNormalMap,

								// y scale is negated to compensate for normal map handedness.
								clearcoatNormalScale: new THREE.Vector2( 2.0, - 2.0 )
							} );
							mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = 1;
							mesh.position.y = - 1;
							group.add( mesh );

							//

							scene.background = texture;
							scene.environment = texture;

						}

					);

				// LIGHTS

				particleLight = new THREE.Mesh(
					new THREE.SphereGeometry( .05, 8, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				scene.add( particleLight );

				particleLight.add( new THREE.PointLight( 0xffffff, 30 ) );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				//

				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.25;
				renderer.inspector = new Inspector();

				// EVENTS

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 3;
				controls.maxDistance = 30;

				window.addEventListener( 'resize', onWindowResize );

			}

			//

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			//

			function animate() {

				render();

			}

			function render() {

				const timer = Date.now() * 0.00025;

				particleLight.position.x = Math.sin( timer * 7 ) * 3;
				particleLight.position.y = Math.cos( timer * 5 ) * 4;
				particleLight.position.z = Math.cos( timer * 3 ) * 3;

				for ( let i = 0; i < group.children.length; i ++ ) {

					const child = group.children[ i ];
					child.rotation.y += 0.005;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_clipping.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - clipping planes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Clipping Planes</span>
			</div>

			<small>Clipping 3D objects via Clipping Planes.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, startTime, object;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.25, 16 );

				camera.position.set( 0, 1.3, 3 );

				scene = new THREE.Scene();

				// Lights

				scene.add( new THREE.AmbientLight( 0xcccccc ) );

				const spotLight = new THREE.SpotLight( 0xffffff, 60 );
				spotLight.angle = Math.PI / 5;
				spotLight.penumbra = 0.2;
				spotLight.position.set( 2, 3, 3 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 3;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.mapSize.width = 2048;
				spotLight.shadow.mapSize.height = 2048;
				spotLight.shadow.bias = - 0.002;
				spotLight.shadow.radius = 4;
				scene.add( spotLight );

				const dirLight = new THREE.DirectionalLight( 0x55505a, 3 );
				dirLight.position.set( 0, 3, 0 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 10;

				dirLight.shadow.camera.right = 1;
				dirLight.shadow.camera.left = - 1;
				dirLight.shadow.camera.top	= 1;
				dirLight.shadow.camera.bottom = - 1;

				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;
				scene.add( dirLight );

				// Clipping planes

				const globalPlane = new THREE.Plane( new THREE.Vector3( - 1, 0, 0 ), 0.1 );
				const localPlane1 = new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0.8 );
				const localPlane2 = new THREE.Plane( new THREE.Vector3( 0, 0, - 1 ), 0.1 );

				// Clipping Groups

				const globalClippingGroup = new THREE.ClippingGroup();
				globalClippingGroup.clippingPlanes = [ globalPlane ];

				const knotClippingGroup = new THREE.ClippingGroup();
				knotClippingGroup.clippingPlanes = [ localPlane1, localPlane2 ];
				knotClippingGroup.clipIntersection = true;

				scene.add( globalClippingGroup );
				globalClippingGroup.add( knotClippingGroup );

				// Geometry

				const material = new THREE.MeshPhongNodeMaterial( {
					color: 0x80ee10,
					shininess: 0,
					side: THREE.DoubleSide,

					// ***** Clipping setup (material): *****
					alphaToCoverage: true
				} );

				const geometry = new THREE.TorusKnotGeometry( 0.4, 0.08, 95, 20 );

				object = new THREE.Mesh( geometry, material );
				object.castShadow = true;
				knotClippingGroup.add( object );

				const ground = new THREE.Mesh(
					new THREE.PlaneGeometry( 9, 9, 1, 1 ),
					new THREE.MeshPhongNodeMaterial( { color: 0xa0adaf, shininess: 150, alphaToCoverage: true } )
				);

				ground.rotation.x = - Math.PI / 2; // rotates X/Y to X/Z
				ground.receiveShadow = true;
				globalClippingGroup.add( ground );

				// Renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				window.addEventListener( 'resize', onWindowResize );
				document.body.appendChild( renderer.domElement );

				// Controls

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 1, 0 );
				controls.update();

				// GUI

				const gui = renderer.inspector.createParameters( 'Clipping settings' );
				const props = {
					alphaToCoverage: true,
				};
			
				const folderKnot = gui.addFolder( 'Knot Clipping Group' );
				const propsKnot = {

					get 'Enabled'() {

						return knotClippingGroup.enabled;

					},
					set 'Enabled'( v ) {

						knotClippingGroup.enabled = v;

					},

					get 'Shadows'() {

						return knotClippingGroup.clipShadows;

					},
					set 'Shadows'( v ) {

						knotClippingGroup.clipShadows = v;

					},

					get 'Intersection'() {

						return knotClippingGroup.clipIntersection;

					},

					set 'Intersection'( v ) {

						knotClippingGroup.clipIntersection = v;

					},

					get 'Plane'() {

						return localPlane1.constant;

					},
					set 'Plane'( v ) {

						localPlane1.constant = v;

					}

				};

				const folderGlobal = gui.addFolder( 'Global Clipping Group' );
				const propsGlobal = {

					get 'Enabled'() {

						return globalClippingGroup.enabled;

					},
					set 'Enabled'( v ) {

						globalClippingGroup.enabled = v;

					},

					get 'Plane'() {

						return globalPlane.constant;

					},
					set 'Plane'( v ) {

						globalPlane.constant = v;

					}

				};

				gui.add( props, 'alphaToCoverage' ).onChange( function ( value ) {

					ground.material.alphaToCoverage = value;
					ground.material.needsUpdate = true;

					material.alphaToCoverage = value;
					material.needsUpdate = true;

				} );

				folderKnot.add( propsKnot, 'Enabled' );
				folderKnot.add( propsKnot, 'Shadows' );
				folderKnot.add( propsKnot, 'Intersection' );
				folderKnot.add( propsKnot, 'Plane', 0.3, 1.25 );

				folderGlobal.add( propsGlobal, 'Enabled' );
				folderGlobal.add( propsGlobal, 'Plane', - 0.4, 3 );

				// Start

				startTime = Date.now();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate( currentTime ) {

				const time = ( currentTime - startTime ) / 1000;

				object.position.y = 0.8;
				object.rotation.x = time * 0.5;
				object.rotation.y = time * 0.2;
				object.scale.setScalar( Math.cos( time ) * 0.125 + 0.875 );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_audio.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - audio processing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="overlay">
			<button id="startButton">Play</button>
		</div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Audio Processing</span>
			</div>

			<small>Click on screen to process the audio using WebGPU.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, uniform, instanceIndex, instancedArray, float, texture, screenUV, color } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let computeNode;
			let waveBuffer, sampleRate;
			let waveArray;
			let currentAudio, currentAnalyser;
			const analyserBuffer = new Uint8Array( 1024 );
			let analyserTexture;

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', init );

			async function playAudioBuffer() {

				if ( currentAudio ) currentAudio.stop();

				// compute audio

				renderer.compute( computeNode );

				const wave = new Float32Array( await renderer.getArrayBufferAsync( waveArray.value ) );

				// play result

				const audioOutputContext = new AudioContext( { sampleRate } );
				const audioOutputBuffer = audioOutputContext.createBuffer( 1, wave.length, sampleRate );

				audioOutputBuffer.copyToChannel( wave, 0 );

				const source = audioOutputContext.createBufferSource();
				source.connect( audioOutputContext.destination );
				source.buffer = audioOutputBuffer;
				source.start();

				currentAudio = source;

				// visual feedback

				currentAnalyser = audioOutputContext.createAnalyser();
				currentAnalyser.fftSize = 2048;

				source.connect( currentAnalyser );

			}

			async function init() {

				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				// audio buffer

				const soundBuffer = await fetch( 'sounds/webgpu-audio-processing.mp3' ).then( res => res.arrayBuffer() );
				const audioContext = new AudioContext();

				const audioBuffer = await audioContext.decodeAudioData( soundBuffer );

				waveBuffer = audioBuffer.getChannelData( 0 );

				// adding extra silence to delay and pitch
				waveBuffer = new Float32Array( [ ...waveBuffer, ...new Float32Array( 200000 ) ] );

				sampleRate = audioBuffer.sampleRate / audioBuffer.numberOfChannels;

				// create webgpu buffers

				waveArray = instancedArray( waveBuffer );

				// read-only buffer

				const originalWave = instancedArray( waveBuffer ).toReadOnly();

				// The Pixel Buffer Object (PBO) is required to get the GPU computed data to the CPU in the WebGL2 fallback.
				// As used in `renderer.getArrayBufferAsync( waveArray.value )`.

				originalWave.setPBO( true );
				waveArray.setPBO( true );

				// params

				const pitch = uniform( 1.5 );
				const delayVolume = uniform( .2 );
				const delayOffset = uniform( .55 );


				// compute (shader-node)

				const computeShaderFn = Fn( () => {

					const index = float( instanceIndex );

					// pitch

					const time = index.mul( pitch );

					let wave = originalWave.element( time );


					// delay

					for ( let i = 1; i < 7; i ++ ) {

						const waveOffset = originalWave.element( index.sub( delayOffset.mul( sampleRate ).mul( i ) ).mul( pitch ) );
						const waveOffsetVolume = waveOffset.mul( delayVolume.div( i * i ) );

						wave = wave.add( waveOffsetVolume );

					}


					// store

					const waveStorageElementNode = waveArray.element( instanceIndex );

					waveStorageElementNode.assign( wave );

				} );


				// compute

				computeNode = computeShaderFn().compute( waveBuffer.length );

				// renderer

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 30 );


				// nodes

				analyserTexture = new THREE.DataTexture( analyserBuffer, analyserBuffer.length, 1, THREE.RedFormat );

				const spectrum = texture( analyserTexture, screenUV.x ).x.mul( screenUV.y );
				const backgroundNode = color( 0x0000FF ).mul( spectrum );


				// scene

				scene = new THREE.Scene();
				scene.backgroundNode = backgroundNode;

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				await renderer.init();

				window.addEventListener( 'resize', onWindowResize );
				document.addEventListener( 'click', playAudioBuffer );

				// gui

				const gui = renderer.inspector.createParameters( 'Audio' );

				gui.add( pitch, 'value', .5, 2, 0.01 ).name( 'pitch' );
				gui.add( delayVolume, 'value', 0, 1, .01 ).name( 'delayVolume' );
				gui.add( delayOffset, 'value', .1, 1, .01 ).name( 'delayOffset' );

				//

				playAudioBuffer();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				if ( currentAnalyser ) {

					currentAnalyser.getByteFrequencyData( analyserBuffer );

					analyserTexture.needsUpdate = true;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_birds.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute birds</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Compute Birds</span>
			</div>

			<small>
				Move mouse to disturb birds.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { uniform, varying, vec4, add, sub, max, dot, sin, mat3, uint, negate, instancedArray, cameraProjectionMatrix, cameraViewMatrix, positionLocal, modelWorldMatrix, sqrt, float, Fn, If, cos, Loop, Continue, normalize, instanceIndex, length, vertexIndex } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let container;
			let camera, scene, renderer;

			let last = performance.now();

			let pointer, raycaster;
			let computeVelocity, computePosition, effectController;

			const BIRDS = 16384;
			const SPEED_LIMIT = 9.0;
			const BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;

			// Custom Geometry - using 3 triangles each. No normals currently.
			class BirdGeometry extends THREE.BufferGeometry {

				constructor() {

					super();

					const points = 3 * 3;

					const vertices = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );

					this.setAttribute( 'position', vertices );

					let v = 0;

					function verts_push() {

						for ( let i = 0; i < arguments.length; i ++ ) {

							vertices.array[ v ++ ] = arguments[ i ];

						}

					}

					const wingsSpan = 20;

					// Body
					verts_push(
						0, 0, - 20,
						0, - 8, 10,
						0, 0, 30
					);

					// Left Wing
					verts_push(
						0, 0, - 15,
						- wingsSpan, 0, 5,
						0, 0, 15
					);

					// Right Wing
					verts_push(
						0, 0, 15,
						wingsSpan, 0, 5,
						0, 0, - 15
					);

					this.scale( 0.2, 0.2, 0.2 );

				}

			}

			// TODO: Fix example with WebGL backend

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xffffff, 700, 3000 );

				// Pointer

				pointer = new THREE.Vector2();
				raycaster = new THREE.Raycaster();

				// Sky

				const geometry = new THREE.IcosahedronGeometry( 1, 6 );
				const material = new THREE.MeshBasicNodeMaterial( {
					// Use vertex positions to create atmosphere colors
					colorNode: varying(
						vec4(
							sub( 0.25, positionLocal.y ),
							sub( - 0.25, positionLocal.y ),
							add( 1.5, positionLocal.y ),
							1.0
						)
					),
					side: THREE.BackSide
				} );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.rotation.z = 0.75;
				mesh.scale.setScalar( 1200 );
				scene.add( mesh );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera );
				controls.connect( renderer.domElement );

				// Initialize position, velocity, and phase values

				const positionArray = new Float32Array( BIRDS * 3 );
				const velocityArray = new Float32Array( BIRDS * 3 );
				const phaseArray = new Float32Array( BIRDS );

				for ( let i = 0; i < BIRDS; i ++ ) {

					const posX = Math.random() * BOUNDS - BOUNDS_HALF;
					const posY = Math.random() * BOUNDS - BOUNDS_HALF;
					const posZ = Math.random() * BOUNDS - BOUNDS_HALF;

					positionArray[ i * 3 + 0 ] = posX;
					positionArray[ i * 3 + 1 ] = posY;
					positionArray[ i * 3 + 2 ] = posZ;

					const velX = Math.random() - 0.5;
					const velY = Math.random() - 0.5;
					const velZ = Math.random() - 0.5;

					velocityArray[ i * 3 + 0 ] = velX * 10;
					velocityArray[ i * 3 + 1 ] = velY * 10;
					velocityArray[ i * 3 + 2 ] = velZ * 10;

					phaseArray[ i ] = 1;

				}

				// Labels applied to storage nodes and uniform nodes are reflected within the shader output,
				// and are useful for debugging purposes.

				const positionStorage = instancedArray( positionArray, 'vec3' ).setName( 'positionStorage' );
				const velocityStorage = instancedArray( velocityArray, 'vec3' ).setName( 'velocityStorage' );
				const phaseStorage = instancedArray( phaseArray, 'float' ).setName( 'phaseStorage' );

				// The Pixel Buffer Object (PBO) is required to get the GPU computed data in the WebGL2 fallback.

				positionStorage.setPBO( true );
				velocityStorage.setPBO( true );
				phaseStorage.setPBO( true );

				// Define Uniforms. Uniforms only need to be defined once rather than per shader.

				effectController = {
					separation: uniform( 15.0 ).setName( 'separation' ),
					alignment: uniform( 20.0 ).setName( 'alignment' ),
					cohesion: uniform( 20.0 ).setName( 'cohesion' ),
					freedom: uniform( 0.75 ).setName( 'freedom' ),
					now: uniform( 0.0 ),
					deltaTime: uniform( 0.0 ).setName( 'deltaTime' ),
					rayOrigin: uniform( new THREE.Vector3() ).setName( 'rayOrigin' ),
					rayDirection: uniform( new THREE.Vector3() ).setName( 'rayDirection' )
				};

				// Create geometry

				const birdGeometry = new BirdGeometry();
				const birdMaterial = new THREE.NodeMaterial();

				// Animate bird mesh within vertex shader, then apply position offset to vertices.

				const birdVertexTSL = Fn( () => {

					const position = positionLocal.toVar();
					const newPhase = phaseStorage.element( instanceIndex ).toVar();
					const newVelocity = normalize( velocityStorage.element( instanceIndex ) ).toVar();

					If( vertexIndex.equal( 4 ).or( vertexIndex.equal( 7 ) ), () => {

						// flap wings
						position.y = sin( newPhase ).mul( 5.0 );

					} );

					const newPosition = modelWorldMatrix.mul( position );

					newVelocity.z.mulAssign( - 1.0 );
					const xz = length( newVelocity.xz );
					const xyz = float( 1.0 );
					const x = sqrt( ( newVelocity.y.mul( newVelocity.y ) ).oneMinus() );

					const cosry = newVelocity.x.div( xz ).toVar();
					const sinry = newVelocity.z.div( xz ).toVar();

					const cosrz = x.div( xyz );
					const sinrz = newVelocity.y.div( xyz ).toVar();

					// Nodes must be negated with negate(). Using '-', their values will resolve to NaN.
					const maty = mat3(
						cosry, 0, negate( sinry ),
						0, 1, 0,
						sinry, 0, cosry
					);

					const matz = mat3(
						cosrz, sinrz, 0,
						negate( sinrz ), cosrz, 0,
						0, 0, 1
					);

					const finalVert = maty.mul( matz ).mul( newPosition );
					finalVert.addAssign( positionStorage.element( instanceIndex ) );

					return cameraProjectionMatrix.mul( cameraViewMatrix ).mul( finalVert );

				} );

				birdMaterial.vertexNode = birdVertexTSL();
				birdMaterial.side = THREE.DoubleSide;

				const birdMesh = new THREE.InstancedMesh( birdGeometry, birdMaterial, BIRDS );
				birdMesh.rotation.y = Math.PI / 2;
				birdMesh.matrixAutoUpdate = false;
				birdMesh.frustumCulled = false;
				birdMesh.updateMatrix();

				// Define GPU Compute shaders.
				// Shaders are computationally identical to their GLSL counterparts outside of texture destructuring.

				computeVelocity = Fn( () => {

					// Define consts
					const PI = float( 3.141592653589793 );
					const PI_2 = PI.mul( 2.0 );
					const limit = float( SPEED_LIMIT ).toVar( 'limit' );

					// Destructure uniforms
					const { alignment, separation, cohesion, deltaTime, rayOrigin, rayDirection } = effectController;

					const zoneRadius = separation.add( alignment ).add( cohesion ).toConst();
					const separationThresh = separation.div( zoneRadius ).toConst();
					const alignmentThresh = ( separation.add( alignment ) ).div( zoneRadius ).toConst();
					const zoneRadiusSq = zoneRadius.mul( zoneRadius ).toConst();

					// Cache current bird's position and velocity outside the loop
					const birdIndex = instanceIndex.toConst( 'birdIndex' );
					const position = positionStorage.element( birdIndex ).toVar();
					const velocity = velocityStorage.element( birdIndex ).toVar();

					// Add influence of pointer position to velocity using cached position
					const directionToRay = rayOrigin.sub( position ).toConst();
					const projectionLength = dot( directionToRay, rayDirection ).toConst();
					const closestPoint = rayOrigin.sub( rayDirection.mul( projectionLength ) ).toConst();
					const directionToClosestPoint = closestPoint.sub( position ).toConst();
					const distanceToClosestPoint = length( directionToClosestPoint ).toConst();
					const distanceToClosestPointSq = distanceToClosestPoint.mul( distanceToClosestPoint ).toConst();

					const rayRadius = float( 150.0 ).toConst();
					const rayRadiusSq = rayRadius.mul( rayRadius ).toConst();

					If( distanceToClosestPointSq.lessThan( rayRadiusSq ), () => {

						const velocityAdjust = ( distanceToClosestPointSq.div( rayRadiusSq ).sub( 1.0 ) ).mul( deltaTime ).mul( 100.0 );
						velocity.addAssign( normalize( directionToClosestPoint ).mul( velocityAdjust ) );
						limit.addAssign( 5.0 );

					} );

					// Attract flocks to center
					const dirToCenter = position.toVar();
					dirToCenter.y.mulAssign( 2.5 );
					velocity.subAssign( normalize( dirToCenter ).mul( deltaTime ).mul( 5.0 ) );

					Loop( { start: uint( 0 ), end: uint( BIRDS ), type: 'uint', condition: '<' }, ( { i } ) => {

						If( i.equal( birdIndex ), () => {

							Continue();

						} );

						// Cache bird's position and velocity

						const birdPosition = positionStorage.element( i );
						const dirToBird = birdPosition.sub( position );
						const distToBird = length( dirToBird );

						If( distToBird.lessThan( 0.0001 ), () => {

							Continue();

						} );

						const distToBirdSq = distToBird.mul( distToBird );

						// Don't apply any changes to velocity if changes if the bird is outsize the zone's radius.
						If( distToBirdSq.greaterThan( zoneRadiusSq ), () => {

							Continue();

						} );

						// Determine which threshold the bird is flying within and adjust its velocity accordingly

						const percent = distToBirdSq.div( zoneRadiusSq );

						If( percent.lessThan( separationThresh ), () => {

							// Separation - Move apart for comfort
							const velocityAdjust = ( separationThresh.div( percent ).sub( 1.0 ) ).mul( deltaTime );
							velocity.subAssign( normalize( dirToBird ).mul( velocityAdjust ) );

						} ).ElseIf( percent.lessThan( alignmentThresh ), () => {

							// Alignment - fly the same direction
							const threshDelta = alignmentThresh.sub( separationThresh );
							const adjustedPercent = ( percent.sub( separationThresh ) ).div( threshDelta );
							const birdVelocity = velocityStorage.element( i );

							const cosRange = cos( adjustedPercent.mul( PI_2 ) );
							const cosRangeAdjust = float( 0.5 ).sub( cosRange.mul( 0.5 ) ).add( 0.5 );
							const velocityAdjust = cosRangeAdjust.mul( deltaTime );
							velocity.addAssign( normalize( birdVelocity ).mul( velocityAdjust ) );

						} ).Else( () => {

							// Attraction / Cohesion - move closer
							const threshDelta = alignmentThresh.oneMinus();
							const adjustedPercent = threshDelta.equal( 0.0 ).select( 1.0, ( percent.sub( alignmentThresh ) ).div( threshDelta ) );

							const cosRange = cos( adjustedPercent.mul( PI_2 ) );
							const adj1 = cosRange.mul( - 0.5 );
							const adj2 = adj1.add( 0.5 );
							const adj3 = float( 0.5 ).sub( adj2 );

							const velocityAdjust = adj3.mul( deltaTime );
							velocity.addAssign( normalize( dirToBird ).mul( velocityAdjust ) );

						} );

					} );

					If( length( velocity ).greaterThan( limit ), () => {

						velocity.assign( normalize( velocity ).mul( limit ) );

					} );

					// Write back the final velocity to storage
					velocityStorage.element( birdIndex ).assign( velocity );

				} )().compute( BIRDS ).setName( 'Birds Velocity' );

				computePosition = Fn( () => {

					const { deltaTime } = effectController;
					positionStorage.element( instanceIndex ).addAssign( velocityStorage.element( instanceIndex ).mul( deltaTime ).mul( 15.0 ) );

					const velocity = velocityStorage.element( instanceIndex );
					const phase = phaseStorage.element( instanceIndex );

					const modValue = phase.add( deltaTime ).add( length( velocity.xz ).mul( deltaTime ).mul( 3.0 ) ).add( max( velocity.y, 0.0 ).mul( deltaTime ).mul( 6.0 ) );
					phaseStorage.element( instanceIndex ).assign( modValue.mod( 62.83 ) );

				} )().compute( BIRDS ).setName( 'Birds Position' );

				scene.add( birdMesh );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointermove', onPointerMove );

				window.addEventListener( 'resize', onWindowResize );

				const gui = renderer.inspector.createParameters( 'Birds settings' );
				gui.add( effectController.separation, 'value', 0.0, 100.0, 1.0 ).name( 'Separation' );
				gui.add( effectController.alignment, 'value', 0.0, 100, 0.001 ).name( 'Alignment ' );
				gui.add( effectController.cohesion, 'value', 0.0, 100, 0.025 ).name( 'Cohesion' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				pointer.x = ( event.clientX / window.innerWidth ) * 2.0 - 1.0;
				pointer.y = 1.0 - ( event.clientY / window.innerHeight ) * 2.0;

			}

			function render() {

				const now = performance.now();
				let deltaTime = ( now - last ) / 1000;

				if ( deltaTime > 1 ) deltaTime = 1; // safety cap on large deltas
				last = now;

				raycaster.setFromCamera( pointer, camera );

				effectController.now.value = now;
				effectController.deltaTime.value = deltaTime;
				effectController.rayOrigin.value.copy( raycaster.ray.origin );
				effectController.rayDirection.value.copy( raycaster.ray.direction );

				renderer.compute( computeVelocity );
				renderer.compute( computePosition );

				renderer.render( scene, camera );

				// Move pointer away so we only affect birds when moving the mouse
				pointer.y = 10;

			}

			init();

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_cloth.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute cloth</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Compute Cloth</span>
			</div>

			<small>Simple cloth simulation with a verlet system running in compute shaders.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Fn, If, Return, instancedArray, instanceIndex, uniform, select, attribute, uint, Loop, float, transformNormalToView, cross, triNoise3D, time } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let renderer, scene, camera, controls;

			const clothWidth = 1;
			const clothHeight = 1;
			const clothNumSegmentsX = 30;
			const clothNumSegmentsY = 30;
			const sphereRadius = 0.15;

			let vertexPositionBuffer, vertexForceBuffer, vertexParamsBuffer;
			let springVertexIdBuffer, springRestLengthBuffer, springForceBuffer;
			let springListBuffer;
			let computeSpringForces, computeVertexForces;
			let dampeningUniform, spherePositionUniform, stiffnessUniform, sphereUniform, windUniform;
			let vertexWireframeObject, springWireframeObject;
			let clothMesh, clothMaterial, sphere;
			let timeSinceLastStep = 0;
			let timestamp = 0;
			const verletVertices = [];
			const verletSprings = [];
			const verletVertexColumns = [];

			const clock = new THREE.Clock();

			const params = {
				wireframe: false,
				sphere: true,
				wind: 1.0,
			};

			const API = {
				color: 0x204080, // sRGB
				sheenColor: 0xffffff // sRGB
			};

			// TODO: Fix example with WebGL backend

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			init();

			async function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( - 1.6, - 0.1, - 1.6 );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 3;
				controls.target.set( 0, - 0.1, 0 );
				controls.update();

				const hdrLoader = new HDRLoader().setPath( 'textures/equirectangular/' );

				const hdrTexture = await hdrLoader.loadAsync( 'royal_esplanade_1k.hdr' );
				hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
				scene.background = hdrTexture;
				scene.backgroundBlurriness = 0.5;
				scene.environment = hdrTexture;

				setupCloth();

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( stiffnessUniform, 'value', 0.1, 0.5, 0.01 ).name( 'stiffness' );
				gui.add( params, 'wireframe' );
				gui.add( params, 'sphere' );
				gui.add( params, 'wind', 0, 5, 0.1 );

				const materialFolder = gui.addFolder( 'material' );
				materialFolder.addColor( API, 'color' ).onChange( function ( color ) {

					clothMaterial.color.setHex( color );

				} );
				materialFolder.add( clothMaterial, 'roughness', 0.0, 1, 0.01 );
				materialFolder.add( clothMaterial, 'sheen', 0.0, 1, 0.01 );
				materialFolder.add( clothMaterial, 'sheenRoughness', 0.0, 1, 0.01 );
				materialFolder.addColor( API, 'sheenColor' ).onChange( function ( color ) {

					clothMaterial.sheenColor.setHex( color );

				} );

				window.addEventListener( 'resize', onWindowResize );

				renderer.setAnimationLoop( render );

			}

			function setupVerletGeometry() {

				// this function sets up the geometry of the verlet system, a grid of vertices connected by springs

				const addVerletVertex = ( x, y, z, isFixed ) => {

					const id = verletVertices.length;
					const vertex = {
						id,
						position: new THREE.Vector3( x, y, z ),
						isFixed,
						springIds: [],
					};
					verletVertices.push( vertex );
					return vertex;

				};

				const addVerletSpring = ( vertex0, vertex1 ) => {

					const id = verletSprings.length;
					const spring = {
						id,
						vertex0,
						vertex1
					};
					vertex0.springIds.push( id );
					vertex1.springIds.push( id );
					verletSprings.push( spring );
					return spring;

				};

				// create the cloth's verlet vertices
				for ( let x = 0; x <= clothNumSegmentsX; x ++ ) {

					const column = [];
					for ( let y = 0; y <= clothNumSegmentsY; y ++ ) {

						const posX = x * ( clothWidth / clothNumSegmentsX ) - clothWidth * 0.5;
						const posZ = y * ( clothHeight / clothNumSegmentsY );
						const isFixed = ( y === 0 ) && ( ( x % 5 ) === 0 ); // make some of the top vertices' positions fixed
						const vertex = addVerletVertex( posX, clothHeight * 0.5, posZ, isFixed );
						column.push( vertex );

					}

					verletVertexColumns.push( column );

				}

				// create the cloth's verlet springs
				for ( let x = 0; x <= clothNumSegmentsX; x ++ ) {

					for ( let y = 0; y <= clothNumSegmentsY; y ++ ) {

						const vertex0 = verletVertexColumns[ x ][ y ];
						if ( x > 0 ) addVerletSpring( vertex0, verletVertexColumns[ x - 1 ][ y ] );
						if ( y > 0 ) addVerletSpring( vertex0, verletVertexColumns[ x ][ y - 1 ] );
						if ( x > 0 && y > 0 ) addVerletSpring( vertex0, verletVertexColumns[ x - 1 ][ y - 1 ] );
						if ( x > 0 && y < clothNumSegmentsY ) addVerletSpring( vertex0, verletVertexColumns[ x - 1 ][ y + 1 ] );

						// You can make the cloth more rigid by adding more springs between further apart vertices
						//if (x > 1) addVerletSpring(vertex0, verletVertexColumns[x - 2][y]);
						//if (y > 1) addVerletSpring(vertex0, verletVertexColumns[x][y - 2]);

					}

				}

			}

			function setupVerletVertexBuffers() {

				// setup the buffers holding the vertex data for the compute shaders

				const vertexCount = verletVertices.length;

				const springListArray = [];
				// this springListArray will hold a list of spring ids, ordered by the id of the vertex affected by that spring.
				// this is so the compute shader that accumulates the spring forces for each vertex can efficiently iterate over all springs affecting that vertex

				const vertexPositionArray = new Float32Array( vertexCount * 3 );
				const vertexParamsArray = new Uint32Array( vertexCount * 3 );
				// the params Array holds three values for each verlet vertex:
				// x: isFixed, y: springCount, z: springPointer
				// isFixed is 1 if the verlet is marked as immovable, 0 if not
				// springCount is the number of springs connected to that vertex
				// springPointer is the index of the first spring in the springListArray that is connected to that vertex

				for ( let i = 0; i < vertexCount; i ++ ) {

					const vertex = verletVertices[ i ];
					vertexPositionArray[ i * 3 ] = vertex.position.x;
					vertexPositionArray[ i * 3 + 1 ] = vertex.position.y;
					vertexPositionArray[ i * 3 + 2 ] = vertex.position.z;
					vertexParamsArray[ i * 3 ] = vertex.isFixed ? 1 : 0;
					if ( ! vertex.isFixed ) {

						vertexParamsArray[ i * 3 + 1 ] = vertex.springIds.length;
						vertexParamsArray[ i * 3 + 2 ] = springListArray.length;
						springListArray.push( ...vertex.springIds );

					}

				}

				vertexPositionBuffer = instancedArray( vertexPositionArray, 'vec3' ).setPBO( true ); // setPBO(true) is only important for the WebGL Fallback
				vertexForceBuffer = instancedArray( vertexCount, 'vec3' );
				vertexParamsBuffer = instancedArray( vertexParamsArray, 'uvec3' );

				springListBuffer = instancedArray( new Uint32Array( springListArray ), 'uint' ).setPBO( true );

			}

			function setupVerletSpringBuffers() {

				// setup the buffers holding the spring data for the compute shaders

				const springCount = verletSprings.length;

				const springVertexIdArray = new Uint32Array( springCount * 2 );
				const springRestLengthArray = new Float32Array( springCount );

				for ( let i = 0; i < springCount; i ++ ) {

					const spring = verletSprings[ i ];
					springVertexIdArray[ i * 2 ] = spring.vertex0.id;
					springVertexIdArray[ i * 2 + 1 ] = spring.vertex1.id;
					springRestLengthArray[ i ] = spring.vertex0.position.distanceTo( spring.vertex1.position );

				}

				springVertexIdBuffer = instancedArray( springVertexIdArray, 'uvec2' ).setPBO( true );
				springRestLengthBuffer = instancedArray( springRestLengthArray, 'float' );
				springForceBuffer = instancedArray( springCount * 3, 'vec3' ).setPBO( true );

			}

			function setupUniforms() {

				dampeningUniform = uniform( 0.99 );
				spherePositionUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );
				sphereUniform = uniform( 1.0 );
				windUniform = uniform( 1.0 );
				stiffnessUniform = uniform( 0.2 );

			}

			function setupComputeShaders() {

				// This function sets up the compute shaders for the verlet simulation
				// There are two shaders that are executed for each simulation step

				const vertexCount = verletVertices.length;
				const springCount = verletSprings.length;

				// 1. computeSpringForces:
				// This shader computes a force for each spring, depending on the distance between the two vertices connected by that spring and the targeted rest length
				computeSpringForces = Fn( () => {

					If( instanceIndex.greaterThanEqual( uint( springCount ) ), () => {

						// compute Shaders are executed in groups of 64, so instanceIndex might be bigger than the amount of springs.
						// in that case, return.
						Return();

					} );

					const vertexIds = springVertexIdBuffer.element( instanceIndex );
					const restLength = springRestLengthBuffer.element( instanceIndex );

					const vertex0Position = vertexPositionBuffer.element( vertexIds.x );
					const vertex1Position = vertexPositionBuffer.element( vertexIds.y );

					const delta = vertex1Position.sub( vertex0Position ).toVar();
					const dist = delta.length().max( 0.000001 ).toVar();
					const force = dist.sub( restLength ).mul( stiffnessUniform ).mul( delta ).mul( 0.5 ).div( dist );
					springForceBuffer.element( instanceIndex ).assign( force );

				} )().compute( springCount ).setName( 'Spring Forces' );

				// 2. computeVertexForces:
				// This shader accumulates the force for each vertex.
				// First it iterates over all springs connected to this vertex and accumulates their forces.
				// Then it adds a gravital force, wind force, and the collision with the sphere.
				// In the end it adds the force to the vertex' position.
				computeVertexForces = Fn( () => {

					If( instanceIndex.greaterThanEqual( uint( vertexCount ) ), () => {

						// compute Shaders are executed in groups of 64, so instanceIndex might be bigger than the amount of vertices.
						// in that case, return.
						Return();

					} );

					const params = vertexParamsBuffer.element( instanceIndex ).toVar();
					const isFixed = params.x;
					const springCount = params.y;
					const springPointer = params.z;

					If( isFixed, () => {

						// don't need to calculate vertex forces if the vertex is set as immovable
						Return();

					} );

					const position = vertexPositionBuffer.element( instanceIndex ).toVar( 'vertexPosition' );
					const force = vertexForceBuffer.element( instanceIndex ).toVar( 'vertexForce' );

					force.mulAssign( dampeningUniform );

					const ptrStart = springPointer.toVar( 'ptrStart' );
					const ptrEnd = ptrStart.add( springCount ).toVar( 'ptrEnd' );

					Loop( { start: ptrStart, end: ptrEnd, type: 'uint', condition: '<' }, ( { i } ) => {

						const springId = springListBuffer.element( i ).toVar( 'springId' );
						const springForce = springForceBuffer.element( springId );
						const springVertexIds = springVertexIdBuffer.element( springId );
						const factor = select( springVertexIds.x.equal( instanceIndex ), 1.0, - 1.0 );
						force.addAssign( springForce.mul( factor ) );

					} );

					// gravity
					force.y.subAssign( 0.00005 );

					// wind
					const noise = triNoise3D( position, 1, time ).sub( 0.2 ).mul( 0.0001 );
					const windForce = noise.mul( windUniform );
					force.z.subAssign( windForce );

					// collision with sphere
					const deltaSphere = position.add( force ).sub( spherePositionUniform );
					const dist = deltaSphere.length();
					const sphereForce = float( sphereRadius ).sub( dist ).max( 0 ).mul( deltaSphere ).div( dist ).mul( sphereUniform );
					force.addAssign( sphereForce );

					vertexForceBuffer.element( instanceIndex ).assign( force );
					vertexPositionBuffer.element( instanceIndex ).addAssign( force );

				} )().compute( vertexCount ).setName( 'Vertex Forces' );

			}

			function setupWireframe() {

				// adds helpers to visualize the verlet system

				// verlet vertex visualizer
				const vertexWireframeMaterial = new THREE.SpriteNodeMaterial();
				vertexWireframeMaterial.positionNode = vertexPositionBuffer.element( instanceIndex );
				vertexWireframeObject = new THREE.Mesh( new THREE.PlaneGeometry( 0.01, 0.01 ), vertexWireframeMaterial );
				vertexWireframeObject.frustumCulled = false;
				vertexWireframeObject.count = verletVertices.length;
				scene.add( vertexWireframeObject );


				// verlet spring visualizer
				const springWireframePositionBuffer = new THREE.BufferAttribute( new Float32Array( 6 ), 3, false );
				const springWireframeIndexBuffer = new THREE.BufferAttribute( new Uint32Array( [ 0, 1 ] ), 1, false );
				const springWireframeMaterial = new THREE.LineBasicNodeMaterial();
				springWireframeMaterial.positionNode = Fn( () => {

					const vertexIds = springVertexIdBuffer.element( instanceIndex );
					const vertexId = select( attribute( 'vertexIndex' ).equal( 0 ), vertexIds.x, vertexIds.y );
					return vertexPositionBuffer.element( vertexId );

				} )();

				const springWireframeGeometry = new THREE.InstancedBufferGeometry();
				springWireframeGeometry.setAttribute( 'position', springWireframePositionBuffer );
				springWireframeGeometry.setAttribute( 'vertexIndex', springWireframeIndexBuffer );
				springWireframeGeometry.instanceCount = verletSprings.length;

				springWireframeObject = new THREE.Line( springWireframeGeometry, springWireframeMaterial );
				springWireframeObject.frustumCulled = false;
				springWireframeObject.count = verletSprings.length;
				scene.add( springWireframeObject );

			}

			function setupSphere() {

				const geometry = new THREE.IcosahedronGeometry( sphereRadius * 0.95, 4 );
				const material = new THREE.MeshStandardNodeMaterial();
				sphere = new THREE.Mesh( geometry, material );
				scene.add( sphere );

			}

			function setupClothMesh() {

				// This function generates a three Geometry and Mesh to render the cloth based on the verlet systems position data.
				// Therefore it creates a plane mesh, in which each vertex will be centered in the center of 4 verlet vertices.

				const vertexCount = clothNumSegmentsX * clothNumSegmentsY;
				const geometry = new THREE.BufferGeometry();

				// verletVertexIdArray will hold the 4 verlet vertex ids that contribute to each geometry vertex's position
				const verletVertexIdArray = new Uint32Array( vertexCount * 4 );
				const indices = [];

				const getIndex = ( x, y ) => {

					return y * clothNumSegmentsX + x;

				};

				for ( let x = 0; x < clothNumSegmentsX; x ++ ) {

					for ( let y = 0; y < clothNumSegmentsX; y ++ ) {

						const index = getIndex( x, y );
						verletVertexIdArray[ index * 4 ] = verletVertexColumns[ x ][ y ].id;
						verletVertexIdArray[ index * 4 + 1 ] = verletVertexColumns[ x + 1 ][ y ].id;
						verletVertexIdArray[ index * 4 + 2 ] = verletVertexColumns[ x ][ y + 1 ].id;
						verletVertexIdArray[ index * 4 + 3 ] = verletVertexColumns[ x + 1 ][ y + 1 ].id;

						if ( x > 0 && y > 0 ) {

							indices.push( getIndex( x, y ), getIndex( x - 1, y ), getIndex( x - 1, y - 1 ) );
							indices.push( getIndex( x, y ), getIndex( x - 1, y - 1 ), getIndex( x, y - 1 ) );

						}

					}

				}

				const verletVertexIdBuffer = new THREE.BufferAttribute( verletVertexIdArray, 4, false );
				const positionBuffer = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3, false );
				geometry.setAttribute( 'position', positionBuffer );
				geometry.setAttribute( 'vertexIds', verletVertexIdBuffer );
				geometry.setIndex( indices );

				clothMaterial = new THREE.MeshPhysicalNodeMaterial( {
					color: new THREE.Color().setHex( API.color ),
					side: THREE.DoubleSide,
					transparent: true,
					opacity: 0.85,
					sheen: 1.0,
					sheenRoughness: 0.5,
					sheenColor: new THREE.Color().setHex( API.sheenColor ),
				} );

				clothMaterial.positionNode = Fn( ( { material } ) => {

					// gather the position of the 4 verlet vertices and calculate the center position and normal from that
					const vertexIds = attribute( 'vertexIds' );
					const v0 = vertexPositionBuffer.element( vertexIds.x ).toVar();
					const v1 = vertexPositionBuffer.element( vertexIds.y ).toVar();
					const v2 = vertexPositionBuffer.element( vertexIds.z ).toVar();
					const v3 = vertexPositionBuffer.element( vertexIds.w ).toVar();

					const top = v0.add( v1 );
					const right = v1.add( v3 );
					const bottom = v2.add( v3 );
					const left = v0.add( v2 );

					const tangent = right.sub( left ).normalize();
					const bitangent = bottom.sub( top ).normalize();

					const normal = cross( tangent, bitangent );

					// send the normalView from the vertex shader to the fragment shader
					material.normalNode = transformNormalToView( normal ).toVarying();

					return v0.add( v1 ).add( v2 ).add( v3 ).mul( 0.25 );

				} )();

				clothMesh = new THREE.Mesh( geometry, clothMaterial );
				clothMesh.frustumCulled = false;
				scene.add( clothMesh );

			}

			function setupCloth() {

				setupVerletGeometry();
				setupVerletVertexBuffers();
				setupVerletSpringBuffers();
				setupUniforms();
				setupComputeShaders();
				setupWireframe();
				setupSphere();
				setupClothMesh();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function updateSphere() {

				sphere.position.set( Math.sin( timestamp * 2.1 ) * 0.1, 0, Math.sin( timestamp * 0.8 ) );
				spherePositionUniform.value.copy( sphere.position );

			}

			async function render() {

				sphere.visible = params.sphere;
				sphereUniform.value = params.sphere ? 1 : 0;
				windUniform.value = params.wind;
				clothMesh.visible = ! params.wireframe;
				vertexWireframeObject.visible = params.wireframe;
				springWireframeObject.visible = params.wireframe;

				const deltaTime = Math.min( clock.getDelta(), 1 / 60 ); // don't advance the time too far, for example when the window is out of focus
				const stepsPerSecond = 360; // ensure the same amount of simulation steps per second on all systems, independent of refresh rate
				const timePerStep = 1 / stepsPerSecond;

				timeSinceLastStep += deltaTime;

				while ( timeSinceLastStep >= timePerStep ) {

					// run a verlet system simulation step
					timestamp += timePerStep;
					timeSinceLastStep -= timePerStep;
					updateSphere();
					renderer.compute( computeSpringForces );
					renderer.compute( computeVertexForces );

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>


================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_geometry.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute geometry</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Compute Geometry</span>
			</div>

			<small>Jelly deformation with compute shaders. Move pointer to interact.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { vec4, storage, Fn, If, uniform, instanceIndex, objectWorldMatrix, color, screenUV, attribute } from 'three/tsl';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let raycaster, pointer;

			let mesh;

			const pointerPosition = uniform( vec4( 0 ) );
			const elasticity = uniform( .4 ); // elasticity ( how "strong" the spring is )
			const damping = uniform( .94 ); // damping factor ( energy loss )
			const brushSize = uniform( .25 );
			const brushStrength = uniform( .22 );

			init();

			const jelly = Fn( ( { renderer, geometry, object } ) => {

				const count = geometry.attributes.position.count;

				// Create storage buffer attribute for modified position.

				const positionBaseAttribute = geometry.attributes.position;
				const positionStorageBufferAttribute = new THREE.StorageBufferAttribute( count, 3 );
				const speedBufferAttribute = new THREE.StorageBufferAttribute( count, 3 );

				geometry.setAttribute( 'storagePosition', positionStorageBufferAttribute );

				// Attributes

				const positionAttribute = storage( positionBaseAttribute, 'vec3', count );
				const positionStorageAttribute = storage( positionStorageBufferAttribute, 'vec3', count );

				const speedAttribute = storage( speedBufferAttribute, 'vec3', count );

				// Vectors

				// Base vec3 position of the mesh vertices.
				const basePosition = positionAttribute.element( instanceIndex );
				// Mesh vertices after compute modification.
				const currentPosition = positionStorageAttribute.element( instanceIndex );
				// Speed of each mesh vertex.
				const currentSpeed = speedAttribute.element( instanceIndex );

				//

				const computeInit = Fn( () => {

					// Modified storage position starts out the same as the base position.

					currentPosition.assign( basePosition );

				} )().compute( count );

				//

				const computeUpdate = Fn( () => {

					// pinch

					If( pointerPosition.w.equal( 1 ), () => {

						const worldPosition = objectWorldMatrix( object ).mul( currentPosition );

						const dist = worldPosition.distance( pointerPosition.xyz );
						const direction = pointerPosition.xyz.sub( worldPosition ).normalize();

						const power = brushSize.sub( dist ).max( 0 ).mul( brushStrength );

						currentPosition.addAssign( direction.mul( power ) );

					} );

					// compute ( jelly )

					const distance = basePosition.distance( currentPosition );
					const force = elasticity.mul( distance ).mul( basePosition.sub( currentPosition ) );

					currentSpeed.addAssign( force );
					currentSpeed.mulAssign( damping );

					currentPosition.addAssign( currentSpeed );

				} )().compute( count ).setName( 'Update Jelly' );

				// initialize the storage buffer with the base position

				computeUpdate.onInit( () => renderer.compute( computeInit ) );

				//

				return computeUpdate;

			} );

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.set( 0, 0, 1 );

				scene = new THREE.Scene();

				raycaster = new THREE.Raycaster();
				pointer = new THREE.Vector2();

				// background

				const bgColor = screenUV.y.mix( color( 0x9f87f7 ), color( 0xf2cdcd ) );
				const bgVignette = screenUV.distance( .5 ).remapClamp( 0.3, .8 ).oneMinus();
				const bgIntensity = 4;

				scene.backgroundNode = bgColor.mul( bgVignette.mul( color( 0xa78ff6 ).mul( bgIntensity ) ) );

				// model

				new GLTFLoader().load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {

					// create jelly effect material

					const material = new THREE.MeshNormalNodeMaterial();
					material.geometryNode = jelly();
					material.positionNode = attribute( 'storagePosition' );

					// apply the material to the mesh

					mesh = gltf.scene.children[ 0 ];
					mesh.scale.setScalar( .1 );
					mesh.material = material;
					scene.add( mesh );

				} );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = .7;
				controls.maxDistance = 2;

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( elasticity, 'value', 0, .5 ).name( 'elasticity' );
				gui.add( damping, 'value', .9, .98 ).name( 'damping' );
				gui.add( brushSize, 'value', .1, .5 ).name( 'brush size' );
				gui.add( brushStrength, 'value', .1, .3 ).name( 'brush strength' );

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'pointermove', onPointerMove );

			}

			function onPointerMove( event ) {

				pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObject( scene );

				if ( intersects.length > 0 ) {

					const intersect = intersects[ 0 ];

					pointerPosition.value.copy( intersect.point );
					pointerPosition.value.w = 1; // enable

				} else {

					pointerPosition.value.w = 0; // disable

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_particles.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - compute particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Compute Particles</span>
			</div>

			<small>500k Particles.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, If, uniform, float, uv, vec3, hash, shapeCircle,
				instancedArray, instanceIndex } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			const particleCount = 200000;

			const gravity = uniform( - .00098 );
			const bounce = uniform( .8 );
			const friction = uniform( .99 );
			const size = uniform( .12 );

			const clickPosition = uniform( new THREE.Vector3() );

			let camera, scene, renderer;
			let controls;
			let computeParticles;

			let isOrbitControlsActive;

			init();

			async function init() {

				const { innerWidth, innerHeight } = window;

				camera = new THREE.PerspectiveCamera( 50, innerWidth / innerHeight, .1, 1000 );
				camera.position.set( 0, 5, 20 );

				scene = new THREE.Scene();

				//

				const positions = instancedArray( particleCount, 'vec3' );
				const velocities = instancedArray( particleCount, 'vec3' );
				const colors = instancedArray( particleCount, 'vec3' );

				// compute

				const separation = 0.2;
				const amount = Math.sqrt( particleCount );
				const offset = float( amount / 2 );

				const computeInit = Fn( () => {

					const position = positions.element( instanceIndex );
					const color = colors.element( instanceIndex );

					const x = instanceIndex.mod( amount );
					const z = instanceIndex.div( amount );

					position.x = offset.sub( x ).mul( separation );
					position.z = offset.sub( z ).mul( separation );

					color.x = hash( instanceIndex );
					color.y = hash( instanceIndex.add( 2 ) );

				} )().compute( particleCount ).setName( 'Init Particles' );

				//

				const computeUpdate = Fn( () => {

					const position = positions.element( instanceIndex );
					const velocity = velocities.element( instanceIndex );

					velocity.addAssign( vec3( 0.00, gravity, 0.00 ) );
					position.addAssign( velocity );

					velocity.mulAssign( friction );

					// floor

					If( position.y.lessThan( 0 ), () => {

						position.y = 0;
						velocity.y = velocity.y.negate().mul( bounce );

						// floor friction

						velocity.x = velocity.x.mul( .9 );
						velocity.z = velocity.z.mul( .9 );

					} );

				} );

				computeParticles = computeUpdate().compute( particleCount ).setName( 'Update Particles' );

				// create particles

				const material = new THREE.SpriteNodeMaterial();
				material.colorNode = uv().mul( colors.element( instanceIndex ) );
				material.positionNode = positions.toAttribute();
				material.scaleNode = size;
				material.opacityNode = shapeCircle();
				material.alphaToCoverage = true;
				material.transparent = true;

				const particles = new THREE.Sprite( material );
				particles.count = particleCount;
				particles.frustumCulled = false;
				scene.add( particles );

				//

				const helper = new THREE.GridHelper( 90, 45, 0x303030, 0x303030 );
				scene.add( helper );

				const geometry = new THREE.PlaneGeometry( 200, 200 );
				geometry.rotateX( - Math.PI / 2 );

				const plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
				scene.add( plane );

				const raycaster = new THREE.Raycaster();
				const pointer = new THREE.Vector2();

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				//

				renderer.compute( computeInit );

				// Hit

				const computeHit = Fn( () => {

					const position = positions.element( instanceIndex );
					const velocity = velocities.element( instanceIndex );

					const dist = position.distance( clickPosition );
					const direction = position.sub( clickPosition ).normalize();
					const distArea = float( 3 ).sub( dist ).max( 0 );

					const power = distArea.mul( .01 );
					const relativePower = power.mul( hash( instanceIndex ).mul( 1.5 ).add( .5 ) );

					velocity.assign( velocity.add( direction.mul( relativePower ) ) );

				} )().compute( particleCount ).setName( 'Hit Particles' );

				//

				function onMove( event ) {

					if ( isOrbitControlsActive ) return;

					pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

					raycaster.setFromCamera( pointer, camera );

					const intersects = raycaster.intersectObject( plane, false );

					if ( intersects.length > 0 ) {

						const { point } = intersects[ 0 ];

						// move to uniform

						clickPosition.value.copy( point );
						clickPosition.value.y = - 1;

						// compute

						renderer.compute( computeHit );

					}

				}

				renderer.domElement.addEventListener( 'pointermove', onMove );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 5;
				controls.maxDistance = 200;
				controls.target.set( 0, - 8, 0 );
				controls.update();

				controls.addEventListener( 'start', () => {

					isOrbitControlsActive = true;

				} );
				controls.addEventListener( 'end', () => {

					isOrbitControlsActive = false;

				} );

				controls.touches = {
					ONE: null,
					TWO: THREE.TOUCH.DOLLY_PAN
				};

				//

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( gravity, 'value', - .0098, 0, 0.0001 ).name( 'gravity' );
				gui.add( bounce, 'value', .1, 1, 0.01 ).name( 'bounce' );
				gui.add( friction, 'value', .96, .99, 0.01 ).name( 'friction' );
				gui.add( size, 'value', .12, .5, 0.01 ).name( 'size' );

			}

			function onWindowResize() {

				const { innerWidth, innerHeight } = window;

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( innerWidth, innerHeight );

			}

			function animate() {

				controls.update();

				renderer.compute( computeParticles );
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_particles_fluid.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute fluid particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Fluid Particles</span>
			</div>

			<small>MLS-MPM particle simulation running in compute shaders.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Fn, If, Return, instancedArray, instanceIndex, uniform, attribute, uint, float, clamp, struct, atomicStore, int, ivec3, array, vec3, atomicAdd, Loop, atomicLoad, max, pow, mat3, vec4, cross, step } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
			import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let renderer, scene, camera, controls;

			const clock = new THREE.Clock();

			const maxParticles = 8192 * 16;
			const gridSize1d = 64;
			const gridSize = new THREE.Vector3( gridSize1d, gridSize1d, gridSize1d );
			const fixedPointMultiplier = 1e7;

			let particleCountUniform, stiffnessUniform, restDensityUniform, dynamicViscosityUniform, dtUniform, gravityUniform, gridSizeUniform;
			let particleBuffer, cellBuffer, cellBufferFloat;
			let clearGridKernel, p2g1Kernel, p2g2Kernel, updateGridKernel, g2pKernel;
			let particleMesh;
			const mouseCoord = new THREE.Vector3();
			const prevMouseCoord = new THREE.Vector3();
			let mouseRayOriginUniform, mouseRayDirectionUniform, mouseForceUniform;

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );
				throw new Error( 'No WebGPU support' );

			}

			const params = {
				particleCount: 8192 * 4,
			};

			init();

			async function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.35;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( - 1.3, 1.3, - 1.3 );

				controls = new OrbitControls( camera, renderer.domElement );

				controls.minDistance = 1;
				controls.maxDistance = 3;
				controls.maxPolarAngle = Math.PI * 0.35;
				controls.touches = { TWO: THREE.TOUCH.DOLLY_ROTATE };

				const hdrLoader = new HDRLoader().setPath( 'textures/equirectangular/' );

				const hdrTexture = await hdrLoader.loadAsync( 'royal_esplanade_1k.hdr' );
				hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
				scene.background = hdrTexture;
				scene.backgroundBlurriness = 0.5;
				scene.environment = hdrTexture;

				setupParticles();

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( params, 'particleCount', 4096, maxParticles, 4096 ).onChange( value => {

					p2g1Kernel.count = value;
					p2g2Kernel.count = value;
					g2pKernel.count = value;
					particleMesh.count = value;
					particleCountUniform.value = value;

				} );

				window.addEventListener( 'resize', onWindowResize );
				controls.update();
				renderer.setAnimationLoop( render );

			}

			function setupBuffers() {

				const particleStruct = struct( {
					position: { type: 'vec3' },
					velocity: { type: 'vec3' },
					C: { type: 'mat3' },
				} );
				const particleStructSize = 20; // each vec3 occupies 4 floats and mat3 occupies 12 floats in memory because of webgpu memory alignment
				const particleArray = new Float32Array( maxParticles * particleStructSize );

				for ( let i = 0; i < maxParticles; i ++ ) {

					particleArray[ i * particleStructSize ] = ( Math.random() * 0.8 + 0.1 );
					particleArray[ i * particleStructSize + 1 ] = ( Math.random() * 0.8 + 0.1 );
					particleArray[ i * particleStructSize + 2 ] = ( Math.random() * 0.8 + 0.1 );

				}

				particleBuffer = instancedArray( particleArray, particleStruct );

				const cellCount = gridSize.x * gridSize.y * gridSize.z;

				const cellStruct = struct( {
					x: { type: 'int', atomic: true },
					y: { type: 'int', atomic: true },
					z: { type: 'int', atomic: true },
					mass: { type: 'int', atomic: true },
				} );

				cellBuffer = instancedArray( cellCount, cellStruct );
				cellBufferFloat = instancedArray( cellCount, 'vec4' );

			}

			function setupUniforms() {

				gridSizeUniform = uniform( gridSize );
				particleCountUniform = uniform( params.particleCount, 'uint' );
				stiffnessUniform = uniform( 50 );
				restDensityUniform = uniform( 1.5 );
				dynamicViscosityUniform = uniform( 0.1 );
				dtUniform = uniform( 1 / 60 );
				gravityUniform = uniform( new THREE.Vector3( 0, - ( 9.81 * 9.81 ), 0 ) );
				mouseRayOriginUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );
				mouseRayDirectionUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );
				mouseForceUniform = uniform( new THREE.Vector3( 0, 0, 0 ) );

				// gui.add(restDensityUniform, "value", 1.0, 3, 0.1).name("restDensity");
				// it's interesting to adjust the restDensity but it might cause the simulation to become unstable

			}

			function setupComputeShaders() {

				// the MLS-MPM system uses five compute shaders:
				// 1. clearGridKernel: this clears the grid before each pass
				// 2. p2g1Kernel & 3. p2g2Kernel: These particle2grid kernels transfer the particles' energy to the grid
				// 4. updateGridKernel: updates the grid
				// 5. g2pKernel: grid2particle kernel, transfers the grid energy back to the particles
				// the implementation closely follows https://github.com/matsuoka-601/WebGPU-Ocean

				// because webgpu only supports int atomics, we use fixed point floats by multiplying/dividing the float values with a high integer constant
				const encodeFixedPoint = ( f32 ) => {

					return int( f32.mul( fixedPointMultiplier ) );
			
				};

				const decodeFixedPoint = ( i32 ) => {

					return float( i32 ).div( fixedPointMultiplier );
			
				};

				const cellCount = gridSize.x * gridSize.y * gridSize.z;
				clearGridKernel = Fn( () => {

					If( instanceIndex.greaterThanEqual( uint( cellCount ) ), () => {

						Return();
			
					} );

					atomicStore( cellBuffer.element( instanceIndex ).get( 'x' ), 0 );
					atomicStore( cellBuffer.element( instanceIndex ).get( 'y' ), 0 );
					atomicStore( cellBuffer.element( instanceIndex ).get( 'z' ), 0 );
					atomicStore( cellBuffer.element( instanceIndex ).get( 'mass' ), 0 );
			
				} )().compute( cellCount ).setName( 'clearGridKernel' );

				p2g1Kernel = Fn( () => {

					If( instanceIndex.greaterThanEqual( particleCountUniform ), () => {

						Return();
			
					} );
					const particlePosition = particleBuffer.element( instanceIndex ).get( 'position' ).toConst( 'particlePosition' );
					const particleVelocity = particleBuffer.element( instanceIndex ).get( 'velocity' ).toConst( 'particleVelocity' );
					const C = particleBuffer.element( instanceIndex ).get( 'C' ).toConst( 'C' );

					const gridPosition = particlePosition.mul( gridSizeUniform ).toVar();
					const cellIndex = ivec3( gridPosition ).sub( 1 ).toConst( 'cellIndex' );
					const cellDiff = gridPosition.fract().sub( 0.5 ).toConst( 'cellDiff' );
					const w0 = float( 0.5 ).mul( float( 0.5 ).sub( cellDiff ) ).mul( float( 0.5 ).sub( cellDiff ) );
					const w1 = float( 0.75 ).sub( cellDiff.mul( cellDiff ) );
					const w2 = float( 0.5 ).mul( float( 0.5 ).add( cellDiff ) ).mul( float( 0.5 ).add( cellDiff ) );
					const weights = array( [ w0, w1, w2 ] ).toConst( 'weights' );

					Loop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {

						Loop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {

							Loop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {

								const weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );
								const cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();
								const cellDist = vec3( cellX ).add( 0.5 ).sub( gridPosition ).toConst( 'cellDist' );
								const Q = C.mul( cellDist );

								const massContrib = weight; // assuming particle mass = 1.0
								const velContrib = massContrib.mul( particleVelocity.add( Q ) ).toConst( 'velContrib' );
								const cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();
								const cell = cellBuffer.element( cellPtr );

								atomicAdd( cell.get( 'x' ), encodeFixedPoint( velContrib.x ) );
								atomicAdd( cell.get( 'y' ), encodeFixedPoint( velContrib.y ) );
								atomicAdd( cell.get( 'z' ), encodeFixedPoint( velContrib.z ) );
								atomicAdd( cell.get( 'mass' ), encodeFixedPoint( massContrib ) );
			
							} );
			
						} );
			
					} );
			
				} )().compute( params.particleCount ).setName( 'p2g1Kernel' );

				p2g2Kernel = Fn( () => {

					If( instanceIndex.greaterThanEqual( particleCountUniform ), () => {

						Return();
			
					} );
					const particlePosition = particleBuffer.element( instanceIndex ).get( 'position' ).toConst( 'particlePosition' );
					const gridPosition = particlePosition.mul( gridSizeUniform ).toVar();

					const cellIndex = ivec3( gridPosition ).sub( 1 ).toConst( 'cellIndex' );
					const cellDiff = gridPosition.fract().sub( 0.5 ).toConst( 'cellDiff' );
					const w0 = float( 0.5 ).mul( float( 0.5 ).sub( cellDiff ) ).mul( float( 0.5 ).sub( cellDiff ) );
					const w1 = float( 0.75 ).sub( cellDiff.mul( cellDiff ) );
					const w2 = float( 0.5 ).mul( float( 0.5 ).add( cellDiff ) ).mul( float( 0.5 ).add( cellDiff ) );
					const weights = array( [ w0, w1, w2 ] ).toConst( 'weights' );

					const density = float( 0 ).toVar( 'density' );
					Loop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {

						Loop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {

							Loop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {

								const weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );
								const cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();
								const cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();
								const cell = cellBuffer.element( cellPtr );
								const mass = decodeFixedPoint( atomicLoad( cell.get( 'mass' ) ) );
								density.addAssign( mass.mul( weight ) );
			
							} );
			
						} );
			
					} );

					const volume = float( 1 ).div( density );
					const pressure = max( 0.0, pow( density.div( restDensityUniform ), 5.0 ).sub( 1 ).mul( stiffnessUniform ) ).toConst( 'pressure' );
					const stress = mat3( pressure.negate(), 0, 0, 0, pressure.negate(), 0, 0, 0, pressure.negate() ).toVar( 'stress' );
					const dudv = particleBuffer.element( instanceIndex ).get( 'C' ).toConst( 'C' );

					const strain = dudv.add( dudv.transpose() );
					stress.addAssign( strain.mul( dynamicViscosityUniform ) );
					const eq16Term0 = volume.mul( - 4 ).mul( stress ).mul( dtUniform );

					Loop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {

						Loop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {

							Loop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {

								const weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );
								const cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();
								const cellDist = vec3( cellX ).add( 0.5 ).sub( gridPosition ).toConst( 'cellDist' );
								const momentum = eq16Term0.mul( weight ).mul( cellDist ).toConst( 'momentum' );

								const cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();
								const cell = cellBuffer.element( cellPtr );
								atomicAdd( cell.get( 'x' ), encodeFixedPoint( momentum.x ) );
								atomicAdd( cell.get( 'y' ), encodeFixedPoint( momentum.y ) );
								atomicAdd( cell.get( 'z' ), encodeFixedPoint( momentum.z ) );
			
							} );
			
						} );
			
					} );
			
				} )().compute( params.particleCount ).setName( 'p2g2Kernel' );

				updateGridKernel = Fn( () => {

					If( instanceIndex.greaterThanEqual( uint( cellCount ) ), () => {

						Return();
			
					} );
					const cell = cellBuffer.element( instanceIndex );
					const mass = decodeFixedPoint( atomicLoad( cell.get( 'mass' ) ) ).toConst();
					If( mass.lessThanEqual( 0 ), () => {

						Return();

					} );

					const vx = decodeFixedPoint( atomicLoad( cell.get( 'x' ) ) ).div( mass ).toVar();
					const vy = decodeFixedPoint( atomicLoad( cell.get( 'y' ) ) ).div( mass ).toVar();
					const vz = decodeFixedPoint( atomicLoad( cell.get( 'z' ) ) ).div( mass ).toVar();

					const x = int( instanceIndex ).div( int( gridSize.z * gridSize.y ) );
					const y = int( instanceIndex ).div( int( gridSize.z ) ).mod( int( gridSize.y ) );
					const z = int( instanceIndex ).mod( int( gridSize.z ) );
					If( x.lessThan( int( 1 ) ).or( x.greaterThan( int( gridSize.x ).sub( int( 2 ) ) ) ), () => {

						vx.assign( 0 );

					} );
					If( y.lessThan( int( 1 ) ).or( y.greaterThan( int( gridSize.y ).sub( int( 2 ) ) ) ), () => {

						vy.assign( 0 );

					} );
					If( z.lessThan( int( 1 ) ).or( z.greaterThan( int( gridSize.z ).sub( int( 2 ) ) ) ), () => {

						vz.assign( 0 );

					} );

					cellBufferFloat.element( instanceIndex ).assign( vec4( vx, vy, vz, mass ) );
			
				} )().compute( cellCount ).setName( 'updateGridKernel' );


				const clampToRoundedBox = ( pos, box, radius ) => {

					const result = pos.sub( 0.5 ).toVar();
					const pp = step( box, result.abs() ).mul( result.add( box.negate().mul( result.sign() ) ) );
					const ppLen = pp.length().toVar();
					const dist = ppLen.sub( radius );
					If( dist.greaterThan( 0.0 ), () => {

						result.subAssign( pp.normalize().mul( dist ).mul( 1.3 ) );
			
					} );
					result.addAssign( 0.5 );
					return result;
			
				};

				g2pKernel = Fn( () => {

					If( instanceIndex.greaterThanEqual( particleCountUniform ), () => {

						Return();
			
					} );
					const particlePosition = particleBuffer.element( instanceIndex ).get( 'position' ).toVar( 'particlePosition' );
					const gridPosition = particlePosition.mul( gridSizeUniform ).toVar();
					const particleVelocity = vec3( 0 ).toVar();

					const cellIndex = ivec3( gridPosition ).sub( 1 ).toConst( 'cellIndex' );
					const cellDiff = gridPosition.fract().sub( 0.5 ).toConst( 'cellDiff' );

					const w0 = float( 0.5 ).mul( float( 0.5 ).sub( cellDiff ) ).mul( float( 0.5 ).sub( cellDiff ) );
					const w1 = float( 0.75 ).sub( cellDiff.mul( cellDiff ) );
					const w2 = float( 0.5 ).mul( float( 0.5 ).add( cellDiff ) ).mul( float( 0.5 ).add( cellDiff ) );
					const weights = array( [ w0, w1, w2 ] ).toConst( 'weights' );

					const B = mat3( 0 ).toVar( 'B' );
					Loop( { start: 0, end: 3, type: 'int', name: 'gx', condition: '<' }, ( { gx } ) => {

						Loop( { start: 0, end: 3, type: 'int', name: 'gy', condition: '<' }, ( { gy } ) => {

							Loop( { start: 0, end: 3, type: 'int', name: 'gz', condition: '<' }, ( { gz } ) => {

								const weight = weights.element( gx ).x.mul( weights.element( gy ).y ).mul( weights.element( gz ).z );
								const cellX = cellIndex.add( ivec3( gx, gy, gz ) ).toConst();
								const cellDist = vec3( cellX ).add( 0.5 ).sub( gridPosition ).toConst( 'cellDist' );
								const cellPtr = cellX.x.mul( int( gridSize.y * gridSize.z ) ).add( cellX.y.mul( int( gridSize.z ) ) ).add( cellX.z ).toConst();

								const weightedVelocity = cellBufferFloat.element( cellPtr ).xyz.mul( weight ).toConst( 'weightedVelocity' );
								const term = mat3(
									weightedVelocity.mul( cellDist.x ),
									weightedVelocity.mul( cellDist.y ),
									weightedVelocity.mul( cellDist.z )
								);
								B.addAssign( term );
								particleVelocity.addAssign( weightedVelocity );
			
							} );
			
						} );
			
					} );

					particleBuffer.element( instanceIndex ).get( 'C' ).assign( B.mul( 4 ) );

					// gravity
					particleVelocity.addAssign( gravityUniform.mul( dtUniform ) );

					// scale from (gridSize.x, gridSize.y, gridSize.z) to (1, 1, 1)
					particleVelocity.divAssign( gridSizeUniform );

					// mouseInteraction
					const dist = cross( mouseRayDirectionUniform, particlePosition.sub( mouseRayOriginUniform ) ).length();
					const force = dist.mul( 3.00 ).oneMinus().max( 0.0 ).pow( 2 );
					particleVelocity.addAssign( mouseForceUniform.mul( force ) );

					// add velocity to position
					particlePosition.addAssign( particleVelocity.mul( dtUniform ) );

					// clamp position so outermost gridCells are not reached
					particlePosition.assign( clamp( particlePosition, vec3( 1 ).div( gridSizeUniform ), vec3( gridSize ).sub( 1 ).div( gridSizeUniform ) ) );

					// add force for particles to stay within rounded box
					const innerBox = gridSizeUniform.mul( 0.5 ).sub( 9.0 ).div( gridSizeUniform ).toVar();
					const innerRadius = float( 6.0 ).div( gridSizeUniform.x );
					const posNext = particlePosition.add( particleVelocity.mul( dtUniform ).mul( 2.0 ) ).toConst( 'posNext' );
					const posNextClamped = clampToRoundedBox( posNext, innerBox, innerRadius );
					particleVelocity.addAssign( posNextClamped.sub( posNext ) );

					/*
					const wallStiffness = 1.0;
					const xN = particlePosition.add( particleVelocity.mul( dtUniform ).mul( 2.0 ) ).toConst( 'xN' );
					const wallMin = vec3( 3 ).div(gridSizeUniform).toConst( 'wallMin' );
					const wallMax = vec3( gridSize ).sub( 3 ).div(gridSizeUniform).toConst( 'wallMax' );
					particleVelocity.addAssign( wallMin.sub( xN ).max( 0.0 ).mul( wallStiffness ) );
					particleVelocity.addAssign( wallMax.sub( xN ).min( 0.0 ).mul( wallStiffness ) );
					*/

					// scale from (1, 1, 1) back to (gridSize.x, gridSize.y, gridSize.z) to
					particleVelocity.mulAssign( gridSizeUniform );

					particleBuffer.element( instanceIndex ).get( 'position' ).assign( particlePosition );
					particleBuffer.element( instanceIndex ).get( 'velocity' ).assign( particleVelocity );
			
				} )().compute( params.particleCount ).setName( 'g2pKernel' );

			}

			function setupMesh() {

				// mergeVertices to reduce the number of vertexShaderCalls
				const geometry = BufferGeometryUtils.mergeVertices( new THREE.IcosahedronGeometry( 0.008, 1 ).deleteAttribute( 'uv' ) );

				const material = new THREE.MeshStandardNodeMaterial( {
					color: '#0066FF'
				} );

				material.positionNode = Fn( () => {

					const particlePosition = particleBuffer.element( instanceIndex ).get( 'position' );
					return attribute( 'position' ).add( particlePosition );
			
				} )();
				particleMesh = new THREE.Mesh( geometry, material );
				particleMesh.count = params.particleCount;
				particleMesh.position.set( - 0.5, 0, - 0.5 );
				particleMesh.frustumCulled = false;
				scene.add( particleMesh );

			}

			function setupMouse() {

				const raycaster = new THREE.Raycaster();
				const raycastPlane = new THREE.Plane( new THREE.Vector3( 0, 1, 0 ) );

				const onMove = ( event ) => {

					const pointer = new THREE.Vector2( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
					raycaster.setFromCamera( pointer, camera );
					raycaster.ray.origin.x += 0.5;
					raycaster.ray.origin.z += 0.5;
					mouseRayOriginUniform.value.copy( raycaster.ray.origin );
					mouseRayDirectionUniform.value.copy( raycaster.ray.direction );

					raycaster.ray.intersectPlane( raycastPlane, mouseCoord );

				};

				renderer.domElement.addEventListener( 'pointermove', onMove );

			}

			function setupParticles() {

				setupBuffers();
				setupUniforms();
				setupComputeShaders();
				setupMesh();
				setupMouse();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function render() {

				const deltaTime = THREE.MathUtils.clamp( clock.getDelta(), 0.00001, 1 / 60 ); // don't advance the time too far, for example when the window is out of focus
				dtUniform.value = deltaTime;

				mouseForceUniform.value.copy( mouseCoord ).sub( prevMouseCoord ).multiplyScalar( 2 );
				const mouseForceLength = mouseForceUniform.value.length();
				if ( mouseForceLength > 0.3 ) {

					mouseForceUniform.value.multiplyScalar( 0.3 / mouseForceLength );
			
				}

				prevMouseCoord.copy( mouseCoord );

				//renderer.compute( [ clearGridKernel, p2g1Kernel, p2g2Kernel, updateGridKernel, g2pKernel ] );
				renderer.compute( clearGridKernel );
				renderer.compute( p2g1Kernel );
				renderer.compute( p2g2Kernel );
				renderer.compute( updateGridKernel );
				renderer.compute( g2pKernel );

				renderer.render( scene, camera );

			}


		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_particles_rain.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - compute particles rain</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Compute Rain</span>
			</div>

			<small>Compatible with native lights and shadows using post-processing pass.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, texture, uv, uint, instancedArray, positionWorld, billboarding, time, hash, deltaTime, vec2, instanceIndex, positionGeometry, If } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

			const maxParticleCount = 50000;
			const instanceCount = maxParticleCount / 2;

			let camera, scene, renderer;
			let controls;
			let computeParticles;
			let monkey;
			let clock;

			let collisionBox, collisionCamera, collisionPosRT, collisionPosMaterial;
			let collisionBoxPos, collisionBoxPosUI;

			init();

			async function init() {

				const { innerWidth, innerHeight } = window;

				camera = new THREE.PerspectiveCamera( 60, innerWidth / innerHeight, .1, 110 );
				camera.position.set( 40, 8, 0 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				const dirLight = new THREE.DirectionalLight( 0xffffff, .5 );
				dirLight.castShadow = true;
				dirLight.position.set( 3, 17, 17 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 50;
				dirLight.shadow.camera.right = 25;
				dirLight.shadow.camera.left = - 25;
				dirLight.shadow.camera.top = 25;
				dirLight.shadow.camera.bottom = - 25;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				dirLight.shadow.bias = - 0.01;

				scene.add( dirLight );
				scene.add( new THREE.AmbientLight( 0x111111 ) );

				//

				collisionCamera = new THREE.OrthographicCamera( - 50, 50, 50, - 50, .1, 50 );
				collisionCamera.position.y = 50;
				collisionCamera.lookAt( 0, 0, 0 );
				collisionCamera.layers.disableAll();
				collisionCamera.layers.enable( 1 );

				collisionPosRT = new THREE.RenderTarget( 1024, 1024 );
				collisionPosRT.texture.type = THREE.HalfFloatType;
				collisionPosRT.texture.magFilter = THREE.NearestFilter;
				collisionPosRT.texture.minFilter = THREE.NearestFilter;
				collisionPosRT.texture.generateMipmaps = false;

				collisionPosMaterial = new THREE.MeshBasicNodeMaterial();
				collisionPosMaterial.colorNode = positionWorld;

				//

				const positionBuffer = instancedArray( maxParticleCount, 'vec3' );
				const velocityBuffer = instancedArray( maxParticleCount, 'vec3' );
				const ripplePositionBuffer = instancedArray( maxParticleCount, 'vec3' );
				const rippleTimeBuffer = instancedArray( maxParticleCount, 'vec3' );

				// compute

				const randUint = () => uint( Math.random() * 0xFFFFFF );

				const computeInit = Fn( () => {

					const position = positionBuffer.element( instanceIndex );
					const velocity = velocityBuffer.element( instanceIndex );
					const rippleTime = rippleTimeBuffer.element( instanceIndex );

					const randX = hash( instanceIndex );
					const randY = hash( instanceIndex.add( randUint() ) );
					const randZ = hash( instanceIndex.add( randUint() ) );

					position.x = randX.mul( 100 ).add( - 50 );
					position.y = randY.mul( 25 );
					position.z = randZ.mul( 100 ).add( - 50 );

					velocity.y = randX.mul( - .04 ).add( - .2 );

					rippleTime.x = 1000;

				} )().compute( maxParticleCount );

				//

				const computeUpdate = Fn( () => {

					const getCoord = ( pos ) => pos.add( 50 ).div( 100 );

					const position = positionBuffer.element( instanceIndex );
					const velocity = velocityBuffer.element( instanceIndex );
					const ripplePosition = ripplePositionBuffer.element( instanceIndex );
					const rippleTime = rippleTimeBuffer.element( instanceIndex );

					position.addAssign( velocity );

					rippleTime.x = rippleTime.x.add( deltaTime.mul( 4 ) );

					//

					const collisionArea = texture( collisionPosRT.texture, getCoord( position.xz ) );

					const surfaceOffset = .05;

					const floorPosition = collisionArea.y.add( surfaceOffset );

					// floor

					const ripplePivotOffsetY = - .9;

					If( position.y.add( ripplePivotOffsetY ).lessThan( floorPosition ), () => {

						position.y = 25;

						ripplePosition.xz = position.xz;
						ripplePosition.y = floorPosition;

						// reset hit time: x = time

						rippleTime.x = 1;

						// next drops will not fall in the same place

						position.x = hash( instanceIndex.add( time ) ).mul( 100 ).add( - 50 );
						position.z = hash( instanceIndex.add( time.add( randUint() ) ) ).mul( 100 ).add( - 50 );

					} );

					const rippleOnSurface = texture( collisionPosRT.texture, getCoord( ripplePosition.xz ) );

					const rippleFloorArea = rippleOnSurface.y.add( surfaceOffset );

					If( ripplePosition.y.greaterThan( rippleFloorArea ), () => {

						rippleTime.x = 1000;

					} );

				} );

				computeParticles = computeUpdate().compute( maxParticleCount ).setName( 'Particles' );

				// rain

				const rainMaterial = new THREE.MeshBasicNodeMaterial();
				rainMaterial.colorNode = uv().distance( vec2( .5, 0 ) ).oneMinus().mul( 3 ).exp().mul( .1 );
				rainMaterial.vertexNode = billboarding( { position: positionBuffer.toAttribute() } );
				rainMaterial.opacity = .2;
				rainMaterial.side = THREE.DoubleSide;
				rainMaterial.forceSinglePass = true;
				rainMaterial.depthWrite = false;
				rainMaterial.depthTest = true;
				rainMaterial.transparent = true;

				const rainParticles = new THREE.Mesh( new THREE.PlaneGeometry( .1, 2 ), rainMaterial );
				rainParticles.count = instanceCount;
				scene.add( rainParticles );

				// ripple

				const rippleTime = rippleTimeBuffer.element( instanceIndex ).x;

				const rippleEffect = Fn( () => {

					const center = uv().add( vec2( - .5 ) ).length().mul( 7 );
					const distance = rippleTime.sub( center );

					return distance.min( 1 ).sub( distance.max( 1 ).sub( 1 ) );

				} );

				const rippleMaterial = new THREE.MeshBasicNodeMaterial();
				rippleMaterial.colorNode = rippleEffect();
				rippleMaterial.positionNode = positionGeometry.add( ripplePositionBuffer.toAttribute() );
				rippleMaterial.opacityNode = rippleTime.mul( .3 ).oneMinus().max( 0 ).mul( .5 );
				rippleMaterial.side = THREE.DoubleSide;
				rippleMaterial.forceSinglePass = true;
				rippleMaterial.depthWrite = false;
				rippleMaterial.depthTest = true;
				rippleMaterial.transparent = true;

				// ripple geometry

				const surfaceRippleGeometry = new THREE.PlaneGeometry( 2.5, 2.5 );
				surfaceRippleGeometry.rotateX( - Math.PI / 2 );

				const xRippleGeometry = new THREE.PlaneGeometry( 1, 2 );
				xRippleGeometry.rotateY( - Math.PI / 2 );

				const zRippleGeometry = new THREE.PlaneGeometry( 1, 2 );

				const rippleGeometry = BufferGeometryUtils.mergeGeometries( [ surfaceRippleGeometry, xRippleGeometry, zRippleGeometry ] );

				const rippleParticles = new THREE.Mesh( rippleGeometry, rippleMaterial );
				rippleParticles.count = instanceCount;
				scene.add( rippleParticles );

				// floor geometry

				const floorGeometry = new THREE.PlaneGeometry( 1000, 1000 );
				floorGeometry.rotateX( - Math.PI / 2 );

				const plane = new THREE.Mesh( floorGeometry, new THREE.MeshBasicMaterial( { color: 0x050505 } ) );
				scene.add( plane );

				//

				collisionBox = new THREE.Mesh( new THREE.BoxGeometry( 30, 1, 15 ), new THREE.MeshStandardMaterial() );
				collisionBox.material.color.set( 0x333333 );
				collisionBox.position.y = 12;
				collisionBox.scale.x = 3.5;
				collisionBox.layers.enable( 1 );
				collisionBox.castShadow = true;
				scene.add( collisionBox );

				//

				const loader = new THREE.BufferGeometryLoader();
				loader.load( 'models/json/suzanne_buffergeometry.json', function ( geometry ) {

					geometry.computeVertexNormals();

					monkey = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial( { roughness: 1, metalness: 0 } ) );
					monkey.receiveShadow = true;
					monkey.scale.setScalar( 5 );
					monkey.rotation.y = Math.PI / 2;
					monkey.position.y = 4.5;
					monkey.layers.enable( 1 ); // add to collision layer

					scene.add( monkey );

				} );

				//

				clock = new THREE.Clock();

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				//

				renderer.compute( computeInit );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 5;
				controls.maxDistance = 50;
				controls.update();

				//

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );

				// use lerp to smooth the movement
				collisionBoxPosUI = new THREE.Vector3().copy( collisionBox.position );
				collisionBoxPos = new THREE.Vector3();

				gui.add( collisionBoxPosUI, 'z', - 50, 50, .001 ).name( 'position' );
				gui.add( collisionBox.scale, 'x', .1, 3.5, 0.01 ).name( 'scale' );
				gui.add( rainParticles, 'count', 200, maxParticleCount, 1 ).name( 'drop count' ).onChange( ( v ) => rippleParticles.count = v );

			}

			function onWindowResize() {

				const { innerWidth, innerHeight } = window;

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( innerWidth, innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				if ( monkey ) {

					monkey.rotation.y += delta;

				}

				collisionBoxPos.set( collisionBoxPosUI.x, collisionBoxPosUI.y, - collisionBoxPosUI.z );

				collisionBox.position.lerp( collisionBoxPos, 10 * delta );

				// position

				scene.overrideMaterial = collisionPosMaterial;
				scene.name = 'Collision Scene';
				renderer.setRenderTarget( collisionPosRT );
				renderer.render( scene, collisionCamera );

				// compute

				renderer.compute( computeParticles );

				// result

				scene.overrideMaterial = null;
				scene.name = 'Scene';
				renderer.setRenderTarget( null );
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_particles_snow.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - compute snow</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Compute Snow</span>
			</div>

			<small>
				100k snow particles simulation.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, texture, vec3, pass, color, uint, screenUV, instancedArray, positionWorld, positionLocal, time, vec2, hash, instanceIndex, If } from 'three/tsl';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			const maxParticleCount = 100000;

			let camera, scene, renderer;
			let controls;
			let computeParticles;
			let postProcessing;

			let collisionCamera, collisionPosRT, collisionPosMaterial;

			init();

			async function init() {

				const { innerWidth, innerHeight } = window;

				camera = new THREE.PerspectiveCamera( 60, innerWidth / innerHeight, .1, 100 );
				camera.position.set( 20, 2, 20 );
				camera.layers.enable( 2 );
				camera.lookAt( 0, 40, 0 );

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x0f3c37, 5, 40 );

				const dirLight = new THREE.DirectionalLight( 0xf9ff9b, 9 );
				dirLight.castShadow = true;
				dirLight.position.set( 10, 10, 0 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 30;
				dirLight.shadow.camera.right = 30;
				dirLight.shadow.camera.left = - 30;
				dirLight.shadow.camera.top = 30;
				dirLight.shadow.camera.bottom = - 30;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				dirLight.shadow.bias = - 0.009;
				scene.add( dirLight );

				scene.add( new THREE.HemisphereLight( 0x0f3c37, 0x080d10, 100 ) );

				//

				collisionCamera = new THREE.OrthographicCamera( - 50, 50, 50, - 50, .1, 50 );
				collisionCamera.position.y = 50;
				collisionCamera.lookAt( 0, 0, 0 );
				collisionCamera.layers.enable( 1 );

				collisionPosRT = new THREE.RenderTarget( 1024, 1024 );
				collisionPosRT.texture.type = THREE.HalfFloatType;
				collisionPosRT.texture.magFilter = THREE.NearestFilter;
				collisionPosRT.texture.minFilter = THREE.NearestFilter;
				collisionPosRT.texture.generateMipmaps = false;

				collisionPosMaterial = new THREE.MeshBasicNodeMaterial();
				collisionPosMaterial.fog = false;
				collisionPosMaterial.toneMapped = false;
				collisionPosMaterial.colorNode = positionWorld.y;

				//

				const positionBuffer = instancedArray( maxParticleCount, 'vec3' );
				const scaleBuffer = instancedArray( maxParticleCount, 'vec3' );
				const staticPositionBuffer = instancedArray( maxParticleCount, 'vec3' );
				const dataBuffer = instancedArray( maxParticleCount, 'vec4' );

				// compute

				const randUint = () => uint( Math.random() * 0xFFFFFF );

				const computeInit = Fn( () => {

					const position = positionBuffer.element( instanceIndex );
					const scale = scaleBuffer.element( instanceIndex );
					const particleData = dataBuffer.element( instanceIndex );

					const randX = hash( instanceIndex );
					const randY = hash( instanceIndex.add( randUint() ) );
					const randZ = hash( instanceIndex.add( randUint() ) );

					position.x = randX.mul( 100 ).add( - 50 );
					position.y = randY.mul( 500 ).add( 3 );
					position.z = randZ.mul( 100 ).add( - 50 );

					scale.xyz = hash( instanceIndex.add( Math.random() ) ).mul( .8 ).add( .2 );

					staticPositionBuffer.element( instanceIndex ).assign( vec3( 1000, 10000, 1000 ) );

					particleData.y = randY.mul( - .1 ).add( - .02 );

					particleData.x = position.x;
					particleData.z = position.z;
					particleData.w = randX;

				} )().compute( maxParticleCount ).setName( 'Init Particles' );

				//

				const surfaceOffset = .2;
				const speed = .4;

				const computeUpdate = Fn( () => {

					const getCoord = ( pos ) => pos.add( 50 ).div( 100 );

					const position = positionBuffer.element( instanceIndex );
					const scale = scaleBuffer.element( instanceIndex );
					const particleData = dataBuffer.element( instanceIndex );

					const velocity = particleData.y;
					const random = particleData.w;

					const rippleOnSurface = texture( collisionPosRT.texture, getCoord( position.xz ) ).toInspector( 'Collision Test', () => {

						return texture( collisionPosRT.texture ).y; // .div( collisionCamera.position.y );

					} );

					const rippleFloorArea = rippleOnSurface.y.add( scale.x.mul( surfaceOffset ) );

					If( position.y.greaterThan( rippleFloorArea ), () => {

						position.x = particleData.x.add( time.mul( random.mul( random ) ).mul( speed ).sin().mul( 3 ) );
						position.z = particleData.z.add( time.mul( random ).mul( speed ).cos().mul( random.mul( 10 ) ) );

						position.y = position.y.add( velocity );

					} ).Else( () => {

						staticPositionBuffer.element( instanceIndex ).assign( position );

					} );

				} );

				computeParticles = computeUpdate().compute( maxParticleCount );
				computeParticles.name = 'Update Particles';

				// rain

				const geometry = new THREE.SphereGeometry( surfaceOffset, 5, 5 );

				function particle( staticParticles ) {

					const posBuffer = staticParticles ? staticPositionBuffer : positionBuffer;
					const layer = staticParticles ? 1 : 2;

					const staticMaterial = new THREE.MeshStandardNodeMaterial( {
						color: 0xeeeeee,
						roughness: .9,
						metalness: 0
					} );

					staticMaterial.positionNode = positionLocal.mul( scaleBuffer.toAttribute() ).add( posBuffer.toAttribute() );

					const rainParticles = new THREE.Mesh( geometry, staticMaterial );
					rainParticles.count = maxParticleCount;
					rainParticles.castShadow = true;
					rainParticles.layers.disableAll();
					rainParticles.layers.enable( layer );

					return rainParticles;

				}

				const dynamicParticles = particle();
				const staticParticles = particle( true );

				scene.add( dynamicParticles );
				scene.add( staticParticles );

				// floor geometry

				const floorGeometry = new THREE.PlaneGeometry( 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );

				const plane = new THREE.Mesh( floorGeometry, new THREE.MeshStandardMaterial( {
					color: 0x0c1e1e,
					roughness: .5,
					metalness: 0,
					transparent: true
				} ) );

				plane.material.opacityNode = positionLocal.xz.mul( .05 ).distance( 0 ).saturate().oneMinus();

				scene.add( plane );

				// tree

				function tree( count = 8 ) {

					const coneMaterial = new THREE.MeshStandardNodeMaterial( {
						color: 0x0d492c,
						roughness: .6,
						metalness: 0
					} );

					const object = new THREE.Group();

					for ( let i = 0; i < count; i ++ ) {

						const radius = 1 + i;

						const coneGeometry = new THREE.ConeGeometry( radius * 0.95, radius * 1.25, 32 );

						const cone = new THREE.Mesh( coneGeometry, coneMaterial );
						cone.castShadow = true;
						cone.position.y = ( ( count - i ) * 1.5 ) + ( count * .6 );
						object.add( cone );

					}

					const geometry = new THREE.CylinderGeometry( 1, 1, count, 32 );
					const cone = new THREE.Mesh( geometry, coneMaterial );
					cone.position.y = count / 2;
					object.add( cone );

					return object;

				}

				const teapotTree = new THREE.Mesh( new TeapotGeometry( .5, 18 ), new THREE.MeshBasicNodeMaterial( {
					color: 0xfcfb9e
				} ) );

				teapotTree.name = 'Teapot Pass';
				teapotTree.position.y = 18;

				scene.add( tree() );
				scene.add( teapotTree );

				//

				scene.backgroundNode = screenUV.distance( .5 ).mul( 2 ).mix( color( 0x0f4140 ), color( 0x060a0d ) );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 10, 0 );
				controls.minDistance = 25;
				controls.maxDistance = 35;
				controls.maxPolarAngle = Math.PI / 1.7;
				controls.autoRotate = true;
				controls.autoRotateSpeed = - 0.7;
				controls.update();

				// post processing

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode();
				const vignette = screenUV.distance( .5 ).mul( 1.35 ).clamp().oneMinus();

				const teapotTreePass = pass( teapotTree, camera ).getTextureNode();
				const teapotTreePassBlurred = gaussianBlur( teapotTreePass, vec2( 1 ), 6 );
				teapotTreePassBlurred.resolutionScale = 0.2;

				const scenePassColorBlurred = gaussianBlur( scenePassColor );
				scenePassColorBlurred.resolutionScale = 0.5;
				scenePassColorBlurred.directionNode = vec2( 1 );

				// compose

				let totalPass = scenePass.toInspector( 'Scene' );
				totalPass = totalPass.add( scenePassColorBlurred.mul( .1 ) );
				totalPass = totalPass.mul( vignette );
				totalPass = totalPass.add( teapotTreePass.mul( 10 ).add( teapotTreePassBlurred ).toInspector( 'Teapot Blur' ) );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = totalPass;

				//

				renderer.compute( computeInit );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const { innerWidth, innerHeight } = window;

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( innerWidth, innerHeight );

			}

			function animate() {

				controls.update();

				// position

				scene.name = 'Collider Position';
				scene.overrideMaterial = collisionPosMaterial;
				renderer.setRenderTarget( collisionPosRT );
				renderer.render( scene, collisionCamera );

				// compute

				renderer.compute( computeParticles );

				// result

				scene.name = 'Scene';
				scene.overrideMaterial = null;
				renderer.setRenderTarget( null );

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_points.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - compute</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Compute</span>
			</div>

			<small>
				300k points animated using GPU.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/",
					"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@3.6.0/dist/main.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { Fn, uniform, instancedArray, float, vec2, color, instanceIndex } from 'three/tsl';

			let camera, scene, renderer;
			let computeNode;

			const pointerVector = new THREE.Vector2( - 10.0, - 10.0 ); // Out of bounds first
			const scaleVector = new THREE.Vector2( 1, 1 );

			init();

			async function init() {

				camera = new THREE.OrthographicCamera( - 1.0, 1.0, 1.0, - 1.0, 0, 1 );
				camera.position.z = 1;

				scene = new THREE.Scene();

				// initialize particles

				const particlesCount = 300000;

				const particleArray = instancedArray( particlesCount, 'vec2' );
				const velocityArray = instancedArray( particlesCount, 'vec2' );

				// create function

				const computeShaderFn = Fn( () => {

					const particle = particleArray.element( instanceIndex );
					const velocity = velocityArray.element( instanceIndex );

					const pointer = uniform( pointerVector );
					const limit = uniform( scaleVector );

					const position = particle.add( velocity ).toVar();

					velocity.x = position.x.abs().greaterThanEqual( limit.x ).select( velocity.x.negate(), velocity.x );
					velocity.y = position.y.abs().greaterThanEqual( limit.y ).select( velocity.y.negate(), velocity.y );

					position.assign( position.min( limit ).max( limit.negate() ) );

					const pointerSize = 0.1;
					const distanceFromPointer = pointer.sub( position ).length();

					particle.assign( distanceFromPointer.lessThanEqual( pointerSize ).select( vec2(), position ) );

				} );

				// compute

				computeNode = computeShaderFn().compute( particlesCount ).setName( 'Update Particles' );
				computeNode.onInit( ( { renderer } ) => {

					const precomputeShaderNode = Fn( () => {

						const particleIndex = float( instanceIndex );

						const randomAngle = particleIndex.mul( .005 ).mul( Math.PI * 2 );
						const randomSpeed = particleIndex.mul( 0.00000001 ).add( 0.0000001 );

						const velX = randomAngle.sin().mul( randomSpeed );
						const velY = randomAngle.cos().mul( randomSpeed );

						const velocity = velocityArray.element( instanceIndex );

						velocity.xy = vec2( velX, velY );

					} );

					renderer.compute( precomputeShaderNode().compute( particlesCount ) );

				} );

				// use a compute shader to animate the point cloud's vertex data.

				const pointsGeometry = new THREE.BufferGeometry();
				pointsGeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 3 ), 3 ) ); // single vertex ( not triangle )
				pointsGeometry.drawRange.count = 1; // force render points as instances ( not triangle )

				const pointsMaterial = new THREE.PointsNodeMaterial();
				pointsMaterial.colorNode = particleArray.element( instanceIndex ).add( color( 0xFFFFFF ) );
				pointsMaterial.positionNode = particleArray.element( instanceIndex );

				const mesh = new THREE.Points( pointsGeometry, pointsMaterial );
				mesh.count = particlesCount;
				scene.add( mesh );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'mousemove', onMouseMove );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( scaleVector, 'x', 0, 1, 0.01 );
				gui.add( scaleVector, 'y', 0, 1, 0.01 );

			}

			function onWindowResize() {

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onMouseMove( event ) {

				const x = event.clientX;
				const y = event.clientY;

				const width = window.innerWidth;
				const height = window.innerHeight;

				pointerVector.set(
					( x / width - 0.5 ) * 2.0,
					( - y / height + 0.5 ) * 2.0
				);

			}

			function animate() {

				renderer.compute( computeNode );
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_reduce.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - compute reduction</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

	<style>

		#reduction-panel {
			background-color: #111;
			width: 100%;
			display: flex;
			position: fixed;
			height: auto;
			bottom: 0px;
			z-index: 99;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			border-left: 2px solid #222;
			text-align: center;
		}

		#panel-title {
			width: fit-content;
		}

		.thread-row {
			display: flex;
			flex-direction: row;
			align-items: center;
			margin: 4px 0;
			position: relative;
		}

		.thread {
			width: 16px;
			height: 16px;
			background-color: #444;
			margin-right: 2px;
			transition: background-color 0.5s, transform 0.5s;
		}

		.stage-display {
			display: flex;
			flex-direction: column;
			justify-content: center;
			margin-bottom: 5px;
		}

		.stage-label {
			font-size: 1.2em;
			color: #aaa;
			font-style: bold;
			margin-top: 6px;
			margin-bottom: 20px;
		}

		.thread {
			display: flex;
			justify-content: center;
			align-items: center;
			width: 40px;
			height: 40px;
			margin: 2px;
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 4px;
			background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0.2));
			box-shadow: inset 0 0 2px rgba(255,255,255,0.1);
			font-family: monospace;
			color: white;
		}

		.thread_data {
			display: block;
			max-width: 100%;
			padding: 0 2px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			font-size: clamp(8px, 2vw, 14px);
			text-align: center;
		}

		.subgroup {
			display: flex;
			position: relative;
			margin-left: 10px;
			margin-right: 10px;
		}

		.subgroup::before {
			/* label text for each subgroup label */
			content: "subgroupAdd()";
			position: absolute;
			top: -20px;
			/* Hide until animation is displayed */
			opacity: 0;
			z-index: 100;
			transition: opacity 0.5s ease;
			font-weight: bold;
			color: white;
			width: 100%;
		}

		.subgroup::after {
			content: attr(data-label);
			position: absolute;
			bottom: -20px;
			opacity: 1;
			z-index: 100;
			color: gray;
			width: 100%;
		}

		.reduction-stage {
			margin-bottom: 20px;
		}

		@keyframes labelAbsorb {
			0% {
				opacity: 0;
				transform: translateY(-50%);
			}
			40% {
				opacity: 1;
				transform: translateY(0%);
			}
			60% {
				opacity: 1;
				transform: translateY(0%);
			}
			80% {
				opacity: 1;
				transform: translate(0%, -20%);
			}
			100% {
				opacity: 0;
				transform: translate(0%, 100%);
			}
		}

		.subgroup.anim::before {
			opacity: 0;
			animation-name: labelAbsorb;
			animation-duration: 1.5s;
			transition:
			transform 0.6s ease-out,
			opacity 0.3s ease-in 0.3s;
		}

	</style>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br /> This example demonstrates the performance of various simple parallel reduction kernels.
			<br /> Reference implementations are translated from the CUDA/WGSL code present in the following books/repos:
			<br /> Impl. 0 - 2: <a href="https://www.cambridge.org/core/books/programming-in-parallel-with-cuda/C43652A69033C25AD6933368CDBE084C"><i>Programming in Parallel with CUDA</i></a> by <a href="https://people.bss.phy.cam.ac.uk/~rea1/">Richard Ansorge</a>
			<br /> Impl. 3: <a href="https://github.com/frost-beta/betann/blob/main/betann/wgsl/reduce_all.wgsl"><i>betann reduce_all kernel</i></a> by <a href="https://github.com/zcbenz">zcbenz</a>
			<br /> Impl. 4: <a href="https://github.com/b0nes164/GPUPrefixSums/blob/main/GPUPrefixSumsWebGPUapis/SharedShaders/rts.wgsl"><i>GPUPrefixSums reduction approach</i></a> by <a href="https://github.com/b0nes164">b0nes164</a>
			<div id="left_side_display" style="position: absolute;top: 150px;left: 0;padding: 10px;background: rgba( 0, 0, 0, 0.5 );color: #fff;font-family: monospace;font-size: 12px;line-height: 1.5;pointer-events: none;text-align: left;"></div>
			<div id="right_side_display" style="position: absolute;top: 150px;right: 0;padding: 10px;background: rgba( 0, 0, 0, 0.5 );color: #fff;font-family: monospace;font-size: 12px;line-height: 1.5;pointer-events: none;text-align: left;"></div>
		</div>

		<div id="reduction-panel">
			<h3 id="panel-title" style="flex: 0 0 auto;">Subgroup Reduction Explanation</h3>
			<div class="reduction-stage" id="subgroup-reduction-stage">
    		<div class="stage-label">Use subgroupAdd() to capture reduction of each workgroup's subgroups (Hover for animation)</div>
				<div class="stage-display">
					<div id="workgroup_threads" style="display: flex; justify-content: center; margin-bottom: 20px;"></div>
					<div id="subgroup_reduction" style="display: flex; justify-content: center; margin-bottom: 5px;"></div>
				</div>
			</div>
    </div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { instancedArray, Loop, If, vec3, dot, clamp, storage, uvec4, subgroupAdd, uniform, uv, uint, float, Fn, vec2, invocationLocalIndex, invocationSubgroupIndex, uvec2, floor, instanceIndex, workgroupId, workgroupBarrier, workgroupArray, subgroupSize, select, log2 } from 'three/tsl';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const timestamps = {
				left_side_display: document.getElementById( 'left_side_display' ),
				right_side_display: document.getElementById( 'right_side_display' )
			};

			const divRoundUp = ( size, part_size ) => {

				return Math.floor( ( size + part_size - 1 ) / part_size );

			};

			const cssSubgroupSize = 4;
			const cssWorkgroupSize = 16;

			const workgroupThreadsContainer = document.getElementById( 'workgroup_threads' );
			const subgroupReductionContainer = document.getElementById( 'subgroup_reduction' );

			document.getElementById( 'panel-title' ).textContent += ` (Subgroup Size: ${cssSubgroupSize}, Workgroup Size: ${cssWorkgroupSize})`;

			const createThreadWithData = ( data ) => {

				const threadEle = document.createElement( 'div' );
				threadEle.className = 'thread';
				const threadData = document.createElement( 'span' );
				threadData.textContent = data; // safer than innerHTML for just text
				threadData.className = 'thread_data';
				threadEle.append( threadData );

				return threadEle;

			};

			// Create thread elements
			const workgroupThreads = [];
			const initialSubgroups = [];
			const initialData = [];
			let currentSubgroupDiv = null;
			for ( let i = 0; i < cssWorkgroupSize; i ++ ) {

				if ( i % cssSubgroupSize === 0 ) {

					const currentSubgroupIndex = Math.floor( i / cssSubgroupSize );

					const subgroupReductionThread = createThreadWithData( 0 );
					subgroupReductionThread.id = `subgroup_reduction_element_${currentSubgroupIndex}`;
					subgroupReductionContainer.appendChild( subgroupReductionThread );

					currentSubgroupDiv = document.createElement( 'div' );
					currentSubgroupDiv.className = 'subgroup';
					currentSubgroupDiv.setAttribute( 'data-label', `Threads ${currentSubgroupIndex * cssSubgroupSize}-${( currentSubgroupIndex + 1 ) * cssSubgroupSize - 1}` );
					initialSubgroups.push( currentSubgroupDiv );
					workgroupThreadsContainer.appendChild( currentSubgroupDiv );

				}

				const data = Math.floor( Math.random() * 9 ) + 1;
				initialData.push( data );

				const thread = createThreadWithData( data );
				workgroupThreads.push( thread );
				currentSubgroupDiv.appendChild( thread );

			}

			const deactivateLabelAnimation = ( subgroupDiv, idx ) => {

				subgroupDiv.classList.remove( 'anim' );

				const subgroupReductionBufferElement = document.getElementById( `subgroup_reduction_element_${idx}` ).querySelector( '.thread_data' );

				subgroupReductionBufferElement.innerHTML = 0;

			};

			const activateLabelAnimation = ( subgroupDiv, idx ) => {

				const threads = Array.from( subgroupDiv.children );
				let total = 0;

				for ( let i = idx * cssSubgroupSize; i < idx * cssSubgroupSize + cssSubgroupSize; i ++ ) {

					total += initialData[ i ];

				}

				subgroupDiv.classList.add( 'anim' );

				setTimeout( () => {

					threads.forEach( t => {

						t.querySelector( '.thread_data' ).textContent = total;

					} );

					const subgroupReductionBufferElement = document.getElementById( `subgroup_reduction_element_${idx}` ).querySelector( '.thread_data' );

					subgroupReductionBufferElement.innerHTML = total;

				}, 1000 );

				// Remove the class after the animation ends so it can be triggered again
				setTimeout( () => {

					subgroupDiv.classList.remove( 'anim' );

				}, 1500 ); // matches animation duration in CSS

			};

			document.getElementById( 'subgroup-reduction-stage' ).addEventListener( 'mouseenter', () => {

				initialSubgroups.forEach( ( subgroupDiv, idx ) => {

					activateLabelAnimation( subgroupDiv, idx );

				} );

			} );

			document.getElementById( 'subgroup-reduction-stage' ).addEventListener( 'mouseleave', () => {

				initialSubgroups.forEach( ( subgroupDiv, idx ) => {

					deactivateLabelAnimation( subgroupDiv, idx );

				} );

				workgroupThreads.forEach( ( thread, idx ) => {

					thread.querySelector( '.thread_data' ).textContent = initialData[ idx ];

				} );

			} );


			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			// Total number of elements and the dimensions of the display grid.
			const size = 262144;
			const vecSize = divRoundUp( size, 4 );
			// Grid display is gridDim x gridDim
			const gridDim = Math.sqrt( size );
			let maxWorkgroupSize = 64;

			// Algorithm speed increase as you iterate through algorithms array
			const algorithms = [
				'Reduce 0 (N/2)',
				'Reduce 1 (Naive Accumulate)',
				'Reduce 2 (Workgroup Reduction)',
				'Reduce 3 (Subgroup Reduce)',
				'Reduce 4 (Subgroup Optimized)',
				'Incorrect Baseline',
			];

			// Input Grid: Displays input data in a grid format
			// Input Log2: Displays input grid data's logarithmic indices horizontally (1, 2, 4, 8, 16, ..., size)
			// Input Element 0: Displays clamped input[0]
			const displayModes = [ 'Input Grid', 'Input Log2', 'Input Element 0', 'Workgroup Sum Grid' ];

			// Holds uniforms for both displays as well as debug information
			const unifiedEffectController = {
				// Number of elements in the grid
				gridElementWidth: uniform( gridDim ),
				gridElementHeight: uniform( gridDim ),
				// Number of elements in the grid being displayed
				gridDisplayWidth: uniform( gridDim ),
				gridDisplayHeight: uniform( gridDim ),
				// How to display end result of reduction.
				// Ideally this is unique to the reduction method being deployed
				'Display Mode': 'Input Log2',
				loggedBuffer: 'Input Buffer',
				elementsReduced: size,
			};


			const leftEffectController = {
				// Current reduction algorithm being executed by this side
				algo: 'Reduce 0 (N/2)',
				// Flag indicating whether to highlight element in validation check
				highlight: uniform( 0 ),
				// Uniform that corresponds to the index of the current algorithm within the algorithms array
				currentAlgo: uniform( 0 ),
				// Current state of reduction (Running, validating, resetting)
				state: 'Run Algo',
				// Current display mode
				displayMode: 'Input Log2',
				// Reduce 0 specific uniform
				numThreadsDispatched: uniform( size / 2 ),
				// The subgroup size used by this side's device
			};

			const rightEffectController = {
				algo: 'Reduce 4 (Subgroup Optimized)',
				currentAlgo: uniform( 3 ),
				highlight: uniform( 0 ),
				displayMode: 'Input Element 0',
				state: 'Run Algo',
				numThreadsDispatched: uniform( size / 2 )
			};

			const leftMaterial = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );
			const rightMaterial = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );
			const leftDisplayColorNodes = {};
			const rightDisplayColorNodes = {};

			const gui = new GUI();

			gui.add( leftEffectController, 'algo', algorithms ).onChange( () => {

				leftEffectController.currentAlgo.value = algorithms.findIndex( val => val === leftEffectController.algo );

			} );

			gui.add( rightEffectController, 'algo', algorithms ).onChange( () => {

				rightEffectController.currentAlgo.value = algorithms.findIndex( val => val === rightEffectController.algo );

			} );

			gui.add( leftEffectController, 'displayMode', displayModes ).name( 'Left Display Mode' ).onChange( () => {

				leftMaterial.colorNode = leftDisplayColorNodes[ leftEffectController.displayMode ];
				leftMaterial.needsUpdate = true;

			} );
			gui.add( rightEffectController, 'displayMode', displayModes ).name( 'Right Display Mode' ).onChange( () => {

				rightMaterial.colorNode = rightDisplayColorNodes[ rightEffectController.displayMode ];
				rightMaterial.needsUpdate = true;

			} );

			const debugFolder = gui.addFolder( 'Debug' );
			const elementsReducedController = debugFolder.add( unifiedEffectController, 'elementsReduced' ).name( 'Elements Reduced' );
			elementsReducedController.disable();
			const stateLeftController = debugFolder.add( leftEffectController, 'state' ).name( 'Left Display State' );
			const stateRightController = debugFolder.add( rightEffectController, 'state' ).name( 'Right Display State' );
			stateLeftController.disable();
			stateRightController.disable();
			debugFolder.add( unifiedEffectController, 'loggedBuffer', [ 'Input Buffer', 'Input Vectorized Buffer', 'Workgroup Sums Buffer', 'Debug Buffer' ] ).name( 'Buffer to Log' );
			debugFolder.close();

			// HELPER FUNCTIONS
			const pow2Ceil = Fn( ( [ x ] ) => {

				If( x.equal( uint( 0 ) ), () => {

					return uint( 1 );

				} );

				const val = x.sub( 1 ).toVar( 'val' );
				val.assign( val.bitOr( val.shiftRight( 1 ) ) );
				val.assign( val.bitOr( val.shiftRight( 2 ) ) );
				val.assign( val.bitOr( val.shiftRight( 4 ) ) );
				val.assign( val.bitOr( val.shiftRight( 8 ) ) );
				val.assign( val.bitOr( val.shiftRight( 16 ) ) );
				return val.add( 1 );

			} ).setLayout( {
				name: 'pow2Ceil',
				type: 'uint',
				inputs: [
					{ name: 'x', type: 'uint' }
				]
			} );

			// ALGORITHM CONSTRUCTORS

			// REDUCE 1

			// Thanks to Sam0oneau of Graphics Programming Discord for the explanation.
			// (Graphics Programming Discord Message Link): https://discord.com/channels/318590007881236480/374061825454768129/1391248956171882597

			/* Reduce 1 Example (Assume Workgroup Size 256, numElements: 262144) -> Initial currentBuffer State: | 1, 1, 1, 1, ... |
				 *
				 * KERNEL 1:
				 * Executes 256 threads by 256 workgroups. Each thread loops 4 times and accesses elements
				 * at the indices below.
				 *          Thread 1                        Thread 2                         Thread 3
				 * | 0, 65536, ..., n * 65536 | 1, 65537, .... (n * 65536) + 1 | 1, 65538, .... (n * 65536) + 2 | etc
				 * Buffer Values: | 4, 4, 4, 4, ...|
				 *
				 * KERNEL 2:
				 * Executes 256 threads by one workgroup. Each thread loops 1024 times
				 *          Thread 1                     Thread 2                     Thread 3
				 * | 0, 256, ...., n * 256    | 1, 257, ... (n * 256) + 1 | 2, 258, ... (n * 256) + 3 | etc
				 * Buffer Values: | 1024, 1024, 1024, 1024, ... |
				 *
				 * KERNEL 3:
				 * Executes 1 thread by one workgroup. Single thread loops 256 times
				 *          Thread 1
				 * | 0, 1, 2, 3, 4, 5, 6 ... etc|
				 * Buffer Values: [262144, 1024, 1024]
				 */


			const createReduce1Fn = ( createReduce1FnProps ) => {

				const { dispatchSize, numElements, inputBuffer, workgroupSize } = createReduce1FnProps;

				const fnDef = Fn( () => {

					const dispatch = uint( dispatchSize ).toVar( 'dispatchSize' );
					const tSum = uint( 0 ).toVar();
					const k = instanceIndex.toVar( 'k' );

					Loop( k.lessThan( uint( numElements ) ), ( ) => {

						tSum.addAssign( inputBuffer.element( k ) );
						k.addAssign( uint( dispatch ) );

					} );

					inputBuffer.element( instanceIndex ).assign( tSum );


				} )().compute( dispatchSize, [ workgroupSize ] );

				return fnDef;

			};

			// REDUCE 2

			// For non power of 2 # of workgroups
			const createReduce2Fn = ( createReduce2FnProps ) => {

				const { workgroupSize, dispatchSize, numElements, inputBuffer } = createReduce2FnProps;

				const fnDef = Fn( () => {

					const tSum = workgroupArray( 'uint', workgroupSize );

					const k = instanceIndex.toVar( 'k' );
					tSum.element( invocationLocalIndex ).assign( uint( 0 ) );

					Loop( k.lessThan( uint( numElements ) ), () => {

						tSum.element( invocationLocalIndex ).addAssign( inputBuffer.element( k ) );

						k.addAssign( uint( dispatchSize ) );

					} );

					workgroupBarrier();

					// Reset the loop condition (account for numWorkgroups % 2 != 0)
					k.assign( pow2Ceil( uint( workgroupSize ) ).div( 2 ) );

					Loop( k.greaterThan( 0 ), () => {

						If( invocationLocalIndex.lessThan( k ).and( invocationLocalIndex.add( k ).lessThan( workgroupSize ) ), () => {

							tSum.element( invocationLocalIndex ).addAssign( tSum.element( invocationLocalIndex.add( k ) ) );

						} );
						workgroupBarrier();
						k.divAssign( 2 );

					} );

					If( invocationLocalIndex.equal( uint( 0 ) ), () => {

						inputBuffer.element( workgroupId.x ).assign( tSum.element( uint( 0 ) ) );

					} );

				} )().compute( dispatchSize, [ workgroupSize ] );

				return fnDef;

			};

			// REDUCE 3

			/* Create array with enough indices for worst-case subgroup size */
			const createSubgroupArray = ( type, workgroupSize, minSubgroupSize = 4 ) => {

				return workgroupArray( 'uint', workgroupSize / minSubgroupSize );

			};

			// zcbenz implementation
			// https://github.com/frost-beta/betann/blob/8aa2701caf63fb29bd4cd2454e656973342c1588/betann/wgsl/reduce_ops.wgsl#L71
			const RowReduce = ( rowReduceProps ) => {

				const { workgroupSize, inputBuffer, total, rowOffset, currentRowSize, workPerThread, vectorized } = rowReduceProps;

				// Number of unvectorized elements each workgroup can ingest
				// At workgroupSize of 256, blockSize will be 1024
				const blockSize = uint( workgroupSize ).mul( workPerThread );
				const block = uint( 0 ).toVar( 'block' );

				// At rowSize of 2048, there will be two blocks
				const blockLimiter = currentRowSize.div( blockSize ).toVar( 'blockLimiter' );
				Loop( block.lessThan( blockLimiter ), () => {

					const blockOffset = block.mul( blockSize );
					const startThread = blockOffset.add( invocationLocalIndex.mul( workPerThread ) );
					const localThreadOffset = uint( 0 ).toVar( 'localThreadOffset' );
					Loop( localThreadOffset.lessThan( workPerThread ), () => {

						const inputElement = inputBuffer.element( rowOffset.add( startThread ).addLocal );

						if ( vectorized ) {

							const value = dot( inputElement, uvec4( 1 ) );
							total.addAssign( value );

						} else {

							const inputElement = inputBuffer.element( rowOffset.add( startThread ).add( localThreadOffset ) );
							total.addAssign( inputElement );

						}

						// Increment up a thread
						localThreadOffset.addAssign( 1 );

					} );

					// Increment up a block
					block.addAssign( 1 );

				} );

				// Ignoring left over check for this example, since we know ahead of time the value of leftover (2048 % 1024 === 0)

			};

			const WorkgroupReduce = ( workgroupReduceProps ) => {

				const { total, workgroupSize } = workgroupReduceProps;

				const subgroupSums = createSubgroupArray( 'uint', workgroupSize );

				// Assign sum of all values in subgroup to total
				total.assign( subgroupAdd( total ) );

				const delta = uint( workgroupSize ).div( subgroupSize ).toVar( 'delta' );

				const subgroupMetaRank = invocationLocalIndex.div( subgroupSize );

				Loop( float( delta ).greaterThan( 1.0 ), () => {

					If( invocationSubgroupIndex.equal( 0 ), () => {

						// Each subgroup will populate the subgroupSums array
						subgroupSums.element( subgroupMetaRank ).assign( total );

					} );

					// Ensure that all subgroups in the workgroup have populated the workgroup memory array
					workgroupBarrier();

					// Thread 0 - subgroupsInWorkgroup will assign a value to total
					total.assign( select( invocationLocalIndex.lessThan( delta ), subgroupSums.element( invocationLocalIndex ), 0 ).uniformFlow() );
					// # of subgroups in workgroup is invariably less than # of threads in subgroup, so subgroupAdd will still sync here
					total.assign( subgroupAdd( total ) );

					delta.divAssign( subgroupSize );

				} );

			};

			const createReduce3Fn = ( createReduce3FnProps ) => {

				const { workgroupSize, workPerThread, inputBuffer, intermediateBuffer, rowSize } = createReduce3FnProps;

				const fnDef = Fn( () => {

					const inputSize = uint( inputBuffer.bufferCount.length );
					const rowOffset = workgroupId.x.mul( rowSize );

					// If the current rows elements exceed the bounds of the input
					// Select either 0 or number of elements left,
					// otherwise, select existing ROW_SIZE
					const currentRowSize = select(
						( rowOffset.add( rowSize ) ).greaterThan( inputSize ),
						select( inputSize.greaterThan( rowOffset ), inputSize.sub( rowOffset ), 0 ).uniformFlow(),
						rowSize,
					).uniformFlow();

					const total = uint( 0 ).toVar( 'total' );

					RowReduce( {
						inputBuffer: inputBuffer,
						total: total,
						rowOffset: rowOffset,
						currentRowSize: currentRowSize,
						workPerThread: workPerThread,
						workgroupSize: workgroupSize,
					} );

					WorkgroupReduce( {
						total: total,
						workgroupSize: workgroupSize,
					} );

					// Populate each workgroup with its reduction
					If( invocationLocalIndex.equal( 0 ), () => {

						intermediateBuffer.element( workgroupId.x ).assign( total );

					} );

				} )();

				return fnDef;

			};

			// REDUCE 4

			// b0nes164 inspired implementation with vec4
			const createReduce4Fn = ( props ) => {

				// Can't pass in subgroup size since we can't always be certain what size is at runtime
				const { size, workPerThread, workgroupSize, inputBuffer, intermediateBuffer } = props;

				const ELEMENTS_PER_VEC4 = 4;
				// The number of individual elements a single workgroup will access
				const partitionSize = workgroupSize * workPerThread * ELEMENTS_PER_VEC4;
				const vecSize = divRoundUp( size, ELEMENTS_PER_VEC4 );
				// Can also be calculated using divRoundUp( vecSize, workgroupSize * workPerThread );
				const numWorkgroups = divRoundUp( size, partitionSize );
				// Currently no way to specify dispatch size in increments of workgroups, so we convert to numInvocations
				const numInvocations = numWorkgroups * workgroupSize;

				const fnDef = Fn( () => {

					const perSubgroupReductionArray = createSubgroupArray( 'uint', workgroupSize );

					// Get the index of the subgroup within the workgroup
					const subgroupMetaRank = invocationLocalIndex.div( subgroupSize );

					// Each subgroup block scans across 4 subgroups. So when we move into a new subgroup,
					// align that subgroups' accesses to the next 4 subgroups
					const subgroupOffset = subgroupMetaRank.mul( subgroupSize ).mul( workPerThread );
					subgroupOffset.addAssign( invocationSubgroupIndex );

					// Per workgroup, offset by number of vectorized elements scanned per workgroup
					const workgroupOffset = workgroupId.x.mul( uint( maxWorkgroupSize ).mul( workPerThread ) );

					const startThread = subgroupOffset.add( workgroupOffset );

					const subgroupReduction = uint( 0 );

					// Each thread will accumulate values from across 'workPerThread' subgroups
					If( workgroupId.x.lessThan( uint( numWorkgroups ).sub( 1 ) ), () => {

						Loop( {
							start: uint( 0 ),
							end: workPerThread,
							type: 'uint',
							condition: '<',
							name: 'currentSubgroupInBlock'
						}, () => {

							// Get vectorized element from input array
							const val = inputBuffer.element( startThread );

							// Sum values within vec4 together by using result of dot product
							subgroupReduction.addAssign( dot( uvec4( 1 ), val ) );

							// Increment so thread will scan value in next subgroup
							startThread.addAssign( subgroupSize );

						} );

					} );

					// Ensure that the last workgroup does not access out of bounds indices
					If( workgroupId.x.equal( uint( numWorkgroups ).sub( 1 ) ), () => {

						Loop( {
							start: uint( 0 ),
							end: workPerThread,
							type: 'uint',
							condition: '<',
							name: 'currentSubgroupInBlock'
						}, () => {

							// Ensure index is less than number of available vectors in inputBuffer
							const val = select( startThread.lessThan( uint( vecSize ) ), inputBuffer.element( startThread ), uvec4( 0 ) ).uniformFlow();

							subgroupReduction.addAssign( dot( val, uvec4( 1 ) ) );
							startThread.addAssign( subgroupSize );

						} );

					} );

					subgroupReduction.assign( subgroupAdd( subgroupReduction ) );

					// Assuming that each element in the input buffer is 1, we generally expect each invocation's subgroupReduction
					// value to be ELEMENTS_PER_VEC4 * workPerThread * subgroupSize

					// Delegate one thread per subgroup to assign each subgroup's reduction to the workgroup array
					If( invocationSubgroupIndex.equal( uint( 0 ) ), () => {

						perSubgroupReductionArray.element( subgroupMetaRank ).assign( subgroupReduction );

					} );

					// Ensure that each workgroup has populated the perSubgroupReductionArray with data
					// from each of it's subgroups
					workgroupBarrier();

					if ( props.debugBuffer ) {

						If( invocationLocalIndex.equal( uint( 0 ) ), () => {

							props.debugBuffer.element( workgroupId.x ).assign( subgroupReduction );

						} );

						workgroupBarrier();

					}

					// WORKGROUP LEVEL REDUCE

					// Multiple approaches here
					// log2(subgroupSize) -> TSL log2 function
					// countTrailingZeros/findLSB(subgroupSize) -> Currently unsupported function in TSL that counts trailing zeros in number bit representation
					// Can technically petition GPU for subgroupSize in shader and calculate logs on CPU at cost of shader being generalizable across devices
					// May also break if subgroupSize changes when device is lost or if program is rerun on lower power device
					const subgroupSizeLog = uint( log2( float( subgroupSize ) ) ).toVar( 'subgroupSizeLog' );
					const spineSize = uint( workgroupSize ).shiftRight( subgroupSizeLog );
					const spineSizeLog = uint( log2( float( spineSize ) ) ).toVar( 'spineSizeLog' );


					// Align size to powers of subgroupSize
					const squaredSubgroupLog = ( spineSizeLog.add( subgroupSizeLog ).sub( 1 ) );
					squaredSubgroupLog.divAssign( subgroupSizeLog );
					squaredSubgroupLog.mulAssign( subgroupSizeLog );
					const alignedSize = ( uint( 1 ).shiftLeft( squaredSubgroupLog ) ).toVar( 'alignedSize' );

					// aligned size 2 * 4

					const offset = uint( 0 );

					// In cases where the number of subgroups in a workgroup is greater than the subgroup size itself,
					// we need to iterate over the array again to capture all the data in the workgroup array buffer
					Loop( { start: subgroupSize, end: alignedSize, condition: '<=', name: 'j', type: 'uint', update: '<<= subgroupSizeLog' }, () => {

						const subgroupIndex = ( ( invocationLocalIndex.add( 1 ) ).shiftLeft( offset ) ).sub( 1 );

						const isValidSubgroupIndex = subgroupIndex.lessThan( spineSize ).toVar( 'isValidSubgroupIndex' );

						// Reduce values within the local workgroup memory.
						// Set toVar to ensure subgroupAdd executes before (not within) the if statement.
						const t = subgroupAdd(
							select(
								isValidSubgroupIndex,
								perSubgroupReductionArray.element( subgroupIndex ),
								0
							).uniformFlow()
						).toVar( 't' );

						// Can assign back to workgroupArray since all
						// subgroup threads work in lockstop for subgroupAdd
						If( isValidSubgroupIndex, () => {

							perSubgroupReductionArray.element( subgroupIndex ).assign( t );

						} );

						// Ensure all threads have completed work

						workgroupBarrier();

						offset.addAssign( subgroupSizeLog );

					} );

					// Assign single thread from workgroup to assign workgroup reduction
					If( invocationLocalIndex.equal( uint( 0 ) ), () => {

						const reducedWorkgroupSum = perSubgroupReductionArray.element( uint( spineSize ).sub( 1 ) );
						intermediateBuffer.element( workgroupId.x ).assign( reducedWorkgroupSum );

					} );

				} )().compute( numInvocations, [ maxWorkgroupSize ] );

				return fnDef;

			};


			// INCORRECT BASELINE

			const createIncorrectBaselineFn = ( incorrectBaselineProps ) => {

				const { inputBuffer } = incorrectBaselineProps;

				const fnDef = Fn( () => {

					inputBuffer.element( instanceIndex ).assign( 99999 );

				} )();

				return fnDef;

			};


			init();

			init( false );

			async function init( leftSideDisplay = true ) {

				const effectController = leftSideDisplay ? leftEffectController : rightEffectController;

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const array = new Uint32Array( Array.from( { length: size }, ( _, i ) => {

					return 1;

				} ) );

				// Represents array of data as uints in compute shader.
				const inputStorage = instancedArray( array, 'uint' ).setPBO( true ).setName( `Current_${leftSideDisplay ? 'Left' : 'Right'}` );
				// Represents array of data as vec4s in compute shader;
				const inputVec4BufferAttribute = new THREE.StorageInstancedBufferAttribute( array, 4 );
				const inputVectorizedStorage = storage( inputVec4BufferAttribute, 'uvec4', vecSize ).setPBO( true ).setName( `CurrentVectorized_${leftSideDisplay ? 'Left' : 'Right'}` );

				// Reduce 3 Calculations
				const workPerThread = 4;
				const numRows = workPerThread * 32;
				const rowSize = divRoundUp( size, numRows );

				const workgroupSumsArray = new Uint32Array( numRows );
				const workgroupSumsStorage = instancedArray( workgroupSumsArray, 'uint' ).setPBO( true ).setName( `WorkgroupSums_${leftSideDisplay ? 'Left' : 'Right'}` );
				const debugArray = new Uint32Array( 1024 );
				const debugStorage = instancedArray( debugArray, 'uint' ).setPBO( true ).setName( `Debug_${leftSideDisplay ? 'Left' : 'Right'}` );

				const buffers = {
					'Input Buffer': inputStorage,
					'Input Vectorized Buffer': inputVectorizedStorage,
					'Workgroup Sums Buffer': workgroupSumsStorage,
					'Debug Buffer': debugStorage,
				};

				const logFunctionName = `Log ${leftSideDisplay ? 'Left' : 'Right'} Side`;
				const functionObj = {};
				functionObj[ logFunctionName ] = async() => {

					const selectedBuffer = buffers[ unifiedEffectController.loggedBuffer ];
					console.log( new Uint32Array( await renderer.getArrayBufferAsync( selectedBuffer.value ) ) );

				};

				debugFolder.add( functionObj, `Log ${leftSideDisplay ? 'Left' : 'Right'} Side` );

				const computeResetBufferFn = Fn( () => {

					inputStorage.element( instanceIndex ).assign( 1 );

				} );

				const computeResetWorkgroupSumsFn = Fn( () => {

					workgroupSumsStorage.element( instanceIndex ).assign( 0 );

				} );


				// Re-initialize compute buffer
				const computeResetBuffer = computeResetBufferFn().compute( size );
				const computeResetWorkgroupSums = computeResetWorkgroupSumsFn().compute( 256 );

				const renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				await renderer.init();

				// Unfortunately, need to arbitrarily run compute shader to get access to device limits
				renderer.compute( computeResetBuffer );


				if ( renderer.backend.device !== null ) {

					maxWorkgroupSize = renderer.backend.device.limits.maxComputeWorkgroupSizeX;

				}

				// Create and store dispatches of reduction of certain size. Map each set of dispatches to algorithm name.

				const computeReduce0Fn = Fn( () => {

					const { numThreadsDispatched } = effectController;

					inputStorage.element( instanceIndex ).addAssign( inputStorage.element( instanceIndex.add( numThreadsDispatched ) ) );

				} )();

				const reduce0Calls = [];

				for ( let i = size / 2; i >= 1; i /= 2 ) {

					const reduce0 = computeReduce0Fn.compute( i, [ maxWorkgroupSize ] );
					reduce0Calls.push( reduce0 );

				}

				const reduce1Calls = [
					// Accumulation
					createReduce1Fn( {
						dispatchSize: maxWorkgroupSize * maxWorkgroupSize,
						workgroupSize: maxWorkgroupSize,
						numElements: size,
						inputBuffer: inputStorage,
					} ),
					// 1 Block accumulation
					createReduce1Fn( {
						dispatchSize: maxWorkgroupSize,
						numElements: maxWorkgroupSize * maxWorkgroupSize,
						workgroupSize: maxWorkgroupSize,
						inputBuffer: inputStorage,
					} ),
					// Final result
					createReduce1Fn( {
						dispatchSize: 1,
						numElements: maxWorkgroupSize,
						workgroupSize: 1,
						inputBuffer: inputStorage
					} ),
				];

				const reduce2Calls = [
					// Accumulate within workgroups
					createReduce2Fn( {
						workgroupSize: maxWorkgroupSize,
						dispatchSize: maxWorkgroupSize * maxWorkgroupSize,
						numElements: size,
						inputBuffer: inputStorage,
					} ),
					// 1 Block accumulation
					createReduce2Fn( {
						workgroupSize: maxWorkgroupSize,
						dispatchSize: maxWorkgroupSize,
						numElements: maxWorkgroupSize,
						inputBuffer: inputStorage,
					} ),
				];

				const reduce3Calls = [
					createReduce3Fn( {
						inputBuffer: inputStorage,
						intermediateBuffer: workgroupSumsStorage,
						workgroupSize: maxWorkgroupSize,
						workPerThread: 4,
						rowSize: rowSize,
						vectorized: false,
					} ).compute( maxWorkgroupSize * numRows, [ maxWorkgroupSize ] ),
					createReduce3Fn( {
						inputBuffer: workgroupSumsStorage,
						intermediateBuffer: inputStorage,
						workgroupSize: 32,
						workPerThread: 4,
						rowSize: rowSize,
						vectorized: false
					} ).compute( 32, [ 32 ] )
				];

				const reduce4Calls = [
					createReduce4Fn( {
						size: size,
						inputBuffer: inputVectorizedStorage,
						intermediateBuffer: workgroupSumsStorage,
						workgroupSize: maxWorkgroupSize,
						workPerThread: 4,
					} ),
					createReduce3Fn( {
						inputBuffer: workgroupSumsStorage,
						intermediateBuffer: inputStorage,
						workgroupSize: 32,
						workPerThread: 4,
						rowSize: rowSize,
						vectorized: false
					} ).compute( 32, [ 32 ] )
				];

				const incorrectBaselineCalls = [
					createIncorrectBaselineFn( {
						inputBuffer: inputStorage,
					} ).compute( size ),
				];

				const calls = {
					'Reduce 0 (N/2)': reduce0Calls,
					'Reduce 1 (Naive Accumulate)': reduce1Calls,
					'Reduce 2 (Workgroup Reduction)': reduce2Calls,
					'Reduce 3 (Subgroup Reduce)': reduce3Calls,
					'Reduce 4 (Subgroup Optimized)': reduce4Calls,
					'Incorrect Baseline': incorrectBaselineCalls
				};

				const getColor = ( bufferToCheck, colorChanger, width, height ) => {

					const subtracter = float( colorChanger ).div( width.mul( height ) );

					const color = vec3( subtracter.oneMinus() ).toVar();

					const { highlight } = effectController;

					// Validate that element 0 is equal to expected result of reduction
					If( highlight.equal( 1 ), () => {

						If( ( bufferToCheck.element( 0 ) ).equal( size ), () => {

							color.assign( vec3( 0.0, subtracter.oneMinus(), 0.0 ) );

						} ).Else( () => {

							color.assign( vec3( subtracter.oneMinus(), 0.0, 0.0 ) );

						} );

					} );

					return color;

				};

				const displayNodes = leftSideDisplay ? leftDisplayColorNodes : rightDisplayColorNodes;
				displayNodes[ 'Input Grid' ] = Fn( () => {

					const { gridElementWidth, gridElementHeight, gridDisplayWidth, gridDisplayHeight } = unifiedEffectController;

					const newUV = uv().mul( vec2( gridDisplayWidth, gridDisplayHeight ) );

					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );

					const elementIndex = uint( gridDisplayWidth ).mul( pixel.y ).add( pixel.x );

					const colorChanger = uint( 0 ).toVar();
					const color = vec3( 0 ).toVar( 'color' );

					colorChanger.assign( inputStorage.element( elementIndex ) );
					color.assign( getColor( inputStorage, colorChanger, gridElementWidth, gridElementHeight ) );

					return color;

				} )();

				displayNodes[ 'Input Log2' ] = Fn( () => {

					const { gridElementWidth, gridElementHeight } = unifiedEffectController;

					const newUV = uv().mul( vec2( Math.log2( size ) ), 1 );

					const colorChanger = uint( 0 ).toVar();
					const color = vec3( 0 ).toVar( 'color' );

					colorChanger.assign( inputStorage.element( uint( 1 ).shiftLeft( newUV.x ) ) );
					color.assign( getColor( inputStorage, colorChanger, gridElementWidth, gridElementHeight ) );

					return color;

				} )();

				displayNodes[ 'Input Element 0' ] = Fn( () => {

					const { gridElementWidth, gridElementHeight } = unifiedEffectController;

					const colorChanger = uint( 0 ).toVar();
					const color = vec3( 0 ).toVar( 'color' );

					// Clamp display of single element to shade where green is still readable
					colorChanger.assign( clamp( inputStorage.element( 0 ), 0, size / 2 ) );
					color.assign( getColor( inputStorage, colorChanger, gridElementWidth, gridElementHeight ) );
					return color;

				} )();

				displayNodes[ 'Workgroup Sum Grid' ] = Fn( () => {

					const width = uint( 8 );
					const height = uint( 16 );

					const newUV = uv().mul( vec2( width, height ) );

					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );

					const elementIndex = uint( width ).mul( pixel.y ).add( pixel.x );

					const colorChanger = uint( 0 ).toVar();
					const color = vec3( 0 ).toVar( 'color' );

					colorChanger.assign( workgroupSumsStorage.element( elementIndex ) );
					color.assign( getColor( inputStorage, colorChanger, width, height ) );

					return color;

				} )();

				( leftSideDisplay ? leftMaterial : rightMaterial ).colorNode = displayNodes[ effectController.displayMode ];
				( leftSideDisplay ? leftMaterial : rightMaterial ).needsUpdate = true;

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), ( leftSideDisplay ? leftMaterial : rightMaterial ) );
				scene.add( plane );

				const animate = () => {

					renderer.render( scene, camera );

				};

				renderer.setAnimationLoop( animate );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( ! leftSideDisplay ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );

				} else {

					scene.background = new THREE.Color( 0x313131 );

				}

				renderer.info.autoReset = false;

				const stepAnimation = async function () {

					const currentAlgorithm = effectController.algo;
					const state = effectController.state;
					const stateController = leftSideDisplay ? stateLeftController : stateRightController;

					if ( state === 'Reset' ) {

						renderer.compute( computeResetBuffer );
						renderer.compute( computeResetWorkgroupSums );

					} else if ( state === 'Run Algo' ) {

						renderer.info.reset();

						const cpuTime = 0;

						switch ( currentAlgorithm ) {

							case 'Reduce 0 (N/2)': {

								let m = size / 2;

								for ( let i = 0; i < reduce0Calls.length; i ++ ) {

									effectController.numThreadsDispatched.value = m;

									const reduce0 = reduce0Calls[ i ];
									// Do a reduction step
									renderer.compute( reduce0 );
									renderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );

									m /= 2;

								}


								break;

							}

							default: {

								const currentAlgoCalls = calls[ currentAlgorithm ];

								for ( let i = 0; i < currentAlgoCalls.length; i ++ ) {

									renderer.compute( currentAlgoCalls[ i ] );
									renderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );

								}

								break;

							}

						}

						// DEBUG: const reductionResult = new Uint32Array( await renderer.getArrayBufferAsync( currentBuffer ) )[0];

						let passInfoString = '';

						if ( effectController.algo.substring( 0, 3 ) === 'CPU' ) {

							passInfoString = `Ran in ${cpuTime}ms<br>`;

						} else {

							passInfoString = `${renderer.info.compute.frameCalls} pass in ${renderer.info.compute.timestamp.toFixed( 6 )}ms<br>`;

						}




						timestamps[ leftSideDisplay ? 'left_side_display' : 'right_side_display' ].innerHTML = `

							Compute ${effectController.algo}: ${passInfoString}`;

					}

					renderer.render( scene, camera );
					renderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );

					// Validate next state

					if ( state === 'Run Algo' ) {

						stateController.setValue( 'Validate' );

						effectController.highlight.value = 1;

					} else if ( state === 'Validate' ) {

						stateController.setValue( 'Reset' );

						effectController.highlight.value = 0;

					} else if ( state === 'Reset' ) {

						stateController.setValue( 'Run Algo' );

					}

					setTimeout( stepAnimation, 1000 );

				};


				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

				setTimeout( stepAnimation, 1000 );

			}

		</script>
	</body>
</html>


================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_sort_bitonic.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - storage pbo external element</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<style>
			.swap_area {
				position: absolute;
				top: 150px;
				padding: 10px;
				background: rgba( 0, 0, 0, 0.5 );
				color: #fff;
				font-family: monospace;
				font-size: 12px;
				line-height: 1.5;
				pointer-events: none;
				text-align: left;
			}
		
		</style>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br /> This example demonstrates a bitonic sort running step by step in a compute shader.
			<br /> The left canvas swaps values within workgroup local arrays. The right swaps values within storage buffers.
			<br /> Reference implementation by <a href="https://poniesandlight.co.uk/reflect/bitonic_merge_sort/">Tim Gfrerer</a>
			<br />
			<div id="local_swap" class="swap_area" style="left: 0;"></div>
			<div id="global_swap" class="swap_area" style="right: 0;"></div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { storage, If, vec3, not, uniform, uv, uint, Fn, vec2, abs, int, uvec2, floor, instanceIndex } from 'three/tsl';

			import { BitonicSort, getBitonicDisperseIndices, getBitonicFlipIndices } from 'three/addons/gpgpu/BitonicSort.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const StepType = {

				NONE: 0,
				// Swap values within workgroup local values
				SWAP_LOCAL: 1,
				DISPERSE_LOCAL: 2,
				// Swap values within global data buffer.
				FLIP_GLOBAL: 3,
				DISPERSE_GLOBAL: 4,

			};

			const timestamps = {
				local_swap: document.getElementById( 'local_swap' ),
				global_swap: document.getElementById( 'global_swap' )
			};

			const localColors = [ 'rgb(203, 64, 203)', 'rgb(0, 215, 215)' ];
			const globalColors = [ 'rgb(1, 150, 1)', 'red' ];

			// Total number of elements and the dimensions of the display grid.
			const size = 16384;
			const gridDim = Math.sqrt( size );

			const getNumSteps = () => {

				const n = Math.log2( size );
				return ( n * ( n + 1 ) ) / 2;

			};

			// Total number of steps in a bitonic sort with 'size' elements.
			const MAX_STEPS = getNumSteps();

			const effectController = {
				// Sqr root of 16834
				gridWidth: uniform( gridDim ),
				gridHeight: uniform( gridDim ),
				highlight: uniform( 1 ),
				stepBitonic: true,
				'Display Mode': 'Swap Zone Highlight'
			};

			const gui = new GUI();
			gui.add( effectController, 'Display Mode', [ 'Elements', 'Swap Zone Highlight' ] ).onChange( () => {

				if ( effectController[ 'Display Mode' ] === 'Elements' ) {

					effectController.highlight.value = 0;


				} else {

					effectController.highlight.value = 1;

				}

			} );

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			// Display utilities

			const getElementIndex = Fn( ( [ uvNode, gridWidth, gridHeight ] ) => {

				const newUV = uvNode.mul( vec2( gridWidth, gridHeight ) );
				const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );
				const elementIndex = uint( gridWidth ).mul( pixel.y ).add( pixel.x );

				return elementIndex;

			}, {
				uvNode: 'vec2',
				gridWidth: 'uint',
				gridHeight: 'uint',
				return: 'uint'
			} );

			const getColor = Fn( ( [ colorChanger, gridWidth, gridHeight ] ) => {

				const subtracter = colorChanger.div( gridWidth.mul( gridHeight ) );
				return vec3( subtracter.oneMinus() ).toVar();

			}, {
				colorChanger: 'float',
				gridWidth: 'float',
				gridHeight: 'float',
				return: 'vec3'
			} );

			const randomizeDataArray = ( array ) => {

				let currentIndex = array.length;
				while ( currentIndex !== 0 ) {

					const randomIndex = Math.floor( Math.random() * currentIndex );
					currentIndex -= 1;
					[ array[ currentIndex ], array[ randomIndex ] ] = [
						array[ randomIndex ],
						array[ currentIndex ],
					];

				}

			};

			const windowResizeCallback = ( renderer, scene, camera ) => {

				renderer.setSize( window.innerWidth / 2, window.innerHeight );
				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const frustumHeight = camera.top - camera.bottom;
				camera.left = - frustumHeight * aspect / 2;
				camera.right = frustumHeight * aspect / 2;
				camera.updateProjectionMatrix();
				renderer.render( scene, camera );

			};

			const constructInnerHTML = ( isGlobal, colorsArr ) => {

				return `

				Compute ${isGlobal ? 'Global' : 'Local'}:
				<div style="display: flex; flex-direction:row; justify-content: center; align-items: center;">
					${isGlobal ? 'Global Swaps' : 'Local Swaps'} Compare Region&nbsp;
					<div style="background-color: ${ colorsArr[ 0 ]}; width:12.5px; height: 1em; border-radius: 20%;"></div>
					&nbsp;to Region&nbsp;
					<div style="background-color: ${ colorsArr[ 1 ] }; width:12.5px; height: 1em; border-radius: 20%;"></div>
				</div>`;

			};

			const createDisplayMesh = ( elementsStorage, algoStorage = null, blockHeightStorage = null ) => {

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				const display = Fn( () => {

					const { gridWidth, gridHeight, highlight } = effectController;

					const elementIndex = getElementIndex( uv(), gridWidth, gridHeight );
					const color = getColor( elementsStorage.element( elementIndex ), gridWidth, gridHeight ).toVar();

					if ( algoStorage !== null && blockHeightStorage !== null ) {

						If( highlight.equal( 1 ).and( not( algoStorage.element( 0 ).equal( StepType.NONE ) ) ), () => {

							const boolCheck = int( elementIndex.mod( blockHeightStorage.element( 0 ) ).lessThan( blockHeightStorage.element( 0 ).div( 2 ) ) );
							color.z.assign( algoStorage.element( 0 ).lessThanEqual( StepType.DISPERSE_LOCAL ) );
							color.x.mulAssign( boolCheck );
							color.y.mulAssign( abs( boolCheck.sub( 1 ) ) );

						} );

					}

					return color;

				} );

				material.colorNode = display();
				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				return plane;

			};

			const createDisplayMesh2 = ( elementsStorage, infoStorage ) => {

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				const display = Fn( () => {

					const { gridWidth, gridHeight, highlight } = effectController;

					const elementIndex = getElementIndex( uv(), gridWidth, gridHeight );
					const color = getColor( elementsStorage.element( elementIndex ), gridWidth, gridHeight ).toVar();


					If( highlight.equal( 1 ).and( not( infoStorage.element( 0 ).equal( StepType.SWAP_LOCAL ) ) ), () => {

						const boolCheck = int( elementIndex.mod( infoStorage.element( 1 ) ).lessThan( infoStorage.element( 1 ).div( 2 ) ) );
						color.z.assign( infoStorage.element( 0 ).lessThanEqual( StepType.DISPERSE_LOCAL ) );
						color.x.mulAssign( boolCheck );
						color.y.mulAssign( abs( boolCheck.sub( 1 ) ) );

					} );


					return color;

				} );

				material.colorNode = display();
				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				return plane;

			};
			
			const setupDomElement = ( renderer ) => {

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

			};

			async function initBitonicSort() {

				let currentStep = 0;

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const array = new Uint32Array( Array.from( { length: size }, ( _, i ) => {

					return i;

				} ) );


				randomizeDataArray( array );

				const currentElementsBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );
				const currentElementsStorage = storage( currentElementsBuffer, 'uint', size ).setPBO( true ).setName( 'Elements' );
				const randomizedElementsBuffer = new THREE.StorageInstancedBufferAttribute( size, 1 );
				const randomizedElementsStorage = storage( randomizedElementsBuffer, 'uint', size ).setPBO( true ).setName( 'RandomizedElements' );

				const computeInitFn = Fn( () => {

					randomizedElementsStorage.element( instanceIndex ).assign( currentElementsStorage.element( instanceIndex ) );

				} );

				const computeResetBuffersFn = Fn( () => {

					currentElementsStorage.element( instanceIndex ).assign( randomizedElementsStorage.element( instanceIndex ) );

				} );

				const renderer = new THREE.WebGPURenderer( { antialias: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				await renderer.init();

				const animate = () => {

					renderer.render( scene, camera );

				};

				renderer.setAnimationLoop( animate );
				setupDomElement( renderer );
				scene.background = new THREE.Color( 0x313131 );

				const bitonicSortModule = new BitonicSort(
					renderer,
					currentElementsStorage,
					{
						workgroupSize: 64,
					}
				);

				scene.add( createDisplayMesh2( currentElementsStorage, bitonicSortModule.infoStorage ) );

				// Initialize each value in the elements buffer.
				const computeInit = computeInitFn().compute( size );
				const computeReset = computeResetBuffersFn().compute( size );

				renderer.compute( computeInit );

				const stepAnimation = async function () {

					renderer.info.reset();

					if ( currentStep < bitonicSortModule.stepCount ) {

						bitonicSortModule.computeStep( renderer );

						currentStep ++;

					} else {

						renderer.compute( computeReset );

						currentStep = 0;

					}

					timestamps[ 'local_swap' ].innerHTML = constructInnerHTML( false, localColors );

					if ( currentStep === bitonicSortModule.stepCount ) {

						setTimeout( stepAnimation, 1000 );

					} else {

						setTimeout( stepAnimation, 100 );

					}

				};

				stepAnimation();

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					windowResizeCallback( renderer, scene, camera );

				}

			}

			initBitonicSort();

			// Global Swaps Only
			initGlobalSwapOnly();

			// When forceGlobalSwap is true, force all valid local swaps to be global swaps.
			async function initGlobalSwapOnly() {

				let currentStep = 0;

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const infoArray = new Uint32Array( [ 3, 2, 2 ] );
				const infoBuffer = new THREE.StorageInstancedBufferAttribute( infoArray, 1 );
				const infoStorage = storage( infoBuffer, 'uint', infoBuffer.count ).setPBO( true ).setName( 'TheInfo' );

				const nextBlockHeightBuffer = new THREE.StorageInstancedBufferAttribute( new Uint32Array( 1 ).fill( 2 ), 1 );
				const nextBlockHeightStorage = storage( nextBlockHeightBuffer, 'uint', nextBlockHeightBuffer.count ).setPBO( true ).setName( 'NextBlockHeight' );
				const nextBlockHeightRead = storage( nextBlockHeightBuffer, 'uint', nextBlockHeightBuffer.count ).setPBO( true ).setName( 'NextBlockHeight' ).toReadOnly();

				const array = new Uint32Array( Array.from( { length: size }, ( _, i ) => {

					return i;

				} ) );

				randomizeDataArray( array );

				const currentElementsBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );
				const currentElementsStorage = storage( currentElementsBuffer, 'uint', size ).setPBO( true ).setName( 'Elements' );
				const tempBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );
				const tempStorage = storage( tempBuffer, 'uint', size ).setPBO( true ).setName( 'Temp' );
				const randomizedElementsBuffer = new THREE.StorageInstancedBufferAttribute( size, 1 );
				const randomizedElementsStorage = storage( randomizedElementsBuffer, 'uint', size ).setPBO( true ).setName( 'RandomizedElements' );

				// Swap the elements in local storage
				const globalCompareAndSwap = ( idxBefore, idxAfter ) => {

					// If the later element is less than the current element
					If( currentElementsStorage.element( idxAfter ).lessThan( currentElementsStorage.element( idxBefore ) ), () => {

						// Apply the swapped values to temporary storage.
						tempStorage.element( idxBefore ).assign( currentElementsStorage.element( idxAfter ) );
						tempStorage.element( idxAfter ).assign( currentElementsStorage.element( idxBefore ) );

					} ).Else( () => {

						// Otherwise apply the existing values to temporary storage.
						tempStorage.element( idxBefore ).assign( currentElementsStorage.element( idxBefore ) );
						tempStorage.element( idxAfter ).assign( currentElementsStorage.element( idxAfter ) );

					} );

				};

				const computeInitFn = Fn( () => {

					randomizedElementsStorage.element( instanceIndex ).assign( currentElementsStorage.element( instanceIndex ) );

				} );

				const computeBitonicStepFn = Fn( () => {

					const nextBlockHeight = nextBlockHeightStorage.element( 0 ).toVar();
					const nextAlgo = infoStorage.element( 0 ).toVar();

					// TODO: Convert to switch block.
					If( nextAlgo.equal( uint( StepType.FLIP_GLOBAL ) ), () => {

						const idx = getBitonicFlipIndices( instanceIndex, nextBlockHeight );
						globalCompareAndSwap( idx.x, idx.y );

					} ).ElseIf( nextAlgo.equal( uint( StepType.DISPERSE_GLOBAL ) ), () => {

						const idx = getBitonicDisperseIndices( instanceIndex, nextBlockHeight );
						globalCompareAndSwap( idx.x, idx.y );

					} );

					// Since this algorithm is global only, we execute an additional compute step to sync the current buffer with the output buffer.

				} );

				const computeSetAlgoFn = Fn( () => {

					const nextBlockHeight = nextBlockHeightStorage.element( 0 ).toVar();
					const nextAlgo = infoStorage.element( 0 );
					const highestBlockHeight = infoStorage.element( 2 ).toVar();

					nextBlockHeight.divAssign( 2 );

					If( nextBlockHeight.equal( 1 ), () => {

						highestBlockHeight.mulAssign( 2 );

						If( highestBlockHeight.equal( size * 2 ), () => {

							nextAlgo.assign( StepType.NONE );
							nextBlockHeight.assign( 0 );

						} ).Else( () => {

							nextAlgo.assign( StepType.FLIP_GLOBAL );
							nextBlockHeight.assign( highestBlockHeight );

						} );


					} ).Else( () => {

						nextAlgo.assign( StepType.DISPERSE_GLOBAL );

					} );

					nextBlockHeightStorage.element( 0 ).assign( nextBlockHeight );
					infoStorage.element( 2 ).assign( highestBlockHeight );

				} );

				const computeAlignCurrentFn = Fn( () => {

					currentElementsStorage.element( instanceIndex ).assign( tempStorage.element( instanceIndex ) );

				} );

				const computeResetBuffersFn = Fn( () => {

					currentElementsStorage.element( instanceIndex ).assign( randomizedElementsStorage.element( instanceIndex ) );

				} );

				const computeResetAlgoFn = Fn( () => {

					infoStorage.element( 0 ).assign( StepType.FLIP_GLOBAL );
					nextBlockHeightStorage.element( 0 ).assign( 2 );
					infoStorage.element( 2 ).assign( 2 );

				} );

				// Initialize each value in the elements buffer.
				const computeInit = computeInitFn().compute( size );
				// Swap a pair of elements in the elements buffer.
				const computeBitonicStep = computeBitonicStepFn().compute( size / 2 );
				// Set the conditions for the next swap.
				const computeSetAlgo = computeSetAlgoFn().compute( 1 );
				// Align the current buffer with the temp buffer if the previous sort was executed in a global scope.
				const computeAlignCurrent = computeAlignCurrentFn().compute( size );
				// Reset the buffers and algorithm information after a full bitonic sort has been completed.
				const computeResetBuffers = computeResetBuffersFn().compute( size );
				const computeResetAlgo = computeResetAlgoFn().compute( 1 );

				scene.add( createDisplayMesh( currentElementsStorage, infoStorage, nextBlockHeightRead ) );

				const renderer = new THREE.WebGPURenderer( { antialias: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				await renderer.init();

				const animate = () => {

					renderer.render( scene, camera );

				};

				renderer.setAnimationLoop( animate );
				setupDomElement( renderer );
				renderer.domElement.style.left = '50%';
				scene.background = new THREE.Color( 0x212121 );

				renderer.compute( computeInit );

				const stepAnimation = async function () {

					if ( currentStep !== MAX_STEPS ) {

						renderer.compute( computeBitonicStep );

						renderer.compute( computeAlignCurrent );

						renderer.compute( computeSetAlgo );

						currentStep ++;

					} else {

						renderer.compute( computeResetBuffers );
						renderer.compute( computeResetAlgo );

						currentStep = 0;

					}

					timestamps[ 'global_swap' ].innerHTML = constructInnerHTML( true, globalColors );

					if ( currentStep === MAX_STEPS ) {

						setTimeout( stepAnimation, 1000 );

					} else {

						setTimeout( stepAnimation, 100 );

					}

				};

				stepAnimation();

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					windowResizeCallback( renderer, scene, camera );

				}

			}
		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_texture.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - compute texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Compute Texture</span>
			</div>

			<small>
				Compute texture using GPU.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, textureStore, Fn, instanceIndex, float, uvec2, vec4 } from 'three/tsl';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let camera, scene, renderer;

			init().then( render );

			async function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				const aspect = window.innerWidth / window.innerHeight;
				camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				scene = new THREE.Scene();

				// texture

				const width = 512, height = 512;

				const storageTexture = new THREE.StorageTexture( width, height );
				//storageTexture.minFilter = THREE.LinearMipMapLinearFilter;

				// create function

				const computeTexture = Fn( ( { storageTexture } ) => {

					const posX = instanceIndex.mod( width );
					const posY = instanceIndex.div( width );
					const indexUV = uvec2( posX, posY );

					// https://www.shadertoy.com/view/Xst3zN

					const x = float( posX ).div( 50.0 );
					const y = float( posY ).div( 50.0 );

					const v1 = x.sin();
					const v2 = y.sin();
					const v3 = x.add( y ).sin();
					const v4 = x.mul( x ).add( y.mul( y ) ).sqrt().add( 5.0 ).sin();
					const v = v1.add( v2, v3, v4 );

					const r = v.sin();
					const g = v.add( Math.PI ).sin();
					const b = v.add( Math.PI ).sub( 0.5 ).sin();

					textureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();

				} );

				// compute

				const computeNode = computeTexture( { storageTexture } ).compute( width * height );

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );
				material.colorNode = texture( storageTexture );

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				// compute texture
				renderer.compute( computeNode );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				const aspect = window.innerWidth / window.innerHeight;

				const frustumHeight = camera.top - camera.bottom;

				camera.left = - frustumHeight * aspect / 2;
				camera.right = frustumHeight * aspect / 2;

				camera.updateProjectionMatrix();

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_texture_3d.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute texture 3D</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Compute Texture 3D</span>
			</div>

			<small>
				Compute texture 3D using GPU.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { time, mx_noise_vec3, instanceIndex, textureStore, float, vec3, vec4, If, Break, Fn, smoothstep, texture3D, uniform } from 'three/tsl';

			import { RaymarchingBox } from 'three/addons/tsl/utils/Raymarching.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let renderer, scene, camera;
			let mesh;
			let computeNode;

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			init();

			async function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 1, 1.5 );

				new OrbitControls( camera, renderer.domElement );

				// Sky

				const canvas = document.createElement( 'canvas' );
				canvas.width = 1;
				canvas.height = 32;

				const context = canvas.getContext( '2d' );
				const gradient = context.createLinearGradient( 0, 0, 0, 32 );
				gradient.addColorStop( 0.0, '#014a84' );
				gradient.addColorStop( 0.5, '#0561a0' );
				gradient.addColorStop( 1.0, '#437ab6' );
				context.fillStyle = gradient;
				context.fillRect( 0, 0, 1, 32 );

				const skyMap = new THREE.CanvasTexture( canvas );
				skyMap.colorSpace = THREE.SRGBColorSpace;

				const sky = new THREE.Mesh(
					new THREE.SphereGeometry( 10 ),
					new THREE.MeshBasicNodeMaterial( { map: skyMap, side: THREE.BackSide } )
				);
				scene.add( sky );

				// Texture

				const size = 200;

				const computeCloud = Fn( ( { storageTexture } ) => {

					const scale = float( 0.05 );
					const id = instanceIndex;

					const x = id.mod( size );
					const y = id.div( size ).mod( size );
					const z = id.div( size * size );

			
					const coord3d = vec3( x, y, z );
					const centered = coord3d.sub( size / 2 ).div( size );
					const d = float( 1.0 ).sub( centered.length() );

					const noiseCoord = coord3d.mul( scale.div( 1.5 ) ).add( time );

					const noise = mx_noise_vec3( noiseCoord ).toConst( 'noise' );

					const data = noise.mul( d ).mul( d ).toConst( 'data' );

					textureStore( storageTexture, vec3( x, y, z ), vec4( vec3( data.x ), 1.0 ) );

				} );

				const storageTexture = new THREE.Storage3DTexture( size, size, size );
				storageTexture.generateMipmaps = false;
				storageTexture.name = 'cloud';
			
				computeNode = computeCloud( { storageTexture } ).compute( size * size * size ).setName( 'computeCloud' );

				// Shader

				const transparentRaymarchingTexture = Fn( ( {
					texture,
					range = float( 0.14 ),
					threshold = float( 0.08 ),
					opacity = float( 0.18 ),
					steps = float( 100 )
				} ) => {

					const finalColor = vec4( 0 ).toVar();

					RaymarchingBox( steps, ( { positionRay } ) => {

						const mapValue = float( texture.sample( positionRay.add( 0.5 ) ).r ).toVar();

						mapValue.assign( smoothstep( threshold.sub( range ), threshold.add( range ), mapValue ).mul( opacity ) );

						const shading = texture.sample( positionRay.add( vec3( - 0.01 ) ) ).r.sub( texture.sample( positionRay.add( vec3( 0.01 ) ) ).r );

						const col = shading.mul( 4.0 ).add( positionRay.x.add( positionRay.y ).mul( 0.5 ) ).add( 0.3 );

						finalColor.rgb.addAssign( finalColor.a.oneMinus().mul( mapValue ).mul( col ) );

						finalColor.a.addAssign( finalColor.a.oneMinus().mul( mapValue ) );

						If( finalColor.a.greaterThanEqual( 0.95 ), () => {

							Break();

						} );

					} );

					return finalColor;

				} );

				// Material

				const baseColor = uniform( new THREE.Color( 0x798aa0 ) );
				const range = uniform( 0.1 );
				const threshold = uniform( 0.08 );
				const opacity = uniform( 0.08 );
				const steps = uniform( 100 );

				const cloud3d = transparentRaymarchingTexture( {
					texture: texture3D( storageTexture, null, 0 ),
					range,
					threshold,
					opacity,
					steps
				} );

				const finalCloud = cloud3d.setRGB( cloud3d.rgb.add( baseColor ) );

				const material = new THREE.NodeMaterial();
				material.colorNode = finalCloud;
				material.side = THREE.BackSide;
				material.transparent = true;
				material.name = 'transparentRaymarchingMaterial';

				mesh = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), material );
				scene.add( mesh );

				mesh.rotation.y = Math.PI / 2;

				//

				renderer.compute( computeNode );

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( threshold, 'value', 0, 1, 0.01 ).name( 'threshold' );
				gui.add( opacity, 'value', 0, 1, 0.01 ).name( 'opacity' );
				gui.add( range, 'value', 0, 1, 0.01 ).name( 'range' );
				gui.add( steps, 'value', 0, 200, 1 ).name( 'steps' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.compute( computeNode );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_texture_pingpong.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - compute ping/pong texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Compute Ping/Pong Texture</span>
			</div>

			<small>
				Compute ping/pong texture using GPU.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { storageTexture, wgslFn, code, instanceIndex, uniform, NodeAccess } from 'three/tsl';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let camera, scene, renderer;
			let computeInitNode, computeToPing, computeToPong;
			let pingTexture, pongTexture;
			let material;
			let phase = true;
			let lastUpdate = - 1;

			const seed = uniform( new THREE.Vector2() );

			init();

			async function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				const aspect = window.innerWidth / window.innerHeight;
				camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				scene = new THREE.Scene();

				// texture

				const hdr = true;
				const width = 512, height = 512;

				pingTexture = new THREE.StorageTexture( width, height );
				pongTexture = new THREE.StorageTexture( width, height );

				if ( hdr ) {

					pingTexture.type = THREE.HalfFloatType;
					pongTexture.type = THREE.HalfFloatType;

				}

				const wgslFormat = hdr ? 'rgba16float' : 'rgba8unorm';
			
				const readPing = storageTexture( pingTexture ).setAccess( NodeAccess.READ_ONLY );
				const writePing = storageTexture( pingTexture ).setAccess( NodeAccess.WRITE_ONLY );
				const readPong = storageTexture( pongTexture ).setAccess( NodeAccess.READ_ONLY );
				const writePong = storageTexture( pongTexture ).setAccess( NodeAccess.WRITE_ONLY );

				// compute init

				const rand2 = code( `
					fn rand2( n: vec2f ) -> f32 {

						return fract( sin( dot( n, vec2f( 12.9898, 4.1414 ) ) ) * 43758.5453 );

					}

					fn blur( image : texture_storage_2d<${wgslFormat}, read>, uv : vec2i ) -> vec4f {

						var color = vec4f( 0.0 );

						color += textureLoad( image, uv + vec2i( - 1, 1 ));
						color += textureLoad( image, uv + vec2i( - 1, - 1 ));
						color += textureLoad( image, uv + vec2i( 0, 0 ));
						color += textureLoad( image, uv + vec2i( 1, - 1 ));
						color += textureLoad( image, uv + vec2i( 1, 1 ));

						return color / 5.0; 
					}

					fn getUV( posX: u32, posY: u32 ) -> vec2f {

						let uv = vec2f( f32( posX ) / ${ width }.0, f32( posY ) / ${ height }.0 );

						return uv;

					}
				` );

				const computeInitWGSL = wgslFn( `
					fn computeInitWGSL( writeTex: texture_storage_2d<${ wgslFormat }, write>, index: u32, seed: vec2f ) -> void {

						let posX = index % ${ width };
						let posY = index / ${ width };
						let indexUV = vec2u( posX, posY );
						let uv = getUV( posX, posY );

						let r = rand2( uv + seed * 100 ) - rand2( uv + seed * 300 );
						let g = rand2( uv + seed * 200 ) - rand2( uv + seed * 300 );
						let b = rand2( uv + seed * 200 ) - rand2( uv + seed * 100 );

						textureStore( writeTex, indexUV, vec4( r, g, b, 1 ) );

					}
				`, [ rand2 ] );

				computeInitNode = computeInitWGSL( { writeTex: storageTexture( pingTexture ), index: instanceIndex, seed } ).compute( width * height );

				// compute loop

				const computePingPongWGSL = wgslFn( `
					fn computePingPongWGSL( readTex: texture_storage_2d<${wgslFormat}, read>, writeTex: texture_storage_2d<${ wgslFormat }, write>, index: u32 ) -> void {

						let posX = index % ${ width };
						let posY = index / ${ width };
						let indexUV = vec2i( i32( posX ), i32( posY ) );

						let color = blur( readTex, indexUV ).rgb;

						textureStore( writeTex, indexUV, vec4f( color * 1.05, 1 ) );

					}
				`, [ rand2 ] );

				//

				computeToPong = computePingPongWGSL( { readTex: readPing, writeTex: writePong, index: instanceIndex } ).compute( width * height );
				computeToPing = computePingPongWGSL( { readTex: readPong, writeTex: writePing, index: instanceIndex } ).compute( width * height );

				//

				material = new THREE.MeshBasicMaterial( { color: 0xffffff, map: pongTexture } );

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				window.addEventListener( 'resize', onWindowResize );

				// compute init

				renderer.compute( computeInitNode );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				const aspect = window.innerWidth / window.innerHeight;

				const frustumHeight = camera.top - camera.bottom;

				camera.left = - frustumHeight * aspect / 2;
				camera.right = frustumHeight * aspect / 2;

				camera.updateProjectionMatrix();

			}

			function render() {

				const time = performance.now();
				const seconds = Math.floor( time / 1000 );

				// reset every second

				if ( phase && seconds !== lastUpdate ) {

					seed.value.set( Math.random(), Math.random() );

					renderer.compute( computeInitNode );

					lastUpdate = seconds;

				}

				// compute step

				renderer.compute( phase ? computeToPong : computeToPing );

				material.map = phase ? pongTexture : pingTexture;

				phase = ! phase;

				// render step

				// update material texture node

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_compute_water.html
================================================
 <!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute water</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Compute Water</span>
			</div>

			<small>
				Click and move mouse to disturb water.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { instanceIndex, struct, If, uint, int, floor, float, length, clamp, vec2, cos, vec3, vertexIndex, Fn, uniform, instancedArray, min, max, positionLocal, transformNormalToView, globalId } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
 			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			// Dimensions of simulation grid.
			const WIDTH = 128;

			// Water size in system units.
			const BOUNDS = 6;
			const BOUNDS_HALF = BOUNDS * 0.5;
			const limit = BOUNDS_HALF - 0.2;

			const waterMaxHeight = 0.1;

			let container;
			let camera, scene, renderer, controls;

			let mouseDown = false;
			let firstClick = true;
			let updateOriginMouseDown = false;

			const mouseCoords = new THREE.Vector2();
			const raycaster = new THREE.Raycaster();
			let frame = 0;

			const effectController = {
				mousePos: uniform( new THREE.Vector2() ).setName( 'mousePos' ),
				mouseSpeed: uniform( new THREE.Vector2() ).setName( 'mouseSpeed' ),
				mouseDeep: uniform( .5 ).setName( 'mouseDeep' ),
				mouseSize: uniform( 0.12 ).setName( 'mouseSize' ),
				viscosity: uniform( 0.96 ).setName( 'viscosity' ),
				ducksEnabled: true,
				wireframe: false,
				speed: 5,
			};

			let sun;
			let waterMesh;
			let poolBorder;
			let meshRay;
			let computeHeight, computeDucks;
			let duckModel = null;

			const NUM_DUCKS = 100;

			const simplex = new SimplexNoise();

			// TODO: Fix example with WebGL backend
			
			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			init();

			function noise( x, y ) {

				let multR = waterMaxHeight;
				let mult = 0.025;
				let r = 0;
				for ( let i = 0; i < 15; i ++ ) {

					r += multR * simplex.noise( x * mult, y * mult );
					multR *= 0.53 + 0.025 * i;
					mult *= 1.25;

				}

				return r;

			}

			async function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.set( 0, 2.00, 4 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				sun = new THREE.DirectionalLight( 0xFFFFFF, 4.0 );
 				sun.position.set( - 1, 2.6, 1.4 );
				scene.add( sun );

				//

				// Initialize height storage buffers
				const heightArray = new Float32Array( WIDTH * WIDTH );
				const prevHeightArray = new Float32Array( WIDTH * WIDTH );

				let p = 0;
				for ( let j = 0; j < WIDTH; j ++ ) {

					for ( let i = 0; i < WIDTH; i ++ ) {

						const x = i * 128 / WIDTH;
						const y = j * 128 / WIDTH;

						const height = noise( x, y );

						heightArray[ p ] = height;
						prevHeightArray[ p ] = height;

						p ++;

					}

				}

				const heightStorage = instancedArray( heightArray ).setName( 'Height' );
				const prevHeightStorage = instancedArray( prevHeightArray ).setName( 'PrevHeight' );

				// Get Indices of Neighbor Values of an Index in the Simulation Grid
				const getNeighborIndicesTSL = ( index ) => {

					const width = uint( WIDTH );

					// Get 2-D compute coordinate from one-dimensional instanceIndex. The calculation will
					// still work even if you dispatch your compute shader 2-dimensionally, since within a compute
					// context, instanceIndex is a 1-dimensional value derived from the workgroup dimensions.

					// Cast to int to prevent unintended index overflow upon subtraction.
					const x = int( index.mod( WIDTH ) );
					const y = int( index.div( WIDTH ) );

					// The original shader accesses height via texture uvs. However, unlike with textures, we can't
					// access areas that are out of bounds. Accordingly, we emulate the Clamp to Edge Wrapping
					// behavior of accessing a DataTexture with out of bounds uvs.

					const leftX = max( 0, x.sub( 1 ) );
					const rightX = min( x.add( 1 ), width.sub( 1 ) );

					const bottomY = max( 0, y.sub( 1 ) );
					const topY = min( y.add( 1 ), width.sub( 1 ) );

					const westIndex = y.mul( width ).add( leftX );
					const eastIndex = y.mul( width ).add( rightX );

					const southIndex = bottomY.mul( width ).add( x );
					const northIndex = topY.mul( width ).add( x );

					return { northIndex, southIndex, eastIndex, westIndex };

				};

				// Get simulation index neighbor values
				const getNeighborValuesTSL = ( index, store ) => {

					const { northIndex, southIndex, eastIndex, westIndex } = getNeighborIndicesTSL( index );

					const north = store.element( northIndex );
					const south = store.element( southIndex );
					const east = store.element( eastIndex );
					const west = store.element( westIndex );

					return { north, south, east, west };

				};

				// Get new normals of simulation area.
				const getNormalsFromHeightTSL = ( index, store ) => {

					const { north, south, east, west } = getNeighborValuesTSL( index, store );

					const normalX = ( west.sub( east ) ).mul( WIDTH / BOUNDS );
					const normalY = ( south.sub( north ) ).mul( WIDTH / BOUNDS );

					return { normalX, normalY };

				};

				computeHeight = Fn( () => {

					const { viscosity, mousePos, mouseSize, mouseDeep, mouseSpeed } = effectController;

					const height = heightStorage.element( instanceIndex ).toVar();
					const prevHeight = prevHeightStorage.element( instanceIndex ).toVar();

					const { north, south, east, west } = getNeighborValuesTSL( instanceIndex, heightStorage );

					const neighborHeight = north.add( south ).add( east ).add( west );
					neighborHeight.mulAssign( 0.5 );
					neighborHeight.subAssign( prevHeight );

					const newHeight = neighborHeight.mul( viscosity );

					// Get x and y position of the coordinate in the water plane

					const x = float( globalId.x ).mul( 1 / WIDTH );
					const y = float( globalId.y ).mul( 1 / WIDTH );

					// Mouse influence
					const centerVec = vec2( 0.5 );

					// Get length of position in range [ -BOUNDS / 2, BOUNDS / 2 ], offset by mousePos, then scale.
					const mousePhase = clamp( length( ( vec2( x, y ).sub( centerVec ) ).mul( BOUNDS ).sub( mousePos ) ).mul( Math.PI ).div( mouseSize ), 0.0, Math.PI );

					// "Indent" water down by scaled distance from center of mouse impact
					newHeight.addAssign( cos( mousePhase ).add( 1.0 ).mul( mouseDeep ).mul( mouseSpeed.length() ) );

					prevHeightStorage.element( instanceIndex ).assign( height );
					heightStorage.element( instanceIndex ).assign( newHeight );

				} )().compute( WIDTH * WIDTH, [ 16, 16 ] ).setName( 'Update Height' );

				// Water Geometry corresponds with buffered compute grid.
				const waterGeometry = new THREE.PlaneGeometry( BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1 );

				const waterMaterial = new THREE.MeshStandardNodeMaterial( {
					color: 0x9bd2ec,
 					metalness: 0.9,
 					roughness: 0,
 					transparent: true,
 					opacity: 0.8,
 					side: THREE.DoubleSide
				} );

				waterMaterial.normalNode = Fn( () => {

					// To correct the lighting as our mesh undulates, we have to reassign the normals in the normal shader.
					const { normalX, normalY } = getNormalsFromHeightTSL( vertexIndex, heightStorage );

					return transformNormalToView( vec3( normalX, normalY.negate(), 1.0 ) ).toVertexStage();

				} )();

				waterMaterial.positionNode = Fn( () => {

					return vec3( positionLocal.x, positionLocal.y, heightStorage.element( vertexIndex ) );

				} )();

				waterMesh = new THREE.Mesh( waterGeometry, waterMaterial );
				waterMesh.rotation.x = - Math.PI * 0.5;
				waterMesh.matrixAutoUpdate = false;
				waterMesh.updateMatrix();

				scene.add( waterMesh );

				// Pool border
				const borderGeom = new THREE.TorusGeometry( 4.2, 0.1, 12, 4 );
 				borderGeom.rotateX( Math.PI * 0.5 );
 				borderGeom.rotateY( Math.PI * 0.25 );
 				poolBorder = new THREE.Mesh( borderGeom, new THREE.MeshStandardMaterial( { color: 0x908877, roughness: 0.2 } ) );
 				scene.add( poolBorder );

				// THREE.Mesh just for mouse raycasting
				const geometryRay = new THREE.PlaneGeometry( BOUNDS, BOUNDS, 1, 1 );
				meshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );
				meshRay.rotation.x = - Math.PI / 2;
				meshRay.matrixAutoUpdate = false;
				meshRay.updateMatrix();
				scene.add( meshRay );

				// Initialize sphere mesh instance position and velocity.
				// position<vec3> + velocity<vec2> + unused<vec3> = 8 floats per sphere.
				// for structs arrays must be enclosed in multiple of 4

				const duckStride = 8;
				const duckInstanceDataArray = new Float32Array( NUM_DUCKS * duckStride );

				// Only hold velocity in x and z directions.
				// The sphere is wedded to the surface of the water, and will only move vertically with the water.

				for ( let i = 0; i < NUM_DUCKS; i ++ ) {

					duckInstanceDataArray[ i * duckStride + 0 ] = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					duckInstanceDataArray[ i * duckStride + 1 ] = 0;
					duckInstanceDataArray[ i * duckStride + 2 ] = ( Math.random() - 0.5 ) * BOUNDS * 0.7;

				}

				const DuckStruct = struct( {
					position: 'vec3',
					velocity: 'vec2'
				} );

				// Duck instance data storage

				const duckInstanceDataStorage = instancedArray( duckInstanceDataArray, DuckStruct ).setName( 'DuckInstanceData' );

				computeDucks = Fn( () => {

					const yOffset = float( - 0.04 );
					const verticalResponseFactor = float( 0.98 );
					const waterPushFactor = float( 0.015 );
					const linearDamping = float( 0.92 );
					const bounceDamping = float( - 0.4 );

					// Get 2-D compute coordinate from one-dimensional instanceIndex.
					const instancePosition = duckInstanceDataStorage.element( instanceIndex ).get( 'position' ).toVar();
					const velocity = duckInstanceDataStorage.element( instanceIndex ).get( 'velocity' ).toVar();

					const gridCoordX = instancePosition.x.div( BOUNDS ).add( 0.5 ).mul( WIDTH );
					const gridCoordZ = instancePosition.z.div( BOUNDS ).add( 0.5 ).mul( WIDTH );

					// Cast to int to prevent unintended index overflow upon subtraction.
					const xCoord = uint( clamp( floor( gridCoordX ), 0, WIDTH - 1 ) );
					const zCoord = uint( clamp( floor( gridCoordZ ), 0, WIDTH - 1 ) );
					const heightInstanceIndex = zCoord.mul( WIDTH ).add( xCoord );

					// Get height of water at the duck's position
					const waterHeight = heightStorage.element( heightInstanceIndex );
					const { normalX, normalY } = getNormalsFromHeightTSL( heightInstanceIndex, heightStorage );

					// Calculate the target Y position based on the water height and the duck's vertical offset
					const targetY = waterHeight.add( yOffset );

					const deltaY = targetY.sub( instancePosition.y );
					instancePosition.y.addAssign( deltaY.mul( verticalResponseFactor ) ); // Gradually update position

					// Get the normal of the water surface at the duck's position
					const pushX = normalX.mul( waterPushFactor );
					const pushZ = normalY.mul( waterPushFactor );

					// Apply the water push to the duck's velocity
					velocity.x.mulAssign( linearDamping );
					velocity.y.mulAssign( linearDamping );

					velocity.x.addAssign( pushX );
					velocity.y.addAssign( pushZ );

					// update position based on velocity
					instancePosition.x.addAssign( velocity.x );
					instancePosition.z.addAssign( velocity.y );

					// Clamp position to the pool bounds

					If( instancePosition.x.lessThan( - limit ), () => {

						instancePosition.x = - limit;
						velocity.x.mulAssign( bounceDamping );

					} ).ElseIf( instancePosition.x.greaterThan( limit ), () => {

						instancePosition.x = limit;
						velocity.x.mulAssign( bounceDamping );

					} );

					If( instancePosition.z.lessThan( - limit ), () => {

						instancePosition.z = - limit;
						velocity.y.mulAssign( bounceDamping ); // Invert and damp vz (velocity.y)

					} ).ElseIf( instancePosition.z.greaterThan( limit ), () => {

						instancePosition.z = limit;
						velocity.y.mulAssign( bounceDamping );

					} );

					// assignment of new values to the instance data storage

					duckInstanceDataStorage.element( instanceIndex ).get( 'position' ).assign( instancePosition );
					duckInstanceDataStorage.element( instanceIndex ).get( 'velocity' ).assign( velocity );

				} )().compute( NUM_DUCKS ).setName( 'Update Ducks' );

				// Models / Textures

				const hdrLoader = new HDRLoader().setPath( './textures/equirectangular/' );
 				const glbloader = new GLTFLoader().setPath( 'models/gltf/' );
 				glbloader.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) );

 				const [ env, model ] = await Promise.all( [ hdrLoader.loadAsync( 'blouberg_sunrise_2_1k.hdr' ), glbloader.loadAsync( 'duck.glb' ) ] );
 				env.mapping = THREE.EquirectangularReflectionMapping;
 				scene.environment = env;
 				scene.background = env;
 				scene.backgroundBlurriness = 0.3;
 				scene.environmentIntensity = 1.25;

				duckModel = model.scene.children[ 0 ];
				duckModel.material.positionNode = Fn( () => {

					const instancePosition = duckInstanceDataStorage.element( instanceIndex ).get( 'position' );

					const newPosition = positionLocal.add( instancePosition );

					return newPosition;

				} )();

				const duckMesh = new THREE.InstancedMesh( duckModel.geometry, duckModel.material, NUM_DUCKS );
				scene.add( duckMesh );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.inspector.domElement );

				controls = new OrbitControls( camera, container );

				container.style.touchAction = 'none';

				//

				container.style.touchAction = 'none';
				container.addEventListener( 'pointermove', onPointerMove );
				container.addEventListener( 'pointerdown', onPointerDown );
				container.addEventListener( 'pointerup', onPointerUp );

				window.addEventListener( 'resize', onWindowResize );

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( effectController.mouseSize, 'value', 0.1, .3 ).name( 'Mouse Size' );
				gui.add( effectController.mouseDeep, 'value', 0.1, 1 ).name( 'Mouse Deep' );
				gui.add( effectController.viscosity, 'value', 0.9, 0.96, 0.001 ).name( 'viscosity' );
				gui.add( effectController, 'speed', 1, 6, 1 );
				gui.add( effectController, 'ducksEnabled' ).onChange( () => {

					duckMesh.visible = effectController.ducksEnabled;

				} );
				gui.add( effectController, 'wireframe' ).onChange( () => {

					waterMesh.material.wireframe = ! waterMesh.material.wireframe;
					poolBorder.material.wireframe = ! poolBorder.material.wireframe;
					duckModel.material.wireframe = ! duckModel.material.wireframe;
					waterMesh.material.needsUpdate = true;
					poolBorder.material.needsUpdate = true;

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function setMouseCoords( x, y ) {

				mouseCoords.set( ( x / renderer.domElement.clientWidth ) * 2 - 1, - ( y / renderer.domElement.clientHeight ) * 2 + 1 );

			}

			function onPointerDown() {

				mouseDown = true;
				firstClick = true;
				updateOriginMouseDown = true;

			}

			function onPointerUp() {

				mouseDown = false;
				firstClick = false;
				updateOriginMouseDown = false;

				controls.enabled = true;

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				setMouseCoords( event.clientX, event.clientY );

			}

			function raycast() {

				if ( mouseDown && ( firstClick || ! controls.enabled ) ) {

					raycaster.setFromCamera( mouseCoords, camera );

					const intersects = raycaster.intersectObject( meshRay );

					if ( intersects.length > 0 ) {

						const point = intersects[ 0 ].point;

						if ( updateOriginMouseDown ) {

							effectController.mousePos.value.set( point.x, point.z );

							updateOriginMouseDown = false;

						}

						effectController.mouseSpeed.value.set(
							( point.x - effectController.mousePos.value.x ),
							( point.z - effectController.mousePos.value.y )
						);

						effectController.mousePos.value.set( point.x, point.z );

						if ( firstClick ) {

							controls.enabled = false;

						}

					} else {

						updateOriginMouseDown = true;

						effectController.mouseSpeed.value.set( 0, 0 );

					}

					firstClick = false;

				} else {

					updateOriginMouseDown = true;

					effectController.mouseSpeed.value.set( 0, 0 );

				}

			}

			function render() {

				raycast();

				frame ++;

				if ( frame >= 7 - effectController.speed ) {

					renderer.compute( computeHeight, [ 8, 8, 1 ] );

					if ( effectController.ducksEnabled ) {

						renderer.compute( computeDucks );

					}

					frame = 0;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_cubemap_adjustments.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - envmap adjustments</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>EnvMap Adjustments</span>
			</div>

			<small>
				Adjust/modify the scene's background and environment.<br/>
				Battle Damaged Sci-fi Helmet by <a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { uniform, mix, pmremTexture, reference, positionLocal, hue, saturation, positionWorld, normalWorld, positionWorldDirection, reflectVector } from 'three/tsl';

			import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				const initialDistance = 2;

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8 * initialDistance, 0.6 * initialDistance, 2.7 * initialDistance );

				scene = new THREE.Scene();

				// cube textures

				const hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];
				const cube1Texture = await new HDRCubeTextureLoader()
					.setPath( './textures/cube/pisaHDR/' )
					.loadAsync( hdrUrls );

				cube1Texture.generateMipmaps = true;
				cube1Texture.minFilter = THREE.LinearMipmapLinearFilter;

				const cube2Urls = [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ];
				const cube2Texture = await new THREE.CubeTextureLoader()
					.setPath( './textures/cube/Park2/' )
					.loadAsync( cube2Urls );

				cube2Texture.generateMipmaps = true;
				cube2Texture.minFilter = THREE.LinearMipmapLinearFilter;

				// nodes and environment

				const adjustments = {
					mix: 0,
					procedural: 0,
					intensity: 1,
					hue: 0,
					saturation: 1
				};

				const mixNode = reference( 'mix', 'float', adjustments );
				const proceduralNode = reference( 'procedural', 'float', adjustments );
				const intensityNode = reference( 'intensity', 'float', adjustments );
				const hueNode = reference( 'hue', 'float', adjustments );
				const saturationNode = reference( 'saturation', 'float', adjustments );

				const rotateY1Matrix = new THREE.Matrix4();
				const rotateY2Matrix = new THREE.Matrix4();

				const getEnvironmentNode = ( reflectNode, positionNode ) => {

					const custom1UV = reflectNode.xyz.mul( uniform( rotateY1Matrix ) );
					const custom2UV = reflectNode.xyz.mul( uniform( rotateY2Matrix ) );
					const mixCubeMaps = mix( pmremTexture( cube1Texture, custom1UV ), pmremTexture( cube2Texture, custom2UV ), positionNode.y.add( mixNode ).clamp() );

					const proceduralEnv = mix( mixCubeMaps, normalWorld, proceduralNode );

					const intensityFilter = proceduralEnv.mul( intensityNode );
					const hueFilter = hue( intensityFilter, hueNode );
					return saturation( hueFilter, saturationNode );

				};

				const blurNode = uniform( 0 );

				scene.environmentNode = getEnvironmentNode( reflectVector, positionWorld );

				scene.backgroundNode = getEnvironmentNode( positionWorldDirection, positionLocal ).context( {
					getTextureLevel: () => blurNode
				} );

				// scene objects

				const loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
				const gltf = await loader.loadAsync( 'DamagedHelmet.gltf' );

				scene.add( gltf.scene );

				const sphereGeometry = new THREE.SphereGeometry( .5, 64, 32 );

				const sphereRightView = new THREE.Mesh( sphereGeometry, new THREE.MeshStandardMaterial( { roughness: 0, metalness: 1 } ) );
				sphereRightView.position.x += 2;

				const sphereLeftView = new THREE.Mesh( sphereGeometry, new THREE.MeshStandardMaterial( { roughness: 1, metalness: 1 } ) );
				sphereLeftView.position.x -= 2;

				scene.add( sphereLeftView );
				scene.add( sphereRightView );

				// renderer and controls

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.inspector = new Inspector();
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( { blurBackground: blurNode.value }, 'blurBackground', 0, 1, 0.01 ).onChange( value => {

					blurNode.value = value;

				} );
				gui.add( { offsetCube1: 0 }, 'offsetCube1', 0, Math.PI * 2, 0.01 ).onChange( value => {

					rotateY1Matrix.makeRotationY( value );

				} );
				gui.add( { offsetCube2: 0 }, 'offsetCube2', 0, Math.PI * 2, 0.01 ).onChange( value => {

					rotateY2Matrix.makeRotationY( value );

				} );
				gui.add( adjustments, 'mix', - 1, 2, 0.01 );
				gui.add( adjustments, 'procedural', 0, 1, 0.01 );
				gui.add( adjustments, 'intensity', 0, 5, 0.01 );
				gui.add( adjustments, 'hue', 0, Math.PI * 2, 0.01 );
				gui.add( adjustments, 'saturation', 0, 2, 0.01 );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_cubemap_dynamic.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - dynamic cube reflection</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			body {
				touch-action: none;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Dynamic Cube Reflections</span>
			</div>

			<small>
				Realtime reflections rendered with a cube camera.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let cube, sphere, torus, material;

			let cubeCamera, cubeRenderTarget;

			let controls;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 75;

				scene = new THREE.Scene();

				const uvTexture = new THREE.TextureLoader().load( './textures/uv_grid_opengl.jpg' );

				const hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];
				const texture = await new HDRCubeTextureLoader()
					.setPath( './textures/cube/pisaHDR/' )
					.loadAsync( hdrUrls );

				texture.name = 'pisaHDR';
				texture.minFilter = THREE.LinearMipmapLinearFilter;
				texture.magFilter = THREE.LinearFilter;

				scene.background = texture;
				scene.environment = texture;

				//

				cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );
				cubeRenderTarget.texture.type = THREE.HalfFloatType;
				cubeRenderTarget.texture.minFilter = THREE.LinearMipmapLinearFilter;
				cubeRenderTarget.texture.magFilter = THREE.LinearFilter;
				cubeRenderTarget.texture.generateMipmaps = true;

				cubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );

				//

				material = new THREE.MeshStandardNodeMaterial( {
					envMap: cubeRenderTarget.texture,
					roughness: 0.05,
					metalness: 1
				} );

				sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 15, 8 ), material );
				scene.add( sphere );

				const material1 = new THREE.MeshStandardNodeMaterial( {
					map: uvTexture,
					roughness: 0.1,
					metalness: 0,
				} );

				const material2 = new THREE.MeshStandardNodeMaterial( {
					map: uvTexture,
					roughness: 0.1,
					metalness: 0,
					envMap: texture,
				} );

				cube = new THREE.Mesh( new THREE.BoxGeometry( 15, 15, 15 ), material1 );
				scene.add( cube );

				torus = new THREE.Mesh( new THREE.TorusKnotGeometry( 8, 3, 128, 16 ), material2 );
				scene.add( torus );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animation );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResized );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.autoRotate = true;

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( material, 'roughness', 0, 1 );
				gui.add( material, 'metalness', 0, 1 );
				gui.add( renderer, 'toneMappingExposure', 0, 2 ).name( 'exposure' );
				gui.add( scene, 'environmentIntensity', 0, 1 );
				gui.add( material2, 'envMapIntensity', 0, 1 );

			}

			function onWindowResized() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

			}

			function animation( msTime ) {

				const time = msTime / 1000;

				cube.position.x = Math.cos( time ) * 30;
				cube.position.y = Math.sin( time ) * 30;
				cube.position.z = Math.sin( time ) * 30;

				cube.rotation.x += 0.02;
				cube.rotation.y += 0.03;

				torus.position.x = Math.cos( time + 10 ) * 30;
				torus.position.y = Math.sin( time + 10 ) * 30;
				torus.position.z = Math.sin( time + 10 ) * 30;

				torus.rotation.x += 0.02;
				torus.rotation.y += 0.03;

				material.visible = false;

				cubeCamera.update( renderer, scene );

				material.visible = true;

				controls.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_cubemap_mix.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - cubemap mix</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Cubemap Mix</span>
			</div>

			<small>
				Mixing two cube maps.<br/>
				Battle Damaged Sci-fi Helmet by <a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a>
			</small>
		</div>
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mix, oscSine, time, pmremTexture, float } from 'three/tsl';

			import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, 0.6, 2.7 );

				scene = new THREE.Scene();

				const hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];
				const cube1Texture = new HDRCubeTextureLoader()
					.setPath( './textures/cube/pisaHDR/' )
					.load( hdrUrls );

				cube1Texture.generateMipmaps = true;
				cube1Texture.minFilter = THREE.LinearMipmapLinearFilter;

				const cube2Urls = [ 'dark-s_px.jpg', 'dark-s_nx.jpg', 'dark-s_py.jpg', 'dark-s_ny.jpg', 'dark-s_pz.jpg', 'dark-s_nz.jpg' ];
				const cube2Texture = await new THREE.CubeTextureLoader()
					.setPath( './textures/cube/MilkyWay/' )
					.loadAsync( cube2Urls );

				cube2Texture.generateMipmaps = true;
				cube2Texture.minFilter = THREE.LinearMipmapLinearFilter;

				scene.environmentNode = mix( pmremTexture( cube2Texture ), pmremTexture( cube1Texture ), oscSine( time.mul( .1 ) ) );

				scene.backgroundNode = scene.environmentNode.context( {
					getTextureLevel: () => float( .5 )
				} );

				const loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
				const gltf = await loader.loadAsync( 'DamagedHelmet.gltf' );

				scene.add( gltf.scene );

				renderer = new THREE.WebGPURenderer( { antialias: true } );

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.inspector = new Inspector();
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_custom_fog.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - custom fog</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Custom Fog</span>
			</div>

			<small>
				Custom Fog via TSL.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, fog, float, positionWorld, triNoise3D, positionView, normalWorld, uniform } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 600 );
				camera.position.set( 30, 15, 30 );

				scene = new THREE.Scene();

				// custom fog

				const skyColor = color( 0xf0f5f5 );
				const groundColor = color( 0xd0dee7 );

				const fogNoiseDistance = positionView.z.negate().smoothstep( 0, camera.far - 300 );

				const distance = fogNoiseDistance.mul( 20 ).max( 4 );
				const alpha = .98;
				const groundFogArea = float( distance ).sub( positionWorld.y ).div( distance ).pow( 3 ).saturate().mul( alpha );

				// a alternative way to create a TimerNode
				const timer = uniform( 0 ).onFrameUpdate( ( frame ) => frame.time );

				const fogNoiseA = triNoise3D( positionWorld.mul( .005 ), 0.2, timer );
				const fogNoiseB = triNoise3D( positionWorld.mul( .01 ), 0.2, timer.mul( 1.2 ) );

				const fogNoise = fogNoiseA.add( fogNoiseB ).mul( groundColor );

				// apply custom fog

				scene.fogNode = fog( fogNoiseDistance.oneMinus().mix( groundColor, fogNoise ), groundFogArea );
				scene.backgroundNode = normalWorld.y.max( 0 ).mix( groundColor, skyColor );

				// builds

				const buildWindows = positionWorld.y.mul( 10 ).floor().mod( 4 ).sign().mix( color( 0x000066 ).add( fogNoiseDistance ), color( 0xffffff ) );

				const buildGeometry = new THREE.BoxGeometry( 1, 1, 1 );
				const buildMaterial = new THREE.MeshPhongNodeMaterial( {
					colorNode: buildWindows
				} );

				const buildMesh = new THREE.InstancedMesh( buildGeometry, buildMaterial, 4000 );
				scene.add( buildMesh );

				const dummy = new THREE.Object3D();
				const center = new THREE.Vector3();

				for ( let i = 0; i < buildMesh.count; i ++ ) {

					const scaleY = Math.random() * 7 + .5;

					dummy.position.x = Math.random() * 600 - 300;
					dummy.position.z = Math.random() * 600 - 300;

					const distance = Math.max( dummy.position.distanceTo( center ) * .012, 1 );

					dummy.position.y = .5 * scaleY * distance;

					dummy.scale.x = dummy.scale.z = Math.random() * 3 + .5;
					dummy.scale.y = scaleY * distance;

					dummy.updateMatrix();

					buildMesh.setMatrixAt( i, dummy.matrix );

				}

				// lights

				scene.add( new THREE.HemisphereLight( skyColor.value, groundColor.value, 0.5 ) );

				// geometry

				const planeGeometry = new THREE.PlaneGeometry( 200, 200 );
				const planeMaterial = new THREE.MeshPhongMaterial( {
					color: 0x999999
				} );

				const ground = new THREE.Mesh( planeGeometry, planeMaterial );
				ground.rotation.x = - Math.PI / 2;
				ground.scale.multiplyScalar( 3 );
				ground.castShadow = true;
				ground.receiveShadow = true;
				scene.add( ground );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 2, 0 );
				controls.minDistance = 7;
				controls.maxDistance = 100;
				controls.maxPolarAngle = Math.PI / 2;
				controls.autoRotate = true;
				controls.autoRotateSpeed = .1;
				controls.update();

				window.addEventListener( 'resize', resize );

			}

			function resize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_custom_fog_background.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - custom fog background</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Custom Fog Background</span>
			</div>

			<small>
				Custom Fog Background via Post-Processing.<br/>
				Battle Damaged Sci-fi Helmet by <a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a>.
				<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> by <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, color, rangeFogFactor } from 'three/tsl';

			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;
			let postProcessing;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, 0.6, 2.7 );

				scene = new THREE.Scene();

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NoToneMapping; // apply tone mapping in post processing, instead
				document.body.appendChild( renderer.domElement );

				// post processing

				// render scene pass
				const scenePass = pass( scene, camera );
				const scenePassViewZ = scenePass.getViewZNode();

				// fog color
				const fogColor = color( 0x4080cc ); // in sRGB color space

				// get fog factor from the scene pass context
				// equivalent to: scene.fog = new THREE.Fog( 0x4080cc, 2.7, 4 );
				const fogFactor = rangeFogFactor( 2.7, 4 ).context( { getViewZ: () => scenePassViewZ } );

				// tone-mapped scene pass
				const scenePassTM = scenePass.toneMapping( THREE.ACESFilmicToneMapping, 1 );

				// mix fog using fog factor and fog color
				const compose = fogFactor.mix( scenePassTM, fogColor );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputColorTransform = true; // no tone mapping will be applied, only the default color space transform
				postProcessing.outputNode = compose;

				//

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;
						scene.environment = texture;

						// model

						const loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
						loader.load( 'DamagedHelmet.gltf', function ( gltf ) {

							scene.add( gltf.scene );

						} );

					} );

				//

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 5;
				controls.target.set( 0, - 0.1, - 0.2 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_depth_texture.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - depth texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Depth Texture</span>
			</div>

			<small>Rendering the scene's depth into a texture for later use</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, controls, renderer;

			let quad, renderTarget;

			const dpr = window.devicePixelRatio;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 20 );
				camera.position.z = 4;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );
				scene.overrideMaterial = new THREE.MeshBasicNodeMaterial();

				//

				const geometry = new THREE.TorusKnotGeometry( 1, 0.3, 128, 64 );

				const count = 50;
				const scale = 5;

				for ( let i = 0; i < count; i ++ ) {

					const r = Math.random() * 2.0 * Math.PI;
					const z = ( Math.random() * 2.0 ) - 1.0;
					const zScale = Math.sqrt( 1.0 - z * z ) * scale;

					const mesh = new THREE.Mesh( geometry );
					mesh.position.set(
						Math.cos( r ) * zScale,
						Math.sin( r ) * zScale,
						z * scale
					);
					mesh.rotation.set( Math.random(), Math.random(), Math.random() );
					scene.add( mesh );

				}

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( dpr );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				const depthTexture = new THREE.DepthTexture();
				depthTexture.type = THREE.FloatType;

				renderTarget = new THREE.RenderTarget( window.innerWidth * dpr, window.innerHeight * dpr );
				renderTarget.depthTexture = depthTexture;

				window.addEventListener( 'resize', onWindowResize );

				// FX

				const materialFX = new THREE.MeshBasicNodeMaterial();
				materialFX.colorNode = texture( depthTexture );

				quad = new THREE.QuadMesh( materialFX );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				renderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );

			}

			function animate() {

				renderer.setRenderTarget( renderTarget );
				renderer.render( scene, camera );

				renderer.setRenderTarget( null );
				quad.render( renderer );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_display_stereo.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - stereo effects</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Stereo Effects</span>
			</div>

			<small>
				Collection of Stereo, Anaglyph and Parallax Barrier effects.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { stereoPass } from 'three/addons/tsl/display/StereoPassNode.js';
			import { anaglyphPass } from 'three/addons/tsl/display/AnaglyphPassNode.js';
			import { parallaxBarrierPass } from 'three/addons/tsl/display/ParallaxBarrierPassNode.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, postProcessing;

			let stereo, anaglyph, parallaxBarrier;

			let mesh, dummy, timer;

			const position = new THREE.Vector3();

			const params = {
				effect: 'stereo',
				eyeSep: 0.064,
			};

			const effects = { Stereo: 'stereo', Anaglyph: 'anaglyph', ParallaxBarrier: 'parallaxBarrier' };

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.z = 3;

				scene = new THREE.Scene();
				scene.background = new THREE.CubeTextureLoader()
					.setPath( 'textures/cube/Park3Med/' )
					.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );

				timer = new THREE.Timer();
				timer.connect( document );

				const geometry = new THREE.SphereGeometry( 0.1, 32, 16 );

				const textureCube = new THREE.CubeTextureLoader()
					.setPath( 'textures/cube/Park3Med/' )
					.load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );

				const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );

				mesh = new THREE.InstancedMesh( geometry, material, 500 );
				mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
			
				dummy = new THREE.Mesh();

				for ( let i = 0; i < 500; i ++ ) {

					dummy.position.x = Math.random() * 10 - 5;
					dummy.position.y = Math.random() * 10 - 5;
					dummy.position.z = Math.random() * 10 - 5;
					dummy.scale.x = dummy.scale.y = dummy.scale.z = Math.random() * 3 + 1;
			
					dummy.updateMatrix();

					mesh.setMatrixAt( i, dummy.matrix );

				}

				scene.add( mesh );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				postProcessing = new THREE.PostProcessing( renderer );
				stereo = stereoPass( scene, camera );
				anaglyph = anaglyphPass( scene, camera );
				parallaxBarrier = parallaxBarrierPass( scene, camera );

				postProcessing.outputNode = stereo;

				const gui = renderer.inspector.createParameters( 'Stereo Settings' );
				gui.add( params, 'effect', effects ).onChange( update );
				gui.add( params, 'eyeSep', 0.001, 0.15, 0.001 ).onChange( function ( value ) {

					stereo.stereo.eyeSep = value;

					anaglyph.stereo.eyeSep = value;
					parallaxBarrier.stereo.eyeSep = value;

				} );

				window.addEventListener( 'resize', onWindowResize );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 25;

			}

			function update( value ) {

				if ( value === 'stereo' ) {

					postProcessing.outputNode = stereo;

				} else if ( value === 'anaglyph' ) {

					postProcessing.outputNode = anaglyph;

				} else if ( value === 'parallaxBarrier' ) {

					postProcessing.outputNode = parallaxBarrier;

				}

				postProcessing.needsUpdate = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function extractPosition( matrix, position ) {

				position.x = matrix.elements[ 12 ];
				position.y = matrix.elements[ 13 ];
				position.z = matrix.elements[ 14 ];

			}

			function animate() {

				timer.update();

				const elapsedTime = timer.getElapsed() * 0.1;

				for ( let i = 0; i < mesh.count; i ++ ) {

					mesh.getMatrixAt( i, dummy.matrix );

					extractPosition( dummy.matrix, position );

					position.x = 5 * Math.cos( elapsedTime + i );
					position.y = 5 * Math.sin( elapsedTime + i * 1.1 );

					dummy.matrix.setPosition( position );

					mesh.setMatrixAt( i, dummy.matrix );

					mesh.instanceMatrix.needsUpdate = true;

				}

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_equirectangular.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - equirectangular</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Equirectangular Panorama</span>
			</div>

			<small>
				Photo by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank" rel="noopener">Jón Ragnarsson</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, equirectUV } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let controls;

			init();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 1, 0, 0 );

				const equirectTexture = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );
				equirectTexture.colorSpace = THREE.SRGBColorSpace;

				scene = new THREE.Scene();
				scene.backgroundNode = texture( equirectTexture, equirectUV(), 0 );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.autoRotate = true;
				controls.rotateSpeed = - 0.125; // negative, to track mouse pointer
				controls.autoRotateSpeed = 1.0;

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( scene, 'backgroundIntensity', 0, 1 ).name( 'background intensity' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_hdr.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
	<title>three.js webgpu - HDR Draw</title>
	<link type="text/css" rel="stylesheet" href="example.css">
	<style>
		body {
			background-color: #fff;
		}
		#no-hdr {
			position: absolute;
			font-family: monospace;
			font-size: 11px;
			font-weight: normal;
			text-align: center;
			background: #000;
			color: #fff;
			left: 50%;
			transform: translateX(-50%);
			padding: 1.5em;
			max-width: 600px;
			margin: 5em auto 0;
		}
	</style>
	</head>
	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>HDR</span>
			</div>

			<small>
				The demo produces a color output intended for HDR monitors.
			</small>
		</div>

		<div id="no-hdr" style="display: none">
			<div>
			The browser says your device or monitor doesn't support HDR.<br />
			If you're on a laptop using an external monitor, try the built in
			monitor<br />
			or, try this site on your phone. Most phones support HDR.
			</div>
		</div>

		<script type="importmap">
			{
				"imports": {
				"three": "../build/three.webgpu.js",
				"three/webgpu": "../build/three.webgpu.js",
				"three/tsl": "../build/three.tsl.js",
				"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, uv, uniform } from 'three/tsl';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import { afterImage } from 'three/addons/tsl/display/AfterImageNode.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { ExtendedSRGBColorSpace, ExtendedSRGBColorSpaceImpl } from 'three/addons/math/ColorSpaces.js';

			const params = {
				intensity: uniform( 4.0, 'float' ).setName( 'intensity' ),
				hardness: uniform( 0.4, 'float' ).setName( 'hardness' ),
				radius: uniform( 0.5, 'float' ).setName( 'radius' ),
				afterImageDecay: uniform( 0.985, 'float' ).setName( 'afterImageDecay' ),
			};

			const hdrMediaQuery = window.matchMedia( '(dynamic-range: high)' );

			function updateHDRWarning() {

				const displayIsHDR = hdrMediaQuery.matches;
				document.querySelector( '#no-hdr' ).style.display = displayIsHDR ? 'none' : '';

			}

			hdrMediaQuery.addEventListener( 'change', updateHDRWarning );
			updateHDRWarning();

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );
				throw new Error( 'No WebGPU support' );

			}

			// Enable Extended sRGB output color space for HDR presentation
			THREE.ColorManagement.define( { [ ExtendedSRGBColorSpace ]: ExtendedSRGBColorSpaceImpl } );

			// Renderer (HalfFloat output + Extended sRGB)
			const renderer = new THREE.WebGPURenderer( {
				antialias: true,
				outputType: THREE.HalfFloatType,
			} );

			renderer.outputColorSpace = ExtendedSRGBColorSpace;
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.inspector = new Inspector();
			document.body.appendChild( renderer.domElement );

			const camera = new THREE.OrthographicCamera( 0, window.innerWidth, window.innerHeight, 0, 1, 2 );
			camera.position.z = 1;

			// Brush scene (rendered into drawTarget)
			const brushScene = new THREE.Scene();

			brushScene.background = new THREE.Color( 0xffffff );
			const brushMat = new THREE.MeshBasicNodeMaterial();
			brushMat.transparent = true;
			brushMat.depthTest = false;
			brushMat.depthWrite = false;
			brushMat.blending = THREE.AdditiveBlending; // additive to build HDR energy

			const postProcessing = new THREE.PostProcessing( renderer );
			const brushPass = pass( brushScene, camera, { type: THREE.HalfFloatType } );
			brushPass.renderTarget.texture.colorSpace = ExtendedSRGBColorSpace;

			postProcessing.outputNode = afterImage( brushPass, params.afterImageDecay );

			// HDR brush uniforms
			const uColor = params.intensity;
			const uHard = params.hardness;
			const uRadius = params.radius;

			// Radial falloff in TSL
			const d = uv().sub( 0.5 ).length();
			const t = d.div( uRadius );
			const a = t.clamp().oneMinus().pow( uHard.mul( 8.0 ).add( 1.0 ) );

			brushMat.colorNode = uColor.mul( a );
			brushMat.opacityNode = a; // premultiplied style with additive blending

			const brushMesh = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), brushMat );
			brushMesh.scale.set( 300, 300, 1 ); // ~300px default brush size
			brushScene.add( brushMesh );

			function onPointerMove( e ) {

				const rect = renderer.domElement.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const y = e.clientY - rect.top;

				// camera has origin at bottom-left (0,0)
				brushMesh.position.set( x, window.innerHeight - y, 0 );

			}

			window.addEventListener( 'pointermove', onPointerMove, { passive: false } );

			// Prevent mobile scroll on touch
			renderer.domElement.addEventListener( 'touchstart', ( e ) => e.preventDefault(), { passive: false } );
			renderer.domElement.addEventListener( 'touchmove', ( e ) => e.preventDefault(), { passive: false } );
			renderer.domElement.addEventListener( 'touchend', ( e ) => e.preventDefault(), { passive: false } );

			// GUI setup
			const gui = renderer.inspector.createParameters( 'Settings' );

			const colorFolder = gui.addFolder( 'HDR' );
			colorFolder.add( params.intensity, 'value', 0, 10, 0.1 ).name( 'Intensity' );

			const brushFolder = gui.addFolder( 'Brush Settings' );
			brushFolder.add( params.hardness, 'value', 0, 0.99, 0.01 ).name( 'Hardness' );
			brushFolder.add( params.radius, 'value', 0.1, 2.0, 0.01 ).name( 'Radius' );

			const effectFolder = gui.addFolder( 'Effects' );
			effectFolder.add( params.afterImageDecay, 'value', 0.9, 0.999, 0.001 ).name( 'After Image Decay' );

			// Resize handling
			function onResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.right = window.innerWidth;
				camera.top = window.innerHeight;
				camera.updateProjectionMatrix();


			}

			window.addEventListener( 'resize', onResize );

			// Main loop
			renderer.setAnimationLoop( async () => {

				postProcessing.render();

			} );

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_instance_mesh.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - instance mesh</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Instancing</span>
			</div>

			<small>
				Instanced rendering via InstancedMesh.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mix, range, normalWorld, oscSine, time } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			let mesh;
			const amount = parseInt( window.location.search.slice( 1 ) ) || 10;
			const count = Math.pow( amount, 3 );
			const dummy = new THREE.Object3D();

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( amount * 0.9, amount * 0.9, amount * 0.9 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				const material = new THREE.MeshBasicMaterial();

				// random colors between instances from 0x000000 to 0xFFFFFF
				const randomColors = range( new THREE.Color( 0x000000 ), new THREE.Color( 0xFFFFFF ) );

				material.colorNode = mix( normalWorld, randomColors, oscSine( time.mul( .1 ) ) );

				const loader = new THREE.BufferGeometryLoader();
				loader.load( 'models/json/suzanne_buffergeometry.json', function ( geometry ) {

					geometry.computeVertexNormals();
					geometry.scale( 0.5, 0.5, 0.5 );

					mesh = new THREE.InstancedMesh( geometry, material, count );
					mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );

					scene.add( mesh );

					//

					const gui = renderer.inspector.createParameters( 'Settings' );
					gui.add( mesh, 'count', 1, count, 1 ).name( 'instance count' );

				} );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				render();

			}

			async function render() {

				if ( mesh ) {

					const time = Date.now() * 0.001;

					mesh.rotation.x = Math.sin( time / 4 );
					mesh.rotation.y = Math.sin( time / 2 );

					let i = 0;
					const offset = ( amount - 1 ) / 2;

					for ( let x = 0; x < amount; x ++ ) {

						for ( let y = 0; y < amount; y ++ ) {

							for ( let z = 0; z < amount; z ++ ) {

								dummy.position.set( offset - x, offset - y, offset - z );
								dummy.rotation.y = ( Math.sin( x / 4 + time ) + Math.sin( y / 4 + time ) + Math.sin( z / 4 + time ) );
								dummy.rotation.z = dummy.rotation.y * 2;

								dummy.updateMatrix();

								mesh.setMatrixAt( i ++, dummy.matrix );

							}

						}

					}

				}

				await renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_instance_path.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - instance path</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Instance Path</span>
			</div>

			<small>
				Rendering and animating instances along a path.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { abs, add, instancedBufferAttribute, positionLocal, mod, time, sin, vec3, select, float, screenUV, color } from 'three/tsl';

			let camera, scene, renderer, controls;

			const count = 1000;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.z = 15;

				scene = new THREE.Scene();
				scene.backgroundNode = screenUV.distance( .5 ).remap( 0, 0.65 ).mix( color( 0x94254c ), color( 0x000000 ) );

				// generate a path representing a heart shape

				const x = 0, y = 0;

				const path = new THREE.Path()
					.moveTo( x - 2.5, y - 2.5 )
					.bezierCurveTo( x - 2.5, y - 2.5, x - 2, y, x, y )
					.bezierCurveTo( x + 3, y, x + 3, y - 3.5, x + 3, y - 3.5 )
					.bezierCurveTo( x + 3, y - 5.5, x + 1, y - 7.7, x - 2.5, y - 9.5 )
					.bezierCurveTo( x - 6, y - 7.7, x - 8, y - 5.5, x - 8, y - 3.5 )
					.bezierCurveTo( x - 8, y - 3.5, x - 8, y, x - 5, y )
					.bezierCurveTo( x - 3.5, y, x - 2.5, y - 2.5, x - 2.5, y - 2.5 );

				// generate instanced ico-spheres along the path
			
				const geometry = new THREE.IcosahedronGeometry( 0.1 );
				const material = new THREE.MeshStandardNodeMaterial();

				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( 2.5, 5, 0 );
				mesh.count = count;
				mesh.frustumCulled = false;

				scene.add( mesh );

				// instance data

				const v = new THREE.Vector3();
				const c = new THREE.Color();

				const positions = [];
				const times = [];
				const seeds = [];
				const colors = [];

				for ( let i = 0; i < count; i ++ ) {

					const t = i / count;
					path.getPointAt( t, v );

					v.x += ( 0.5 - Math.random() );
					v.y += ( 0.5 - Math.random() );
					v.z = ( 0.5 - Math.random() );

					positions.push( v.x, v.y, v.z );
					times.push( t );
					seeds.push( Math.random() );

					c.setHSL( 0.75 + ( Math.random() * 0.25 ), 1, 0.4 );

					colors.push( c.r, c.g, c.b );

				}

				const positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );
				const colorAttribute = new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 );
				const timeAttribute = new THREE.InstancedBufferAttribute( new Float32Array( times ), 1 );
				const seedAttribute = new THREE.InstancedBufferAttribute( new Float32Array( seeds ), 1 );

				// TSL

				const instancePosition = instancedBufferAttribute( positionAttribute );
				const instanceColor = instancedBufferAttribute( colorAttribute );
				const instanceSeed = instancedBufferAttribute( seedAttribute );
				const instanceTime = instancedBufferAttribute( timeAttribute );

				const localTime = instanceTime.add( time );
				const modTime = mod( time.mul( 0.4 ), 1 );
			
				const s0 = sin( localTime.add( instanceSeed ) ).mul( 0.25 );
			
				const dist = abs( instanceTime.sub( modTime ) ).toConst(); // modTime and instanceTime are in the range [0,1]
				const wrapDist = select( dist.greaterThan( 0.5 ), dist.oneMinus(), dist ).toConst(); // the normalized distance should wrap around 0/1
				const s1 = select( wrapDist.greaterThan( 0.1 ), float( 1 ), wrapDist.remap( 0, 0.1, 3, 1 ) ); // compute a scale in a range around the current interpolated value
			
				const offset = vec3( instancePosition.x, instancePosition.y.add( s0 ), instancePosition.z ).toConst( 'offset' );
				material.positionNode = add( positionLocal.mul( s1 ), offset );
				material.colorNode = instanceColor;
			
				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_instance_points.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - points instanced</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Instanced Points</span>
			</div>

			<small>
				Rendering instanced sprites with TSL to emulate wide points.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, storage, Fn, instancedBufferAttribute, instanceIndex, sin, time, float, uniform, shapeCircle, mix, vec3 } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';

			let renderer, scene, camera, camera2, controls, backgroundNode;
			let material;
			let effectController;

			// viewport
			let insetWidth;
			let insetHeight;

			// compute
			let computeSize;

			init();

			async function init() {

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( - 40, 0, 60 );

				camera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );
				camera2.position.copy( camera.position );

				backgroundNode = color( 0x222222 );

				effectController = {

					pulseSpeed: uniform( 6 ),
					minWidth: uniform( 6 ),
					maxWidth: uniform( 20 )

				};

				// Position and THREE.Color Data

				const points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );

				const spline = new THREE.CatmullRomCurve3( points );
				const divisions = Math.round( 4 * points.length );
				const point = new THREE.Vector3();
				const pointColor = new THREE.Color();

				const positions = [];
				const colors = [];
				const sizes = new Float32Array( divisions );

				for ( let i = 0, l = divisions; i < l; i ++ ) {

					const t = i / l;

					spline.getPoint( t, point );
					positions.push( point.x, point.y, point.z );

					pointColor.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );
					colors.push( pointColor.r, pointColor.g, pointColor.b );

					sizes[ i ] = 10.0;

				}

				// Instanced Points

				const positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );
				const colorsAttribute = new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 );

				const instanceSizeBufferAttribute = new THREE.StorageInstancedBufferAttribute( sizes, 1 );
				const instanceSizeStorage = storage( instanceSizeBufferAttribute, 'float', instanceSizeBufferAttribute.count );

				computeSize = Fn( () => {

					const { pulseSpeed, minWidth, maxWidth } = effectController;

					const relativeTime = time.add( float( instanceIndex ) );

					const sizeFactor = sin( relativeTime.mul( pulseSpeed ) ).add( 1 ).div( 2 );

					instanceSizeStorage.element( instanceIndex ).assign( sizeFactor.mul( maxWidth.sub( minWidth ) ).add( minWidth ) );

				} )().compute( divisions );
			
				// Material / Sprites

				const attributeRange = instancedBufferAttribute( instanceSizeBufferAttribute );
				const pointColors = mix( vec3( 0.0 ), instancedBufferAttribute( colorsAttribute ), attributeRange.div( float( effectController.maxWidth ) ) );

				material = new THREE.PointsNodeMaterial( {

					colorNode: pointColors,
					opacityNode: shapeCircle(),
					positionNode: instancedBufferAttribute( positionAttribute ),
					// rotationNode: time,
					sizeNode: instancedBufferAttribute( instanceSizeBufferAttribute ),
					// size: 40, // in pixels units
					vertexColors: true,
					sizeAttenuation: false,
					alphaToCoverage: true

				} );

				const instancedPoints = new THREE.Sprite( material );
				instancedPoints.count = divisions;
				scene.add( instancedPoints );

				// Renderer / Controls

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 10;
				controls.maxDistance = 500;

				window.addEventListener( 'resize', onWindowResize );
				onWindowResize();

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( material, 'alphaToCoverage' );

				gui.add( effectController.minWidth, 'value', 1, 30, 1 ).name( 'minWidth' );
				gui.add( effectController.maxWidth, 'value', 2, 30, 1 ).name( 'maxWidth' );
				gui.add( effectController.pulseSpeed, 'value', 1, 20, 0.1 ).name( 'pulseSpeed' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				insetWidth = window.innerHeight / 4; // square
				insetHeight = window.innerHeight / 4;

				camera2.aspect = insetWidth / insetHeight;
				camera2.updateProjectionMatrix();

			}

			function animate() {

				// compute

				renderer.compute( computeSize );

				// main scene

				renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

				controls.update();

				renderer.autoClear = true;

				scene.backgroundNode = null;

				renderer.render( scene, camera );

				// inset scene

				const posY = window.innerHeight - insetHeight - 20;

				renderer.clearDepth(); // important!

				renderer.setScissorTest( true );

				renderer.setScissor( 20, posY, insetWidth, insetHeight );

				renderer.setViewport( 20, posY, insetWidth, insetHeight );

				camera2.position.copy( camera.position );

				camera2.quaternion.copy( camera.quaternion );

				renderer.autoClear = false;

				scene.backgroundNode = backgroundNode;

				renderer.render( scene, camera2 );

				renderer.setScissorTest( false );

			}

			//

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_instance_sprites.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - instance sprites</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Instanced Sprites</span>
			</div>

			<small>
				Rendering instanced sprites with TSL.
			</small>
		</div>
		
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { uniform, time, instanceIndex, instancedBufferAttribute } from 'three/tsl';


			let camera, scene, renderer, material;
			let mouseX = 0, mouseY = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 2, 2000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0x000000, 0.001 );

				// positions

				const count = 10000;

				const positions = [];

				for ( let i = 0; i < count; i ++ ) {

					positions.push( 2000 * Math.random() - 1000, 2000 * Math.random() - 1000, 2000 * Math.random() - 1000 );

				}

				const positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );

				// texture

				const map = new THREE.TextureLoader().load( 'textures/sprites/snowflake1.png' );
				map.colorSpace = THREE.SRGBColorSpace;

				// material

				material = new THREE.SpriteNodeMaterial( { sizeAttenuation: true, map, alphaMap: map, alphaTest: 0.1 } );
				material.color.setHSL( 1.0, 0.3, 0.7, THREE.SRGBColorSpace );
				material.positionNode = instancedBufferAttribute( positionAttribute );
				material.rotationNode = time.add( instanceIndex ).sin();
				material.scaleNode = uniform( 15 );

				// sprites

				const particles = new THREE.Sprite( material );
				particles.count = count;

				scene.add( particles );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( material, 'sizeAttenuation' ).onChange( function () {

					material.needsUpdate = true;
					material.scaleNode.value = material.sizeAttenuation ? 15 : 0.03;
			
				} );

				//

				document.body.style.touchAction = 'none';
				document.body.addEventListener( 'pointermove', onPointerMove );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			//

			function animate() {

				render();

			}

			function render() {

				const time = Date.now() * 0.00005;

				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

				camera.lookAt( scene.position );

				const h = ( 360 * ( 1.0 + time ) % 360 ) / 360;
				material.color.setHSL( h, 0.5, 0.5 );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_instance_uniform.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - instance uniform</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Instanced Uniform</span>
			</div>

			<small>
				Rendering instanced meshes with individual instance uniforms.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { nodeObject, uniform, cubeTexture } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			class InstanceUniformNode extends THREE.Node {

				constructor() {

					super( 'vec3' );

					this.updateType = THREE.NodeUpdateType.OBJECT;

					this.uniformNode = uniform( new THREE.Color() );

				}

				update( frame ) {

					const mesh = frame.object;

					const meshColor = mesh.color;

					this.uniformNode.value.copy( meshColor );

				}

				setup( /*builder*/ ) {

					return this.uniformNode;

				}

			}

			let camera, scene, renderer;
			let controls;

			const objects = [];

			init();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
				camera.position.set( 0, 200, 1200 );

				scene = new THREE.Scene();

				// Grid

				const helper = new THREE.GridHelper( 1000, 40, 0x303030, 0x303030 );
				helper.position.y = - 75;
				scene.add( helper );

				// CubeMap

				const path = 'textures/cube/SwedishRoyalCastle/';
				const format = '.jpg';
				const urls = [
					path + 'px' + format, path + 'nx' + format,
					path + 'py' + format, path + 'ny' + format,
					path + 'pz' + format, path + 'nz' + format
				];

				const cTexture = new THREE.CubeTextureLoader().load( urls );

				// Materials

				const instanceUniform = nodeObject( new InstanceUniformNode() );
				const cubeTextureNode = cubeTexture( cTexture );

				const material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = instanceUniform.add( cubeTextureNode );
				material.emissiveNode = instanceUniform.mul( cubeTextureNode );

				// Geometry

				const geometry = new TeapotGeometry( 50, 18 );

				for ( let i = 0, l = 12; i < l; i ++ ) {

					addMesh( geometry, material );

				}

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 400;
				controls.maxDistance = 2000;

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function addMesh( geometry, material ) {

				const mesh = new THREE.Mesh( geometry, material );

				mesh.color = new THREE.Color( Math.random() * 0xffffff );

				mesh.position.x = ( objects.length % 4 ) * 200 - 300;
				mesh.position.z = Math.floor( objects.length / 4 ) * 200 - 200;

				mesh.rotation.x = Math.random() * 200 - 100;
				mesh.rotation.y = Math.random() * 200 - 100;
				mesh.rotation.z = Math.random() * 200 - 100;

				objects.push( mesh );

				scene.add( mesh );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				for ( let i = 0, l = objects.length; i < l; i ++ ) {

					const object = objects[ i ];

					object.rotation.x += 0.01;
					object.rotation.y += 0.005;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_instancing_morph.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - instancing morph target animations</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Instancing Morph</span>
			</div>

			<small>
				Rendering instances which are individually animated via morph targets.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, mesh, mixer, dummy;

			const offset = 5000;

			const timeOffsets = new Float32Array( 1024 );

			for ( let i = 0; i < 1024; i ++ ) {

				timeOffsets[ i ] = Math.random() * 3;

			}

			const clock = new THREE.Clock( true );

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 10000 );

				scene = new THREE.Scene();

				scene.background = new THREE.Color( 0x99DDFF );

				scene.fog = new THREE.Fog( 0x99DDFF, 5000, 10000 );

				//

				const light = new THREE.DirectionalLight( 0xffffff, 1 );

				light.position.set( 200, 1000, 50 );

				light.shadow.mapSize.width = 2048;
				light.shadow.mapSize.height = 2048;
				light.castShadow = true;

				light.shadow.camera.left = - 5000;
				light.shadow.camera.right = 5000;
				light.shadow.camera.top = 5000;
				light.shadow.camera.bottom = - 5000;
				light.shadow.camera.far = 2000;

				light.shadow.bias = - 0.01;

				light.shadow.camera.updateProjectionMatrix();

				scene.add( light );

				const hemi = new THREE.HemisphereLight( 0x99DDFF, 0x669933, 1 / 3 );

				scene.add( hemi );

				const ground = new THREE.Mesh(
					new THREE.PlaneGeometry( 1000000, 1000000 ),
					new THREE.MeshStandardMaterial( { color: 0x669933 } )
				);

				ground.rotation.x = - Math.PI / 2;

				ground.receiveShadow = true;

				scene.add( ground );

				const loader = new GLTFLoader();

				loader.load( 'models/gltf/Horse.glb', function ( glb ) {

					dummy = glb.scene.children[ 0 ];

					mesh = new THREE.InstancedMesh( dummy.geometry, new THREE.MeshStandardNodeMaterial( {
						flatShading: true,
					} ), 1024 );

					mesh.castShadow = true;

					for ( let x = 0, i = 0; x < 32; x ++ ) {

						for ( let y = 0; y < 32; y ++ ) {

							dummy.position.set( offset - 300 * x + 200 * Math.random(), 0, offset - 300 * y );

							dummy.updateMatrix();

							mesh.setMatrixAt( i, dummy.matrix );

							mesh.setColorAt( i, new THREE.Color( `hsl(${Math.random() * 360}, 50%, 66%)` ) );

							i ++;
			
						}

			
					}

					scene.add( mesh );

					mixer = new THREE.AnimationMixer( glb.scene );

					const action = mixer.clipAction( glb.animations[ 0 ] );

					action.play();
			
				} );


				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setAnimationLoop( animate );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				const time = clock.getElapsedTime();

				const r = 3000;
				camera.position.set( Math.sin( time / 10 ) * r, 1500 + 1000 * Math.cos( time / 5 ), Math.cos( time / 10 ) * r );
				camera.lookAt( 0, 0, 0 );

				if ( mesh ) {

					for ( let i = 0; i < 1024; i ++ ) {

						mixer.setTime( time + timeOffsets[ i ] );

						mesh.setMorphAt( i, dummy );

					}

					mesh.morphTexture.needsUpdate = true;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_layers.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - layers</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Layers</span>
			</div>

			<small>
				Organizing 3D objects in different layers.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { positionLocal, time, mod, instancedBufferAttribute, rotate, screenUV, color, vec2 } from 'three/tsl';

			let camera, scene, renderer;


			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.layers.enable( 0 ); // enabled by default
				camera.layers.enable( 1 );
				camera.layers.enable( 2 );

				camera.position.z = 10;

				scene = new THREE.Scene();

				const horizontalEffect = screenUV.x.mix( color( 0xf996ae ), color( 0xf6f0a3 ) );
				const lightEffect = screenUV.distance( vec2( 0.5, 1.0 ) ).oneMinus().mul( color( 0xd9b6fd ) );

				scene.backgroundNode = horizontalEffect.add( lightEffect );

				const sprite = new THREE.TextureLoader().load( 'textures/sprites/blossom.png' );
				sprite.colorSpace = THREE.SRGBColorSpace;

				const count = 2500;

				const geometry = new THREE.PlaneGeometry( 0.25, 0.25 );

				const colors = [ 0xD70654, 0xFFD95F, 0xB8D576 ];

				for ( let i = 0; i < 3; i ++ ) {

					const particles = new THREE.Mesh( geometry, getMaterial( count, colors[ i ], sprite ) );
					particles.layers.set( i );
					particles.count = count;
					scene.add( particles );

				}

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// GUI

				const layers = {
					'Red': true,
					'Yellow': true,
					'Green': true
				};

				const gui = renderer.inspector.createParameters( 'Layers' );

				gui.add( layers, 'Red' ).onChange( () => {

					camera.layers.toggle( 0 );

				} );

				gui.add( layers, 'Yellow' ).onChange( () => {

					camera.layers.toggle( 1 );

				} );

				gui.add( layers, 'Green' ).onChange( () => {

					camera.layers.toggle( 2 );

				} );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function getMaterial( count, color, sprite ) {

				// instance data

				const positions = [];
				const rotations = [];
				const directions = [];
				const timeOffsets = [];

				const v = new THREE.Vector3();

				for ( let i = 0; i < count; i ++ ) {

					positions.push(
						THREE.MathUtils.randFloat( - 25, - 20 ),
						THREE.MathUtils.randFloat( - 10, 50 ),
						THREE.MathUtils.randFloat( - 5, 5 )
					);

					v.set( THREE.MathUtils.randFloat( 0.7, 0.9 ), THREE.MathUtils.randFloat( - 0.3, - 0.15 ), 0 ).normalize();

					rotations.push( Math.random(), Math.random(), Math.random() );

					directions.push( v.x, v.y, v.z );

					timeOffsets.push( i / count );

				}

				const positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );
				const rotationAttribute = new THREE.InstancedBufferAttribute( new Float32Array( rotations ), 3 );
				const directionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( directions ), 3 );
				const timeAttribute = new THREE.InstancedBufferAttribute( new Float32Array( timeOffsets ), 1 );

				// material

				const material = new THREE.MeshBasicNodeMaterial( {
					color: color,
					map: sprite,
					alphaMap: sprite,
					alphaTest: 0.1,
					side: THREE.DoubleSide,
					forceSinglePass: true
				} );

				// TSL

				const instancePosition = instancedBufferAttribute( positionAttribute );
				const instanceDirection = instancedBufferAttribute( directionAttribute );
				const instanceRotation = instancedBufferAttribute( rotationAttribute );

				const localTime = instancedBufferAttribute( timeAttribute ).add( time.mul( 0.02 ) );
				const modTime = mod( localTime, 1.0 );

				const rotatedPosition = rotate( positionLocal, instanceRotation.mul( modTime.mul( 20 ) ) );
				material.positionNode = rotatedPosition.add( instancePosition ).add( instanceDirection.mul( modTime.mul( 50 ) ) );

				return material;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lensflares.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - lens flares</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Lens Flares</span>
			</div>

			<small>
				Fly with WASD/RF/QE + mouse.<br/>
				Textures from <a href="http://www.ro.me" target="_blank" rel="noopener">ro.me</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { FlyControls } from 'three/addons/controls/FlyControls.js';
			import { LensflareMesh, LensflareElement } from 'three/addons/objects/LensflareMesh.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let container;

			let camera, scene, renderer;
			let controls;

			const clock = new THREE.Clock();

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// camera

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 15000 );
				camera.position.z = 250;

				// scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color().setHSL( 0.51, 0.4, 0.01, THREE.SRGBColorSpace );
				scene.fog = new THREE.Fog( scene.background, 3500, 15000 );

				// world

				const s = 250;

				const geometry = new THREE.BoxGeometry( s, s, s );
				const material = new THREE.MeshPhongNodeMaterial( { color: 0xffffff, specular: 0xffffff, shininess: 50 } );

				for ( let i = 0; i < 3000; i ++ ) {

					const mesh = new THREE.Mesh( geometry, material );

					mesh.position.x = 8000 * ( 2.0 * Math.random() - 1.0 );
					mesh.position.y = 8000 * ( 2.0 * Math.random() - 1.0 );
					mesh.position.z = 8000 * ( 2.0 * Math.random() - 1.0 );

					mesh.rotation.x = Math.random() * Math.PI;
					mesh.rotation.y = Math.random() * Math.PI;
					mesh.rotation.z = Math.random() * Math.PI;

					mesh.matrixAutoUpdate = false;
					mesh.updateMatrix();

					scene.add( mesh );

				}


				// lights

				const dirLight = new THREE.DirectionalLight( 0xffffff, 0.15 );
				dirLight.position.set( 0, - 1, 0 ).normalize();
				dirLight.color.setHSL( 0.1, 0.7, 0.5 );
				scene.add( dirLight );

				// lensflares
				const textureLoader = new THREE.TextureLoader();

				const textureFlare0 = textureLoader.load( 'textures/lensflare/lensflare0.png' );
				const textureFlare3 = textureLoader.load( 'textures/lensflare/lensflare3.png' );

				textureFlare0.colorSpace = THREE.SRGBColorSpace;
				textureFlare3.colorSpace = THREE.SRGBColorSpace;

				addLight( 0.55, 0.95, 0.6, 5000, 0, - 1000 );
				addLight( 0.1, 0.85, 0.65, 0, 0, - 1000 );
				addLight( 0.995, 0.5, 0.95, 5000, 5000, - 1000 );

				function addLight( h, s, l, x, y, z ) {

					const light = new THREE.PointLight( 0xffffff, 1.5, 2000, 0 );
					light.color.setHSL( h, s, l );
					light.position.set( x, y, z );
					scene.add( light );

					const lensflare = new LensflareMesh();
					lensflare.addElement( new LensflareElement( textureFlare0, 700, 0, light.color ) );
					lensflare.addElement( new LensflareElement( textureFlare3, 60, 0.6 ) );
					lensflare.addElement( new LensflareElement( textureFlare3, 70, 0.7 ) );
					lensflare.addElement( new LensflareElement( textureFlare3, 120, 0.9 ) );
					lensflare.addElement( new LensflareElement( textureFlare3, 70, 1 ) );
					light.add( lensflare );

				}

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				controls = new FlyControls( camera, renderer.domElement );

				controls.movementSpeed = 2500;
				controls.domElement = container;
				controls.rollSpeed = Math.PI / 6;
				controls.autoForward = false;
				controls.dragToLook = false;

				// events

				window.addEventListener( 'resize', onWindowResize );

			}

			//

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

			}

			//

			function animate() {

				render();

			}

			function render() {

				const delta = clock.getDelta();

				controls.update( delta );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lightprobe.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - light probe</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Light Probe</span>
			</div>

			<small>
				Light probes and environment lighting.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';

			import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelperGPU.js';

			let mesh, renderer, scene, camera;

			let gui;

			let lightProbe;
			let directionalLight;

			// linear color space
			const API = {
				lightProbeIntensity: 1.0,
				directionalLightIntensity: 0.6,
				envMapIntensity: 1
			};

			init();

			function init() {

				// renderer
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// tone mapping
				renderer.toneMapping = THREE.NoToneMapping;

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 0, 30 );

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 10;
				controls.maxDistance = 50;
				controls.enablePan = false;

				// probe
				lightProbe = new THREE.LightProbe();
				scene.add( lightProbe );

				// light
				directionalLight = new THREE.DirectionalLight( 0xffffff, API.directionalLightIntensity );
				directionalLight.position.set( 10, 10, 10 );
				scene.add( directionalLight );

				// envmap
				const genCubeUrls = function ( prefix, postfix ) {

					return [
						prefix + 'px' + postfix, prefix + 'nx' + postfix,
						prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix
					];

				};

				const urls = genCubeUrls( 'textures/cube/pisa/', '.png' );

				new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {

					scene.background = cubeTexture;

					lightProbe.copy( LightProbeGenerator.fromCubeTexture( cubeTexture ) );
					lightProbe.intensity = API.lightProbeIntensity;
					lightProbe.position.set( - 10, 0, 0 ); // position not used in scene lighting calculations (helper honors the position, however)

					const geometry = new THREE.SphereGeometry( 5, 64, 32 );
					//const geometry = new THREE.TorusKnotGeometry( 4, 1.5, 256, 32, 2, 3 );

					const material = new THREE.MeshStandardMaterial( {
						color: 0xffffff,
						metalness: 0,
						roughness: 0,
						envMap: cubeTexture,
						envMapIntensity: API.envMapIntensity,
					} );

					// mesh
					mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );

					// helper
					const helper = new LightProbeHelper( lightProbe, 1 );
					scene.add( helper );

				} );


				// gui
				gui = renderer.inspector.createParameters( 'Intensity' );

				gui.add( API, 'lightProbeIntensity', 0, 1, 0.02 )
					.name( 'light probe' )
					.onChange( function () {

						lightProbe.intensity = API.lightProbeIntensity;

					} );

				gui.add( API, 'directionalLightIntensity', 0, 1, 0.02 )
					.name( 'directional light' )
					.onChange( function () {

						directionalLight.intensity = API.directionalLightIntensity;

					} );

				gui.add( API, 'envMapIntensity', 0, 1, 0.02 )
					.name( 'envMap' )
					.onChange( function () {

						mesh.material.envMapIntensity = API.envMapIntensity;

					} );

				// listener
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();


			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lightprobe_cubecamera.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - light probe from cube camera</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Light Probe from Cube Camera</span>
			</div>

			<small>
				Light probes and environment lighting from cube camera.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelperGPU.js';
			import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';

			let renderer, scene, camera, cubeCamera;

			let lightProbe;

			init();

			function init() {

				// renderer
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 0, 30 );

				const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );

				cubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render );
				controls.minDistance = 10;
				controls.maxDistance = 50;
				controls.enablePan = false;

				// probe
				lightProbe = new THREE.LightProbe();
				scene.add( lightProbe );

				// envmap
				const genCubeUrls = function ( prefix, postfix ) {

					return [
						prefix + 'px' + postfix, prefix + 'nx' + postfix,
						prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix
					];

				};

				const urls = genCubeUrls( 'textures/cube/pisa/', '.png' );

				new THREE.CubeTextureLoader().load( urls, async function ( cubeTexture ) {

					scene.background = cubeTexture;

					await renderer.init();

					cubeCamera.update( renderer, scene );

					const probe = await LightProbeGenerator.fromCubeRenderTarget( renderer, cubeRenderTarget );

					lightProbe.copy( probe );

					scene.add( new LightProbeHelper( lightProbe, 5 ) );

					render();

				} );

				// listener
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_custom.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - custom lighting model</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Custom Lighting Model</span>
			</div>

			<small>
				Custom lighting model with selective lights.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, lights } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			class CustomLightingModel extends THREE.LightingModel {

				direct( { lightColor, reflectedLight }/*, builder */ ) {

					reflectedLight.directDiffuse.addAssign( lightColor );

				}

			}

			let camera, scene, renderer;

			let light1, light2, light3;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.z = 1.5;

				scene = new THREE.Scene();

				// lights

				const sphereGeometry = new THREE.SphereGeometry( 0.02, 16, 8 );

				const addLight = ( hexColor ) => {

					const material = new THREE.NodeMaterial();
					material.colorNode = color( hexColor );
					material.lightsNode = lights(); // ignore scene lights

					const mesh = new THREE.Mesh( sphereGeometry, material );

					const light = new THREE.PointLight( hexColor, 0.1, 1 );
					light.add( mesh );

					scene.add( light );

					return light;

				};

				light1 = addLight( 0xffaa00 );
				light2 = addLight( 0x0040ff );
				light3 = addLight( 0x80ff80 );

				//light nodes ( selective lights )

				const allLightsNode = lights( [ light1, light2, light3 ] );

				// points

				const points = [];

				for ( let i = 0; i < 500000; i ++ ) {

					const point = new THREE.Vector3().random().subScalar( 0.5 ).multiplyScalar( 3 );
					points.push( point );

				}

				const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
				const materialPoints = new THREE.PointsNodeMaterial();

				// custom lighting model

				const lightingModel = new CustomLightingModel();
				const lightingModelContext = allLightsNode.context( { lightingModel } );

				materialPoints.lightsNode = lightingModelContext;

				//

				const pointCloud = new THREE.Points( geometryPoints, materialPoints );
				scene.add( pointCloud );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				// controls

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 0;
				controls.maxDistance = 4;

				// events

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = Date.now() * 0.001;
				const scale = .5;

				light1.position.x = Math.sin( time * 0.7 ) * scale;
				light1.position.y = Math.cos( time * 0.5 ) * scale;
				light1.position.z = Math.cos( time * 0.3 ) * scale;

				light2.position.x = Math.cos( time * 0.3 ) * scale;
				light2.position.y = Math.sin( time * 0.5 ) * scale;
				light2.position.z = Math.sin( time * 0.7 ) * scale;

				light3.position.x = Math.sin( time * 0.7 ) * scale;
				light3.position.y = Math.cos( time * 0.3 ) * scale;
				light3.position.z = Math.sin( time * 0.5 ) * scale;

				scene.rotation.y = time * 0.1;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_ies_spotlight.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - ies spotlight</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>IES Spot Light</span>
			</div>

			<small>
				IES Spot Light with IES texture files.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			import { IESLoader } from 'three/addons/loaders/IESLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let renderer, scene, camera;
			let lights;

			async function init() {

				const iesLoader = new IESLoader().setPath( './ies/' );
				//iesLoader.type = THREE.UnsignedByteType; // LDR

				const [ iesTexture1, iesTexture2, iesTexture3, iesTexture4 ] = await Promise.all( [
					iesLoader.loadAsync( '007cfb11e343e2f42e3b476be4ab684e.ies' ),
					iesLoader.loadAsync( '06b4cfdc8805709e767b5e2e904be8ad.ies' ),
					iesLoader.loadAsync( '02a7562c650498ebb301153dbbf59207.ies' ),
					iesLoader.loadAsync( '1a936937a49c63374e6d4fbed9252b29.ies' )
				] );

				//

				scene = new THREE.Scene();

				//

				const spotLight = new THREE.IESSpotLight( 0xff0000, 500 );
				spotLight.position.set( 6.5, 3, 6.5 );
				spotLight.angle = Math.PI / 8;
				spotLight.penumbra = 0.7;
				spotLight.distance = 20;
				spotLight.castShadow = true;
				spotLight.iesMap = iesTexture1;
				spotLight.userData.helper = new THREE.SpotLightHelper( spotLight );
				scene.add( spotLight );
				scene.add( spotLight.target );
				scene.add( spotLight.userData.helper );

				//

				const spotLight2 = new THREE.IESSpotLight( 0x00ff00, 500 );
				spotLight2.position.set( - 6.5, 3, 6.5 );
				spotLight2.angle = Math.PI / 8;
				spotLight2.penumbra = 0.7;
				spotLight2.distance = 20;
				spotLight2.castShadow = true;
				spotLight2.iesMap = iesTexture2;
				spotLight2.userData.helper = new THREE.SpotLightHelper( spotLight2 );
				scene.add( spotLight2 );
				scene.add( spotLight2.target );
				scene.add( spotLight2.userData.helper );

				//

				const spotLight3 = new THREE.IESSpotLight( 0x0000ff, 500 );
				spotLight3.position.set( - 6.5, 3, - 6.5 );
				spotLight3.angle = Math.PI / 8;
				spotLight3.penumbra = 0.7;
				spotLight3.distance = 20;
				spotLight3.castShadow = true;
				spotLight3.iesMap = iesTexture3;
				spotLight3.userData.helper = new THREE.SpotLightHelper( spotLight3 );
				scene.add( spotLight3 );
				scene.add( spotLight3.target );
				scene.add( spotLight3.userData.helper );

				//

				const spotLight4 = new THREE.IESSpotLight( 0xffffff, 500 );
				spotLight4.position.set( 6.5, 3, - 6.5 );
				spotLight4.angle = Math.PI / 8;
				spotLight4.penumbra = 0.7;
				spotLight4.distance = 20;
				spotLight4.castShadow = true;
				spotLight4.iesMap = iesTexture4;
				spotLight4.userData.helper = new THREE.SpotLightHelper( spotLight4 );
				scene.add( spotLight4 );
				scene.add( spotLight4.target );
				scene.add( spotLight4.userData.helper );

				//

				lights = [ spotLight, spotLight2, spotLight3, spotLight4 ];

				//

				const material = new THREE.MeshPhongMaterial( { color: 0x999999/*, dithering: true*/ } );

				const geometry = new THREE.PlaneGeometry( 200, 200 );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.rotation.x = - Math.PI * 0.5;
				mesh.receiveShadow = true;
				scene.add( mesh );

				const geometry2 = new THREE.BoxGeometry( 2, 2, 2 );
				//const geometry2 = new THREE.IcosahedronGeometry( 1, 5 );

				const mesh2 = new THREE.Mesh( geometry2, material );
				mesh2.position.y = 1;
				mesh2.castShadow = true;
				scene.add( mesh2 );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 100 );
				camera.position.set( 16, 4, 1 );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 50;
				controls.enablePan = false;

				//

				function setHelperVisible( value ) {

					for ( let i = 0; i < lights.length; i ++ ) {

						lights[ i ].userData.helper.visible = value;

					}

				}

				setHelperVisible( false );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( { helper: false }, 'helper' ).onChange( ( v ) => setHelperVisible( v ) );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render( time ) {

				time = time / 1000;

				for ( let i = 0; i < lights.length; i ++ ) {

					const t = ( Math.sin( ( time + i ) * ( Math.PI / 2 ) ) + 1 ) / 2;

					const x = THREE.MathUtils.lerp( lights[ i ].position.x, 0, t );
					const z = THREE.MathUtils.lerp( lights[ i ].position.z, 0, t );

					lights[ i ].target.position.x = x;
					lights[ i ].target.position.z = z;
					if ( lights[ i ].userData.helper ) lights[ i ].userData.helper.update();

				}

				renderer.render( scene, camera );

			}

			init();

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_phong.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - phong lighting model</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Phong</span>
			</div>

			<small>
				<b style="color:red">Left: Red lights</b> - <b>Center: All lights</b> - <b style="color:blue">Right: blue light</b>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, fog, rangeFogFactor, checker, uv, mix, texture, lights, normalMap } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';

			let camera, scene, renderer,
				light1, light2, light3, light4,
				controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.z = 7;

				scene = new THREE.Scene();
				scene.fogNode = fog( color( 0xFF00FF ), rangeFogFactor( 12, 30 ) );

				const sphereGeometry = new THREE.SphereGeometry( 0.1, 16, 8 );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const normalMapTexture = textureLoader.load( './textures/water/Water_1_M_Normal.jpg' );
				normalMapTexture.wrapS = THREE.RepeatWrapping;
				normalMapTexture.wrapT = THREE.RepeatWrapping;

				const alphaTexture = textureLoader.load( './textures/roughness_map.jpg' );
				alphaTexture.wrapS = THREE.RepeatWrapping;
				alphaTexture.wrapT = THREE.RepeatWrapping;

				// lights

				const addLight = ( hexColor, power = 1700, distance = 100 ) => {

					const material = new THREE.MeshPhongNodeMaterial();
					material.colorNode = color( hexColor );
					material.lights = false;

					const mesh = new THREE.Mesh( sphereGeometry, material );

					const light = new THREE.PointLight( hexColor, 1, distance );
					light.power = power;
					light.add( mesh );

					scene.add( light );

					return light;

				};

				light1 = addLight( 0x0040ff );
				light2 = addLight( 0xffffff );
				light3 = addLight( 0x80ff80 );
				light4 = addLight( 0xffaa00 );

				// light nodes ( selective lights )

				const blueLightsNode = lights( [ light1 ] );
				const whiteLightsNode = lights( [ light2 ] );

				// models

				const geometryTeapot = new TeapotGeometry( .8, 18 );

				const leftObject = new THREE.Mesh( geometryTeapot, new THREE.MeshPhongNodeMaterial( { color: 0x555555 } ) );
				leftObject.material.lightsNode = blueLightsNode;
				leftObject.material.specularNode = texture( alphaTexture );
				leftObject.position.x = - 3;
				scene.add( leftObject );

				const centerObject = new THREE.Mesh( geometryTeapot, new THREE.MeshPhongNodeMaterial( { color: 0x555555 } ) );
				centerObject.material.normalNode = normalMap( texture( normalMapTexture ) );
				centerObject.material.shininess = 80;
				scene.add( centerObject );

				const rightObject = new THREE.Mesh( geometryTeapot, new THREE.MeshPhongNodeMaterial( { color: 0x555555 } ) );
				rightObject.material.lightsNode = whiteLightsNode;
				//rightObject.material.specular.setHex( 0xFF00FF );
				rightObject.material.specularNode = mix( color( 0x0000FF ), color( 0xFF0000 ), checker( uv().mul( 5 ) ) );
				rightObject.material.shininess = 90;
				rightObject.position.x = 3;
				scene.add( rightObject );

				leftObject.rotation.y = centerObject.rotation.y = rightObject.rotation.y = Math.PI * - 0.5;
				leftObject.position.y = centerObject.position.y = rightObject.position.y = - 1;

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 3;
				controls.maxDistance = 25;

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = performance.now() / 1000;
				const lightTime = time * 0.5;

				light1.position.x = Math.sin( lightTime * 0.7 ) * 3;
				light1.position.y = Math.cos( lightTime * 0.5 ) * 4;
				light1.position.z = Math.cos( lightTime * 0.3 ) * 3;

				light2.position.x = Math.cos( lightTime * 0.3 ) * 3;
				light2.position.y = Math.sin( lightTime * 0.5 ) * 4;
				light2.position.z = Math.sin( lightTime * 0.7 ) * 3;

				light3.position.x = Math.sin( lightTime * 0.7 ) * 3;
				light3.position.y = Math.cos( lightTime * 0.3 ) * 4;
				light3.position.z = Math.sin( lightTime * 0.5 ) * 3;

				light4.position.x = Math.sin( lightTime * 0.3 ) * 3;
				light4.position.y = Math.cos( lightTime * 0.7 ) * 4;
				light4.position.z = Math.sin( lightTime * 0.5 ) * 3;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_physical.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - physical lights</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Physical Lighting Model</span>
			</div>

			<small>
				Physically accurate incandescent bulb by <a href="http://clara.io" target="_blank" rel="noopener">Ben Houston</a><br />
				Real world scale: Brick cube is 50 cm in size. Globe is 50 cm in diameter.<br/>
				Reinhard tonemapping with real-world light falloff (decay = 2).
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, bulbLight, bulbMat, hemiLight;
			let ballMat, cubeMat, floorMat;

			let previousShadowMap = false;

			// ref for lumens: http://www.power-sure.com/lumens.htm
			const bulbLuminousPowers = {
				'110000 lm (1000W)': 110000,
				'3500 lm (300W)': 3500,
				'1700 lm (100W)': 1700,
				'800 lm (60W)': 800,
				'400 lm (40W)': 400,
				'180 lm (25W)': 180,
				'20 lm (4W)': 20,
				'Off': 0
			};

			// ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
			const hemiLuminousIrradiances = {
				'0.0001 lx (Moonless Night)': 0.0001,
				'0.002 lx (Night Airglow)': 0.002,
				'0.5 lx (Full Moon)': 0.5,
				'3.4 lx (City Twilight)': 3.4,
				'50 lx (Living Room)': 50,
				'100 lx (Very Overcast)': 100,
				'350 lx (Office Room)': 350,
				'400 lx (Sunrise/Sunset)': 400,
				'1000 lx (Overcast)': 1000,
				'18000 lx (Daylight)': 18000,
				'50000 lx (Direct Sun)': 50000
			};

			const params = {
				shadows: true,
				exposure: 0.68,
				bulbPower: Object.keys( bulbLuminousPowers )[ 4 ],
				hemiIrradiance: Object.keys( hemiLuminousIrradiances )[ 0 ]
			};

			init();

			function init() {

				const container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.x = - 4;
				camera.position.z = 4;
				camera.position.y = 2;

				scene = new THREE.Scene();

				const bulbGeometry = new THREE.SphereGeometry( 0.02, 16, 8 );
				bulbLight = new THREE.PointLight( 0xffee88, 1, 100, 2 );

				bulbMat = new THREE.MeshStandardMaterial( {
					emissive: 0xffffee,
					emissiveIntensity: 1,
					color: 0x000000
				} );
				bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
				bulbLight.position.set( 0, 2, 0 );
				bulbLight.castShadow = true;
				scene.add( bulbLight );

				hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );
				scene.add( hemiLight );

				floorMat = new THREE.MeshStandardMaterial( {
					roughness: 0.8,
					color: 0xffffff,
					metalness: 0.2,
					bumpScale: 1
				} );
				const textureLoader = new THREE.TextureLoader();
				textureLoader.load( 'textures/hardwood2_diffuse.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 24 );
					map.colorSpace = THREE.SRGBColorSpace;
					floorMat.map = map;
					floorMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/hardwood2_bump.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 24 );
					floorMat.bumpMap = map;
					floorMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/hardwood2_roughness.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 24 );
					floorMat.roughnessMap = map;
					floorMat.needsUpdate = true;

				} );

				cubeMat = new THREE.MeshStandardMaterial( {
					roughness: 0.7,
					color: 0xffffff,
					bumpScale: 1,
					metalness: 0.2
				} );
				textureLoader.load( 'textures/brick_diffuse.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 1, 1 );
					map.colorSpace = THREE.SRGBColorSpace;
					cubeMat.map = map;
					cubeMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/brick_bump.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 1, 1 );
					cubeMat.bumpMap = map;
					cubeMat.needsUpdate = true;

				} );

				ballMat = new THREE.MeshStandardMaterial( {
					color: 0xffffff,
					roughness: 0.5,
					metalness: 1.0
				} );
				textureLoader.load( 'textures/planets/earth_atmos_2048.jpg', function ( map ) {

					map.anisotropy = 4;
					map.colorSpace = THREE.SRGBColorSpace;
					ballMat.map = map;
					ballMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/planets/earth_specular_2048.jpg', function ( map ) {

					map.anisotropy = 4;
					map.colorSpace = THREE.SRGBColorSpace;
					ballMat.metalnessMap = map;
					ballMat.needsUpdate = true;

				} );

				const floorGeometry = new THREE.PlaneGeometry( 20, 20 );
				const floorMesh = new THREE.Mesh( floorGeometry, floorMat );
				floorMesh.receiveShadow = true;
				floorMesh.rotation.x = - Math.PI / 2.0;
				scene.add( floorMesh );

				const ballGeometry = new THREE.SphereGeometry( 0.25, 32, 32 );
				const ballMesh = new THREE.Mesh( ballGeometry, ballMat );
				ballMesh.position.set( 1, 0.25, 1 );
				ballMesh.rotation.y = Math.PI;
				ballMesh.castShadow = true;
				scene.add( ballMesh );

				const boxGeometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );
				const boxMesh = new THREE.Mesh( boxGeometry, cubeMat );
				boxMesh.position.set( - 0.5, 0.25, - 1 );
				boxMesh.castShadow = true;
				scene.add( boxMesh );

				const boxMesh2 = new THREE.Mesh( boxGeometry, cubeMat );
				boxMesh2.position.set( 0, 0.25, - 5 );
				boxMesh2.castShadow = true;
				scene.add( boxMesh2 );

				const boxMesh3 = new THREE.Mesh( boxGeometry, cubeMat );
				boxMesh3.position.set( 7, 0.25, 0 );
				boxMesh3.castShadow = true;
				scene.add( boxMesh3 );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 20;

				window.addEventListener( 'resize', onWindowResize );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( params, 'hemiIrradiance', Object.keys( hemiLuminousIrradiances ) );
				gui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );
				gui.add( params, 'exposure', 0, 1 );
				gui.add( params, 'shadows' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				renderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.
				renderer.shadowMap.enabled = params.shadows;
				bulbLight.castShadow = params.shadows;

				if ( params.shadows !== previousShadowMap ) {

					ballMat.needsUpdate = true;
					cubeMat.needsUpdate = true;
					floorMat.needsUpdate = true;
					previousShadowMap = params.shadows;

				}

				bulbLight.power = bulbLuminousPowers[ params.bulbPower ];
				bulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 2.0 ); // convert from intensity to irradiance at bulb surface

				hemiLight.intensity = hemiLuminousIrradiances[ params.hemiIrradiance ];
				const time = Date.now() * 0.0005;

				bulbLight.position.y = Math.cos( time ) * 0.75 + 1.25;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_pointlights.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - point lights</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Point Lights</span>
			</div>

			<small>
				Walt Disney head by <a href="http://web.archive.org/web/20120903131400/http://davidoreilly.com/post/18087489343/disneyhead" target="_blank" rel="noopener">David OReilly</a><br />
				Displacement effect by <a href="https://oosmoxiecode.com/archive/js_webgl/stanford_bunny/" target="_blank" rel="noopener">oosmoxiecode</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { abs, attribute, distance, float, max, modelWorldMatrixInverse, positionLocal, sin, time, uniform } from 'three/tsl';

			let camera, scene, timer, renderer, controls;

			let light1, light2;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 100;

				scene = new THREE.Scene();

				timer = new THREE.Timer();
				timer.connect( document );

				// model

				const loader = new OBJLoader();
				loader.load( 'models/obj/walt/WaltHead.obj', function ( obj ) {

					const mesh = obj.children[ 0 ];
					mesh.geometry = createGeometry( mesh.geometry );
					mesh.material = createMaterial();

					mesh.scale.multiplyScalar( 0.8 );
					mesh.position.y = - 30;
					scene.add( mesh );

				} );

				const sphere = new THREE.SphereGeometry( 0.5, 16, 8 );

				// lights

				light1 = new THREE.PointLight( 0xff0040, 2000 );
				light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
				scene.add( light1 );

				light2 = new THREE.PointLight( 0x0040ff, 2000 );
				light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
				scene.add( light2 );

				scene.add( new THREE.AmbientLight( 0xaaaaaa, 0.1 ) );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				timer.update();

				const time = timer.getElapsed() * 0.5;

				controls.update();

				light1.position.x = Math.sin( time ) * 20;
				light1.position.y = Math.cos( time * 0.75 ) * - 30;
				light1.position.z = Math.cos( time * 0.5 ) * 20;

				light2.position.x = Math.cos( time * 0.5 ) * 20;
				light2.position.y = Math.sin( time * 0.75 ) * - 30;
				light2.position.z = Math.sin( time ) * 20;

				renderer.render( scene, camera );

			}

			// helpers

			function createMaterial() {

				const material = new THREE.MeshPhongNodeMaterial();

				const seedAttribute = attribute( 'seed' );
				const displaceNormalAttribute = attribute( 'displaceNormal' );

				const localTime = attribute( 'time' ).add( time );

				const effector1 = uniform( light1.position ).toVar();
				const effector2 = uniform( light2.position ).toVar();

				const distance1 = distance( positionLocal, modelWorldMatrixInverse.mul( effector1 ) );
				const distance2 = distance( positionLocal, modelWorldMatrixInverse.mul( effector2 ) );

				const invDistance1 = max( 0.0, float( 20.0 ).sub( distance1 ) ).div( 2.0 );
				const invDistance2 = max( 0.0, float( 20.0 ).sub( distance2 ) ).div( 2.0 );

				const s = abs( sin( localTime.mul( 2 ).add( seedAttribute ) ).mul( 0.5 ) ).add( invDistance1 ).add( invDistance2 );

				material.positionNode = positionLocal.add( displaceNormalAttribute.mul( s ) );

				return material;

			}

			function createGeometry( geometry ) {

				const positionAttribute = geometry.getAttribute( 'position' );

				const v0 = new THREE.Vector3();
				const v1 = new THREE.Vector3();
				const v2 = new THREE.Vector3();
				const v3 = new THREE.Vector3();
				const n = new THREE.Vector3();

				const plane = new THREE.Plane();

				const vertices = [];
				const times = [];
				const seeds = [];
				const displaceNormal = [];

				for ( let i = 0; i < positionAttribute.count; i += 3 ) {

					v0.fromBufferAttribute( positionAttribute, i );
					v1.fromBufferAttribute( positionAttribute, i + 1 );
					v2.fromBufferAttribute( positionAttribute, i + 2 );

					plane.setFromCoplanarPoints( v0, v1, v2 );

					v3.copy( v0 ).add( v1 ).add( v2 ).divideScalar( 3 ); // compute center
					v3.add( n.copy( plane.normal ).multiplyScalar( - 1 ) ); // displace center inwards

					// generate tetrahedron for each triangle

					vertices.push( v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z );
					vertices.push( v3.x, v3.y, v3.z, v1.x, v1.y, v1.z, v0.x, v0.y, v0.z );
					vertices.push( v3.x, v3.y, v3.z, v2.x, v2.y, v2.z, v1.x, v1.y, v1.z );
					vertices.push( v3.x, v3.y, v3.z, v0.x, v0.y, v0.z, v2.x, v2.y, v2.z );

					const t = Math.random();
					const s = Math.random();
					n.copy( plane.normal );

					times.push( t, t, t ); times.push( t, t, t ); times.push( t, t, t ); times.push( t, t, t );
					seeds.push( s, s, s ); seeds.push( s, s, s ); seeds.push( s, s, s ); seeds.push( s, s, s );

					displaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );
					displaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );
					displaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );
					displaceNormal.push( n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z );

				}

				const newGeometry = new THREE.BufferGeometry();
				newGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
				newGeometry.setAttribute( 'time', new THREE.Float32BufferAttribute( times, 1 ) );
				newGeometry.setAttribute( 'seed', new THREE.Float32BufferAttribute( seeds, 1 ) );
				newGeometry.setAttribute( 'displaceNormal', new THREE.Float32BufferAttribute( displaceNormal, 3 ) );

				newGeometry.computeVertexNormals();

				return newGeometry;


			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_projector.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - projector light</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Projector Light</span>
			</div>

			<small>
				Projector light with procedural caustics, video and texture projection.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<video id="video" loop muted crossOrigin="anonymous" playsinline style="display:none">
			<source src="textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
			<source src="textures/sintel.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, color, mx_worley_noise_float, time } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let renderer, scene, camera;

			let projectorLight, lightHelper;

			init();

			function init() {

				// Renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 7, 4, 1 );

				// Controls

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI / 2;
				controls.target.set( 0, 1, 0 );
				controls.update();

				// Textures

				const loader = new THREE.TextureLoader().setPath( 'textures/' );

				// Lights

				const causticEffect = Fn( ( [ projectorUV ] ) => {

					const waterLayer0 = mx_worley_noise_float( projectorUV.mul( 10 ).add( time ) );

					const caustic = waterLayer0.mul( color( 0x5abcd8 ) ).mul( 2 );

					return caustic;

				} );


				const ambient = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 0.15 );
				scene.add( ambient );

				projectorLight = new THREE.ProjectorLight( 0xffffff, 100 );
				projectorLight.colorNode = causticEffect;
				projectorLight.position.set( 2.5, 5, 2.5 );
				projectorLight.angle = Math.PI / 6;
				projectorLight.penumbra = 1;
				projectorLight.decay = 2;
				projectorLight.distance = 0;

				projectorLight.castShadow = true;
				projectorLight.shadow.mapSize.width = 1024;
				projectorLight.shadow.mapSize.height = 1024;
				projectorLight.shadow.camera.near = 1;
				projectorLight.shadow.camera.far = 10;
				projectorLight.shadow.focus = 1;
				projectorLight.shadow.bias = - .003;
				scene.add( projectorLight );

				lightHelper = new THREE.SpotLightHelper( projectorLight );
				scene.add( lightHelper );

				//

				const geometry = new THREE.PlaneGeometry( 200, 200 );
				const material = new THREE.MeshLambertMaterial( { color: 0xbcbcbc } );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( 0, - 1, 0 );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				// Models

				new PLYLoader().load( 'models/ply/binary/Lucy100k.ply', function ( geometry ) {

					geometry.scale( 0.0024, 0.0024, 0.0024 );
					geometry.computeVertexNormals();

					const material = new THREE.MeshLambertMaterial();

					const mesh = new THREE.Mesh( geometry, material );
					mesh.rotation.y = - Math.PI / 2;
					mesh.position.y = 0.8;
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					scene.add( mesh );

				} );

				window.addEventListener( 'resize', onWindowResize );

				// GUI

				const gui = renderer.inspector.createParameters( 'Projector Light' );

				const params = {
					type: 'procedural',
					color: projectorLight.color.getHex(),
					intensity: projectorLight.intensity,
					distance: projectorLight.distance,
					angle: projectorLight.angle,
					penumbra: projectorLight.penumbra,
					decay: projectorLight.decay,
					focus: projectorLight.shadow.focus,
					shadows: true,
				};

				let videoTexture, mapTexture;

				gui.add( params, 'type', [ 'procedural', 'video', 'texture' ] ).onChange( function ( val ) {

					projectorLight.colorNode = null;
					projectorLight.map = null;

					if ( val === 'procedural' ) {

						projectorLight.colorNode = causticEffect;

						focus.setValue( 1 );

					} else if ( val === 'video' ) {

						if ( videoTexture === undefined ) {

							const video = document.getElementById( 'video' );
							video.play();

							videoTexture = new THREE.VideoTexture( video );
							videoTexture.colorSpace = THREE.SRGBColorSpace;

						}

						projectorLight.map = videoTexture;

						focus.setValue( .46 );

					} else if ( val === 'texture' ) {

						mapTexture = loader.load( 'colors.png' );
						mapTexture.minFilter = THREE.LinearFilter;
						mapTexture.magFilter = THREE.LinearFilter;
						mapTexture.generateMipmaps = false;
						mapTexture.colorSpace = THREE.SRGBColorSpace;

						projectorLight.map = mapTexture;

						focus.setValue( 1 );

					}

				} );

				gui.addColor( params, 'color' ).onChange( function ( val ) {

					projectorLight.color.setHex( val );

				} );

				gui.add( params, 'intensity', 0, 500 ).onChange( function ( val ) {

					projectorLight.intensity = val;

				} );


				gui.add( params, 'distance', 0, 20 ).onChange( function ( val ) {

					projectorLight.distance = val;

				} );

				gui.add( params, 'angle', 0, Math.PI / 3 ).onChange( function ( val ) {

					projectorLight.angle = val;

				} );

				gui.add( params, 'penumbra', 0, 1 ).onChange( function ( val ) {

					projectorLight.penumbra = val;

				} );

				gui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {

					projectorLight.decay = val;

				} );

				const focus = gui.add( params, 'focus', 0, 1 ).onChange( function ( val ) {

					projectorLight.shadow.focus = val;

				} );

				gui.add( params, 'shadows' ).onChange( function ( val ) {

					renderer.shadowMap.enabled = val;

					scene.traverse( function ( child ) {

						if ( child.material ) {

							child.material.needsUpdate = true;

						}

					} );

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = performance.now() / 3000;

				projectorLight.position.x = Math.cos( time ) * 2.5;
				projectorLight.position.z = Math.sin( time ) * 2.5;

				lightHelper.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_rectarealight.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - rect area light</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Rect Area Light</span>
			</div>

			<small>
				Rect area light by <a href="http://github.com/abelnation" target="_blank" rel="noopener">abelnation</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
			import { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';

			let renderer, scene, camera;
			let meshKnot;

			init();

			function init() {

				THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animation );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 5, - 15 );

				scene = new THREE.Scene();

				const rectLight1 = new THREE.RectAreaLight( 0xff0000, 5, 4, 10 );
				rectLight1.position.set( - 5, 5, 5 );
				scene.add( rectLight1 );

				const rectLight2 = new THREE.RectAreaLight( 0x00ff00, 5, 4, 10 );
				rectLight2.position.set( 0, 5, 5 );
				scene.add( rectLight2 );

				const rectLight3 = new THREE.RectAreaLight( 0x0000ff, 5, 4, 10 );
				rectLight3.position.set( 5, 5, 5 );
				scene.add( rectLight3 );

				scene.add( new RectAreaLightHelper( rectLight1 ) );
				scene.add( new RectAreaLightHelper( rectLight2 ) );
				scene.add( new RectAreaLightHelper( rectLight3 ) );

				const geoFloor = new THREE.BoxGeometry( 2000, 0.1, 2000 );
				const matStdFloor = new THREE.MeshStandardMaterial( { color: 0xbcbcbc, roughness: 0.1, metalness: 0 } );
				const mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );
				scene.add( mshStdFloor );

				const geoKnot = new THREE.TorusKnotGeometry( 1.5, 0.5, 200, 16 );
				const matKnot = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0, metalness: 0 } );
				meshKnot = new THREE.Mesh( geoKnot, matKnot );
				meshKnot.position.set( 0, 5, 0 );
				scene.add( meshKnot );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.copy( meshKnot.position );
				controls.update();

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = ( window.innerWidth / window.innerHeight );
				camera.updateProjectionMatrix();

			}

			function animation( time ) {

				meshKnot.rotation.y = time / 1000;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_selective.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - selective lights</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Selective Lights</span>
			</div>

			<small>
				<b style="color:red">Left: Red lights</b> - <b>Center: All lights</b> - <b style="color:blue">Right: blue light</b>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { fog, rangeFogFactor, color, lights, texture, normalMap } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';

			let camera, scene, renderer,
				light1, light2, light3, light4,
				controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.z = 7;

				scene = new THREE.Scene();
				scene.fogNode = fog( color( 0xFF00FF ), rangeFogFactor( 12, 30 ) );

				const sphereGeometry = new THREE.SphereGeometry( 0.1, 16, 8 );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const normalMapTexture = textureLoader.load( './textures/water/Water_1_M_Normal.jpg' );
				normalMapTexture.wrapS = THREE.RepeatWrapping;
				normalMapTexture.wrapT = THREE.RepeatWrapping;

				const alphaTexture = textureLoader.load( './textures/roughness_map.jpg' );
				alphaTexture.wrapS = THREE.RepeatWrapping;
				alphaTexture.wrapT = THREE.RepeatWrapping;

				// lights

				const addLight = ( hexColor, power = 1700, distance = 100 ) => {

					const material = new THREE.MeshStandardNodeMaterial();
					material.colorNode = color( hexColor );
					material.lights = false;

					const mesh = new THREE.Mesh( sphereGeometry, material );

					const light = new THREE.PointLight( hexColor, 1, distance );
					light.power = power;
					light.add( mesh );

					scene.add( light );

					return light;

				};

				light1 = addLight( 0xff0040 );
				light2 = addLight( 0x0040ff );
				light3 = addLight( 0x80ff80 );
				light4 = addLight( 0xffaa00 );

				// light nodes ( selective lights )

				const redLightsNode = lights( [ light1 ] );
				const blueLightsNode = lights( [ light2 ] );

				// models

				const geometryTeapot = new TeapotGeometry( .8, 18 );

				const leftObject = new THREE.Mesh( geometryTeapot, new THREE.MeshStandardNodeMaterial( { color: 0x555555 } ) );
				leftObject.material.lightsNode = redLightsNode;
				leftObject.material.roughnessNode = texture( alphaTexture );
				leftObject.material.metalness = 0;
				leftObject.position.x = - 3;
				scene.add( leftObject );

				const centerObject = new THREE.Mesh( geometryTeapot, new THREE.MeshStandardNodeMaterial( { color: 0x555555 } ) );
				centerObject.material.normalNode = normalMap( texture( normalMapTexture ) );
				centerObject.material.metalness = .5;
				centerObject.material.roughness = .5;
				scene.add( centerObject );

				const rightObject = new THREE.Mesh( geometryTeapot, new THREE.MeshStandardNodeMaterial( { color: 0x555555 } ) );
				rightObject.material.lightsNode = blueLightsNode;
				rightObject.material.metalnessNode = texture( alphaTexture );
				rightObject.position.x = 3;
				scene.add( rightObject );

				leftObject.rotation.y = centerObject.rotation.y = rightObject.rotation.y = Math.PI * - 0.5;
				leftObject.position.y = centerObject.position.y = rightObject.position.y = - 1;

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 3;
				controls.maxDistance = 25;

				// events

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = renderer.inspector.createParameters( 'Material' );

				gui.add( centerObject.material, 'roughness', 0, 1, 0.01 );
				gui.add( centerObject.material, 'metalness', 0, 1, 0.01 );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = performance.now() / 1000;
				const lightTime = time * 0.5;

				light1.position.x = Math.sin( lightTime * 0.7 ) * 3;
				light1.position.y = Math.cos( lightTime * 0.5 ) * 4;
				light1.position.z = Math.cos( lightTime * 0.3 ) * 3;

				light2.position.x = Math.cos( lightTime * 0.3 ) * 3;
				light2.position.y = Math.sin( lightTime * 0.5 ) * 4;
				light2.position.z = Math.sin( lightTime * 0.7 ) * 3;

				light3.position.x = Math.sin( lightTime * 0.7 ) * 3;
				light3.position.y = Math.cos( lightTime * 0.3 ) * 4;
				light3.position.z = Math.sin( lightTime * 0.5 ) * 3;

				light4.position.x = Math.sin( lightTime * 0.3 ) * 3;
				light4.position.y = Math.cos( lightTime * 0.7 ) * 4;
				light4.position.z = Math.sin( lightTime * 0.5 ) * 3;
				/*
				@TODO: Used to test scene light change ( currently unavailable )

				if ( time > 2.0 && light1.parent === null ) scene.add( light1 );
				if ( time > 2.5 && light2.parent === null ) scene.add( light2 );
				if ( time > 3.0 && light3.parent === null ) scene.add( light3 );
				if ( time > 3.5 && light4.parent === null ) scene.add( light4 );
				*/
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_spotlight.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - spotlight</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Spot Light</span>
			</div>

			<small>Spot light projecting texture map.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let renderer, scene, camera;

			let spotLight;

			init();

			function init() {

				// Renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				renderer.inspector = new Inspector();

				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1;

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 7, 4, 1 );

				// Controls

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI / 2;
				controls.target.set( 0, 1, 0 );
				controls.update();

				// Textures

				const loader = new THREE.TextureLoader().setPath( 'textures/' );
				const filenames = [ 'disturb.jpg', 'colors.png', 'uv_grid_opengl.jpg' ];

				const textures = { none: null };

				for ( let i = 0; i < filenames.length; i ++ ) {

					const filename = filenames[ i ];

					const texture = loader.load( filename );
					texture.minFilter = THREE.LinearFilter;
					texture.magFilter = THREE.LinearFilter;
					texture.generateMipmaps = false;
					texture.colorSpace = THREE.SRGBColorSpace;

					textures[ filename ] = texture;

				}

				// Lights

				const ambient = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 0.25 );
				scene.add( ambient );

				spotLight = new THREE.SpotLight( 0xffffff, 100 );
				spotLight.name = 'spotLight';
				spotLight.map = textures[ 'disturb.jpg' ];
				spotLight.position.set( 2.5, 5, 2.5 );
				spotLight.angle = Math.PI / 6;
				spotLight.penumbra = 1;
				spotLight.decay = 2;
				spotLight.distance = 0;

				spotLight.castShadow = true;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = 2;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.focus = 1;
				spotLight.shadow.bias = - .003;
				spotLight.shadow.intensity = 1;
				scene.add( spotLight );

				spotLight.lightHelper = new THREE.SpotLightHelper( spotLight );
				spotLight.lightHelper.visible = false;
				scene.add( spotLight.lightHelper );

				spotLight.shadowCameraHelper = new THREE.CameraHelper( spotLight.shadow.camera ); // colored lines
				spotLight.shadowCameraHelper.visible = false;
				scene.add( spotLight.shadowCameraHelper );

				//

				const geometry = new THREE.PlaneGeometry( 10, 10 );
				const material = new THREE.MeshLambertMaterial( { color: 0xbcbcbc } );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( 0, - 1, 0 );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				// Model

				new PLYLoader().load( 'models/ply/binary/Lucy100k.ply', function ( geometry ) {

					geometry.scale( 0.0024, 0.0024, 0.0024 );
					geometry.computeVertexNormals();

					const material = new THREE.MeshLambertMaterial();

					const mesh = new THREE.Mesh( geometry, material );
					mesh.rotation.y = - Math.PI / 2;
					mesh.position.y = 0.8;
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					scene.add( mesh );

				} );

				//

				window.addEventListener( 'resize', onWindowResize );

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );

				const params = {
					map: textures[ 'disturb.jpg' ],
					color: spotLight.color.getHex(),
					intensity: spotLight.intensity,
					distance: spotLight.distance,
					angle: spotLight.angle,
					penumbra: spotLight.penumbra,
					decay: spotLight.decay,
					focus: spotLight.shadow.focus,
					shadowIntensity: spotLight.shadow.intensity,
					helpers: false
				};

				gui.add( params, 'map', textures ).onChange( function ( val ) {

					spotLight.map = val;

				} );

				gui.addColor( params, 'color' ).onChange( function ( val ) {

					spotLight.color.setHex( val );

				} );

				gui.add( params, 'intensity', 0, 500 ).onChange( function ( val ) {

					spotLight.intensity = val;

				} );


				gui.add( params, 'distance', 0, 20 ).onChange( function ( val ) {

					spotLight.distance = val;

				} );

				gui.add( params, 'angle', 0, Math.PI / 3 ).onChange( function ( val ) {

					spotLight.angle = val;

				} );

				gui.add( params, 'penumbra', 0, 1 ).onChange( function ( val ) {

					spotLight.penumbra = val;

				} );

				gui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {

					spotLight.decay = val;

				} );

				gui.add( params, 'focus', 0, 1 ).onChange( function ( val ) {

					spotLight.shadow.focus = val;

				} );

				gui.add( params, 'shadowIntensity', 0, 1 ).onChange( function ( val ) {

					spotLight.shadow.intensity = val;

				} );

				gui.add( params, 'helpers' ).onChange( function ( val ) {

					spotLight.lightHelper.visible = val;
					spotLight.shadowCameraHelper.visible = val;

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = performance.now() / 3000;

				spotLight.position.x = Math.cos( time ) * 2.5;
				spotLight.position.z = Math.sin( time ) * 2.5;

				spotLight.lightHelper.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lights_tiled.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - tiled lighting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Tiled Lighting</span>
			</div>

			<small>
				Custom compute-based Tiled Lighting.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, uv, pass, normalMap, uniform } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { TiledLighting } from 'three/addons/lighting/TiledLighting.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let camera, scene, renderer,
				lights, lightDummy,
				controls,
				compose, tileInfluence,
				lighting,
				count,
				postProcessing;

			init();

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 600 );
				camera.position.z = 200;
				camera.position.y = 30;

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x111111, 300, 500 );
				scene.background = new THREE.Color( 0x111111 );

				count = 1000;

				const material = new THREE.MeshBasicMaterial();

				lightDummy = new THREE.InstancedMesh( new THREE.SphereGeometry( 0.1, 16, 8 ), material, count );
				lightDummy.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				scene.add( lightDummy );

				// lights

				lights = new THREE.Group();
				scene.add( lights );

				const addLight = ( hexColor, power = 10, distance = 3 ) => {

					const light = new THREE.PointLight( hexColor, 1, distance );
					light.position.set( Math.random() * 300 - 150, 1, Math.random() * 300 - 150 );
					light.power = power;
					light.userData.fixedPosition = light.position.clone();
					lights.add( light );

					return light;

				};

				const color = new THREE.Color();

				for ( let i = 0; i < count; i ++ ) {

					const hex = ( Math.random() * 0xffffff ) + 0x666666;

					lightDummy.setColorAt( i, color.setHex( hex ) );

					addLight( hex );

				}

				//

				const lightAmbient = new THREE.AmbientLight( 0xffffff, .1 );
				scene.add( lightAmbient );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const floorColor = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );
				floorColor.wrapS = THREE.RepeatWrapping;
				floorColor.wrapT = THREE.RepeatWrapping;
				floorColor.colorSpace = THREE.SRGBColorSpace;

				const floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );
				floorNormal.wrapS = THREE.RepeatWrapping;
				floorNormal.wrapT = THREE.RepeatWrapping;

				const uvTile = uv().mul( 50 );

				const planeGeometry = new THREE.PlaneGeometry( 1000, 1000 );
				const planeMaterial = new THREE.MeshPhongNodeMaterial( {
					colorNode: texture( floorColor, uvTile ),
					normalNode: normalMap( texture( floorNormal, uvTile ) ),
				} );

				const ground = new THREE.Mesh( planeGeometry, planeMaterial );
				ground.rotation.x = - Math.PI / 2;
				ground.position.y = 0;
				ground.castShadow = true;
				ground.receiveShadow = true;
				scene.add( ground );

				// renderer

				lighting = new TiledLighting(); // ( maxLights = 1024, tileSize = 32 )

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.lighting = lighting; // set lighting system
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 5;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxDistance = 400;

				// events

				window.addEventListener( 'resize', onWindowResize );

				// post processing

				const scenePass = pass( scene, camera );
				const bloomPass = bloom( scenePass, 3, .9, .2 );

				// compose

				compose = scenePass.add( bloomPass );
				tileInfluence = uniform( 0 );

				postProcessing = new THREE.PostProcessing( renderer );

				updatePostProcessing();

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( tileInfluence, 'value', 0, 1 ).name( 'tile indexes debug' );

			}

			function updatePostProcessing() {

				// tile indexes debug, needs to be updated every time the renderer size changes

				const debugBlockIndexes = lighting.getNode( scene, camera ).setSize( window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio ).getBlock().toColor().div( count * 2 );

				postProcessing.outputNode = compose.add( debugBlockIndexes.mul( tileInfluence ) );
				postProcessing.needsUpdate = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				updatePostProcessing();

			}

			function animate() {

				const time = performance.now() / 1000;

				for ( let i = 0; i < lights.children.length; i ++ ) {

					const light = lights.children[ i ];
					const lightTime = ( time * 0.5 ) + light.id;

					light.position.copy( light.userData.fixedPosition );
					light.position.x += Math.sin( lightTime * 0.7 ) * 3;
					light.position.y += Math.cos( lightTime * 0.5 ) * .5;
					light.position.z += Math.cos( lightTime * 0.3 ) * 3;

					lightDummy.setMatrixAt( i, light.matrixWorld );

				}

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lines_fat.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - fat lines</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>

		<div id="container"></div>

		<div id="info"><a href="https://threejs.org" target="_blank">three.js</a> - fat lines</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color } from 'three/tsl';

			import Stats from 'three/addons/libs/stats.module.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Line2 } from 'three/addons/lines/webgpu/Line2.js';
			import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
			import * as GeometryUtils from 'three/addons/utils/GeometryUtils.js';

			let line, renderer, scene, camera, camera2, controls, backgroundNode;
			let line1;
			let matLine, matLineBasic, matLineDashed;
			let stats;
			let gui;

			// viewport
			let insetWidth;
			let insetHeight;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setClearColor( 0x000000, 0.0 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( - 40, 0, 60 );

				camera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );
				camera2.position.copy( camera.position );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 10;
				controls.maxDistance = 500;

				backgroundNode = color( 0x222222 );

				// Position and THREE.Color Data

				const positions = [];
				const colors = [];

				const points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );

				const spline = new THREE.CatmullRomCurve3( points );
				const divisions = Math.round( 12 * points.length );
				const point = new THREE.Vector3();
				const lineColor = new THREE.Color();

				for ( let i = 0, l = divisions; i < l; i ++ ) {

					const t = i / l;

					spline.getPoint( t, point );
					positions.push( point.x, point.y, point.z );

					lineColor.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );
					colors.push( lineColor.r, lineColor.g, lineColor.b );

				}


				// Line2 ( LineGeometry, LineMaterial )

				const geometry = new LineGeometry();
				geometry.setPositions( positions );
				geometry.setColors( colors );

				matLine = new THREE.Line2NodeMaterial( {

					color: 0xffffff,
					linewidth: 5, // in world units with size attenuation, pixels otherwise
					vertexColors: true,
					dashed: false,
					alphaToCoverage: true,

				} );

				line = new Line2( geometry, matLine );
				line.computeLineDistances();
				line.scale.set( 1, 1, 1 );
				scene.add( line );

				const geo = new THREE.BufferGeometry();
				geo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				matLineBasic = new THREE.LineBasicNodeMaterial( { vertexColors: true } );
				matLineDashed = new THREE.LineDashedNodeMaterial( { vertexColors: true, scale: 2, dashSize: 1, gapSize: 1 } );

				line1 = new THREE.Line( geo, matLineBasic );
				line1.computeLineDistances();
				line1.visible = false;
				scene.add( line1 );

				//

				window.addEventListener( 'resize', onWindowResize );
				onWindowResize();

				stats = new Stats();
				document.body.appendChild( stats.dom );

				initGui();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				insetWidth = window.innerHeight / 4; // square
				insetHeight = window.innerHeight / 4;

				camera2.aspect = insetWidth / insetHeight;
				camera2.updateProjectionMatrix();

			}

			function animate() {

				stats.update();

				// main scene

				renderer.setClearColor( 0x000000, 0 );

				renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

				controls.update();

				renderer.autoClear = true;

				scene.backgroundNode = null;
				renderer.render( scene, camera );

				// inset scene

				const posY = window.innerHeight - insetHeight - 20;

				renderer.clearDepth(); // important!

				renderer.setScissorTest( true );

				renderer.setScissor( 20, posY, insetWidth, insetHeight );

				renderer.setViewport( 20, posY, insetWidth, insetHeight );

				camera2.position.copy( camera.position );
				camera2.quaternion.copy( camera.quaternion );

				renderer.autoClear = false;

				scene.backgroundNode = backgroundNode;
				renderer.render( scene, camera2 );

				renderer.setScissorTest( false );

			}

			//

			function initGui() {

				gui = new GUI();

				const param = {
					'line type': 0,
					'world units': false,
					'width': 5,
					'alphaToCoverage': true,
					'dashed': false,
					'dash offset': 0,
					'dash scale': 1,
					'dash / gap': 1
				};

				gui.add( param, 'line type', { 'LineGeometry': 0, '"line-strip"': 1 } ).onChange( function ( val ) {

					switch ( val ) {

						case 0:
							line.visible = true;

							line1.visible = false;

							break;

						case 1:
							line.visible = false;

							line1.visible = true;

							break;

					}

				} );

				gui.add( param, 'world units' ).onChange( function ( val ) {

					matLine.worldUnits = val;
					matLine.needsUpdate = true;

				} );

				gui.add( param, 'width', 1, 10 ).onChange( function ( val ) {

					matLine.linewidth = val;

				} );

				gui.add( param, 'alphaToCoverage' ).onChange( function ( val ) {

					matLine.alphaToCoverage = val;

				} );

				gui.add( param, 'dashed' ).onChange( function ( val ) {

					matLine.dashed = val;
					line1.material = val ? matLineDashed : matLineBasic;

				} );

				gui.add( param, 'dash scale', 0.5, 2, 0.1 ).onChange( function ( val ) {

					matLine.scale = val;
					matLineDashed.scale = val;

				} );

				gui.add( param, 'dash offset', 0, 5, 0.1 ).onChange( function ( val ) {

					matLine.dashOffset = val;
					matLineDashed.dashOffset = val;

				} );

				gui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {

					switch ( val ) {

						case 0:
							matLine.dashSize = 2;
							matLine.gapSize = 1;

							matLineDashed.dashSize = 2;
							matLineDashed.gapSize = 1;

							break;

						case 1:
							matLine.dashSize = 1;
							matLine.gapSize = 1;

							matLineDashed.dashSize = 1;
							matLineDashed.gapSize = 1;

							break;

						case 2:
							matLine.dashSize = 1;
							matLine.gapSize = 2;

							matLineDashed.dashSize = 1;
							matLineDashed.gapSize = 2;

							break;

					}

				} );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lines_fat_raycasting.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - fat lines</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Fat Lines</span>
			</div>

			<small>
				Raycasting on fat lines. Move mouse to test raycasting.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { LineSegments2 } from 'three/addons/lines/webgpu/LineSegments2.js';
			import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';
			import { Line2 } from 'three/addons/lines/webgpu/Line2.js';
			import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

			//

			let line, thresholdLine, segments, thresholdSegments;
			let renderer, scene, camera, controls;
			let sphereInter, sphereOnLine;
			let gui;
			let clock;

			const color = new THREE.Color();

			const pointer = new THREE.Vector2( Infinity, Infinity );

			const raycaster = new THREE.Raycaster();

			raycaster.params.Line2 = {};
			raycaster.params.Line2.threshold = 0;

			const matLine = new THREE.Line2NodeMaterial( {

				color: 0xffffff,
				linewidth: 1, // in world units with size attenuation, pixels otherwise
				worldUnits: true,
				vertexColors: true,

				alphaToCoverage: true,

			} );

			const matThresholdLine = new THREE.Line2NodeMaterial( {

				color: 0xffffff,
				linewidth: matLine.linewidth, // in world units with size attenuation, pixels otherwise
				worldUnits: true,
				// vertexColors: true,
				transparent: true,
				opacity: 0.2,
				depthTest: false,
				visible: false,

			} );

			const params = {

				'line type': 1,
				'world units': matLine.worldUnits,
				'visualize threshold': matThresholdLine.visible,
				'width': matLine.linewidth,
				'alphaToCoverage': matLine.alphaToCoverage,
				'threshold': raycaster.params.Line2.threshold,
				'translation': 0,
				'animate': true

			};

			init();

			function init() {

				clock = new THREE.Clock();

				renderer = new THREE.WebGPURenderer( { antialias: true, alpha: true, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 0.0 );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( - 40, 0, 60 );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 10;
				controls.maxDistance = 500;

				const sphereGeometry = new THREE.SphereGeometry( 0.25, 8, 4 );
				const sphereInterMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, depthTest: false } );
				const sphereOnLineMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, depthTest: false } );

				sphereInter = new THREE.Mesh( sphereGeometry, sphereInterMaterial );
				sphereOnLine = new THREE.Mesh( sphereGeometry, sphereOnLineMaterial );
				sphereInter.visible = false;
				sphereOnLine.visible = false;
				sphereInter.renderOrder = 10;
				sphereOnLine.renderOrder = 10;
				scene.add( sphereInter );
				scene.add( sphereOnLine );

				// Position and THREE.Color Data

				const positions = [];
				const colors = [];
				const points = [];
				for ( let i = - 50; i < 50; i ++ ) {

					const t = i / 3;
					points.push( new THREE.Vector3( t * Math.sin( 2 * t ), t, t * Math.cos( 2 * t ) ) );

				}

				const spline = new THREE.CatmullRomCurve3( points );
				const divisions = Math.round( 3 * points.length );
				const point = new THREE.Vector3();
				const color = new THREE.Color();

				for ( let i = 0, l = divisions; i < l; i ++ ) {

					const t = i / l;

					spline.getPoint( t, point );
					positions.push( point.x, point.y, point.z );

					color.setHSL( t, 1.0, 0.5, THREE.SRGBColorSpace );
					colors.push( color.r, color.g, color.b );

				}

				const lineGeometry = new LineGeometry();
				lineGeometry.setPositions( positions );
				lineGeometry.setColors( colors );

				const segmentsGeometry = new LineSegmentsGeometry();
				segmentsGeometry.setPositions( positions );
				segmentsGeometry.setColors( colors );

				segments = new LineSegments2( segmentsGeometry, matLine );
				segments.computeLineDistances();
				segments.scale.set( 1, 1, 1 );
				scene.add( segments );

				thresholdSegments = new LineSegments2( segmentsGeometry, matThresholdLine );
				thresholdSegments.computeLineDistances();
				thresholdSegments.scale.set( 1, 1, 1 );
				scene.add( thresholdSegments );

				line = new Line2( lineGeometry, matLine );
				line.computeLineDistances();
				line.scale.set( 1, 1, 1 );
				scene.add( line );

				thresholdLine = new Line2( lineGeometry, matThresholdLine );
				thresholdLine.computeLineDistances();
				thresholdLine.scale.set( 1, 1, 1 );
				scene.add( thresholdLine );

				const geo = new THREE.BufferGeometry();
				geo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				//

				switchLine( params[ 'line type' ] );

				//

				document.addEventListener( 'pointermove', onPointerMove );
				window.addEventListener( 'resize', onWindowResize );
				onWindowResize();

				initGui();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			async function animate() {

				const delta = clock.getDelta();

				const obj = line.visible ? line : segments;
				thresholdLine.position.copy( line.position );
				thresholdLine.quaternion.copy( line.quaternion );
				thresholdSegments.position.copy( segments.position );
				thresholdSegments.quaternion.copy( segments.quaternion );

				if ( params.animate ) {

					line.rotation.y += delta * 0.1;

					segments.rotation.y = line.rotation.y;

				}

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObject( obj );

				if ( intersects.length > 0 ) {

					sphereInter.visible = true;
					sphereOnLine.visible = true;

					sphereInter.position.copy( intersects[ 0 ].point );
					sphereOnLine.position.copy( intersects[ 0 ].pointOnLine );

					const index = intersects[ 0 ].faceIndex;
					const colors = obj.geometry.getAttribute( 'instanceColorStart' );

					color.fromBufferAttribute( colors, index );

					sphereInter.material.color.copy( color ).offsetHSL( 0.3, 0, 0 );
					sphereOnLine.material.color.copy( color ).offsetHSL( 0.7, 0, 0 );

					renderer.domElement.style.cursor = 'crosshair';

				} else {

					sphereInter.visible = false;
					sphereOnLine.visible = false;
					renderer.domElement.style.cursor = '';

				}

				renderer.render( scene, camera );

			}

			//

			function switchLine( val ) {

				switch ( val ) {

					case 0:
						line.visible = true;
						thresholdLine.visible = true;

						segments.visible = false;
						thresholdSegments.visible = false;

						break;

					case 1:
						line.visible = false;
						thresholdLine.visible = false;

						segments.visible = true;
						thresholdSegments.visible = true;

						break;

				}

			}

			function initGui() {

				gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( params, 'line type', { 'LineGeometry': 0, 'LineSegmentsGeometry': 1 } ).onChange( function ( val ) {

					switchLine( val );

				} );

				gui.add( params, 'world units' ).onChange( function ( val ) {

					matLine.worldUnits = val;
					matLine.needsUpdate = true;

					matThresholdLine.worldUnits = val;
					matThresholdLine.needsUpdate = true;

				} );

				gui.add( params, 'visualize threshold' ).onChange( function ( val ) {

					matThresholdLine.visible = val;

				} );

				gui.add( params, 'width', 1, 10 ).onChange( function ( val ) {

					matLine.linewidth = val;
					matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;

				} );

				gui.add( params, 'alphaToCoverage' ).onChange( function ( val ) {

					matLine.alphaToCoverage = val;

				} );

				gui.add( params, 'threshold', 0, 10 ).onChange( function ( val ) {

					raycaster.params.Line2.threshold = val;
					matThresholdLine.linewidth = matLine.linewidth + raycaster.params.Line2.threshold;

				} );

				gui.add( params, 'translation', 0, 10 ).onChange( function ( val ) {

					line.position.x = val;
					segments.position.x = val;

				} );

				gui.add( params, 'animate' );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_lines_fat_wireframe.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - fat wireframe</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Fat Lines</span>
			</div>

			<small>
				Wireframe rendering of fat lines.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Wireframe } from 'three/addons/lines/webgpu/Wireframe.js';
			import { WireframeGeometry2 } from 'three/addons/lines/WireframeGeometry2.js';

			let wireframe, renderer, scene, camera, camera2, controls, backgroundNode;
			let wireframe1;
			let matLine, matLineBasic, matLineDashed;
			let gui;

			// viewport
			let insetWidth;
			let insetHeight;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 0.0 );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( - 50, 0, 50 );

				camera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );
				camera2.position.copy( camera.position );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 10;
				controls.maxDistance = 500;

				backgroundNode = color( 0x222222 );

				// Wireframe ( WireframeGeometry2, Line2NodeMaterial )

				let geo = new THREE.IcosahedronGeometry( 20, 1 );

				const geometry = new WireframeGeometry2( geo );

				matLine = new THREE.Line2NodeMaterial( {

					color: 0x4080ff,
					linewidth: 5, // in world units with size attenuation, pixels otherwise
					dashed: false

				} );

				wireframe = new Wireframe( geometry, matLine );
				wireframe.computeLineDistances();
				wireframe.scale.set( 1, 1, 1 );
				scene.add( wireframe );

				// Line ( THREE.WireframeGeometry, THREE.LineBasicMaterial ) - rendered with gl.LINE

				geo = new THREE.WireframeGeometry( geo );

				matLineBasic = new THREE.LineBasicMaterial( { color: 0x4080ff } );
				matLineDashed = new THREE.LineDashedMaterial( { scale: 2, dashSize: 1, gapSize: 1 } );

				wireframe1 = new THREE.LineSegments( geo, matLineBasic );
				wireframe1.computeLineDistances();
				wireframe1.visible = false;
				scene.add( wireframe1 );

				//

				window.addEventListener( 'resize', onWindowResize );
				onWindowResize();

				initGui();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				insetWidth = window.innerHeight / 4; // square
				insetHeight = window.innerHeight / 4;

				camera2.aspect = insetWidth / insetHeight;
				camera2.updateProjectionMatrix();

			}

			function animate() {

				// main scene

				renderer.setClearColor( 0x000000, 0 );

				renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

				renderer.autoClear = true;

				scene.backgroundNode = null;

				scene.name = 'Scene';

				renderer.render( scene, camera );

				// inset scene

				const posY = window.innerHeight - insetHeight - 20;

				renderer.clearDepth(); // important!

				renderer.setScissorTest( true );

				renderer.setScissor( 20, posY, insetWidth, insetHeight );

				renderer.setViewport( 20, posY, insetWidth, insetHeight );

				camera2.position.copy( camera.position );
				camera2.quaternion.copy( camera.quaternion );

				renderer.autoClear = false;

				scene.backgroundNode = backgroundNode;

				scene.name = 'Scene [ Scissor ]';

				renderer.render( scene, camera2 );

				renderer.setScissorTest( false );

			}

			//

			function initGui() {

				gui = renderer.inspector.createParameters( 'Settings' );

				const param = {
					'line type': 0,
					'width (px)': 5,
					'dashed': false,
					'dash scale': 1,
					'dash / gap': 1
				};


				gui.add( param, 'line type', { 'LineGeometry': 0, 'gl.LINE': 1 } ).onChange( function ( val ) {

					switch ( val ) {

						case 0:
							wireframe.visible = true;

							wireframe1.visible = false;

							break;

						case 1:
							wireframe.visible = false;

							wireframe1.visible = true;

							break;

					}

				} );

				gui.add( param, 'width (px)', 1, 10 ).onChange( function ( val ) {

					matLine.linewidth = val;

				} );

				gui.add( param, 'dashed' ).onChange( function ( val ) {

					matLine.dashed = val;
					wireframe1.material = val ? matLineDashed : matLineBasic;

				} );

				gui.add( param, 'dash scale', 0.5, 1, 0.1 ).onChange( function ( val ) {

					matLine.scale = val;
					matLineDashed.scale = val;

				} );

				gui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {

					switch ( val ) {

						case 0:
							matLine.dashSize = 2;
							matLine.gapSize = 1;

							matLineDashed.dashSize = 2;
							matLineDashed.gapSize = 1;

							break;

						case 1:
							matLine.dashSize = 1;
							matLine.gapSize = 1;

							matLineDashed.dashSize = 1;
							matLineDashed.gapSize = 1;

							break;

						case 2:
							matLine.dashSize = 1;
							matLine.gapSize = 2;

							matLineDashed.dashSize = 1;
							matLineDashed.gapSize = 2;

							break;

					}

				} );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_gltf.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - gltf loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>glTF Loader</span>
			</div>

			<small>
				Battle Damaged Sci-fi Helmet by
				<a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a><br />
				<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> by <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;

			init().then( render );

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, 0.6, 2.7 );

				scene = new THREE.Scene();

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;
						//texture.minFilter = THREE.LinearMipmapLinearFilter;
						//texture.generateMipmaps = true;

						scene.background = texture;
						scene.environment = texture;

					} );

				const loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
				loader.load( 'DamagedHelmet.gltf', function ( gltf ) {

					scene.add( gltf.scene );

				} );

				renderer = new THREE.WebGPURenderer( { antialias: true/*, compatibilityMode: true*/ } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				container.appendChild( renderer.domElement );

				await renderer.init();

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.target.set( 0, 0, - 0.2 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_gltf_anisotropy.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - glTF + anisotropy</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>glTF + Anisotropy</span>
			</div>

			<small>
				<a href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy" target="_blank" rel="noopener">KHR_materials_anisotropy</a>
				Anisotropy Barn Lamp from <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/AnisotropyBarnLamp" target="_blank" rel="noopener">glTF-Sample-Models</a><br />
				<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> from <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			let renderer, scene, camera, controls;

			init();

			async function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.35;
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( - 0.35, - 0.2, 0.35 );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, - 0.08, 0.11 );
				controls.minDistance = 0.1;
				controls.maxDistance = 2;
				controls.update();

				const hdrLoader = new HDRLoader().setPath( 'textures/equirectangular/' );
				const gltfLoader = new GLTFLoader().setPath( 'models/gltf/' );

				const [ texture, gltf ] = await Promise.all( [
					hdrLoader.loadAsync( 'royal_esplanade_1k.hdr' ),
					gltfLoader.loadAsync( 'AnisotropyBarnLamp.glb' ),
				] );

				// environment

				texture.mapping = THREE.EquirectangularReflectionMapping;

				scene.background = texture;
				scene.backgroundBlurriness = 0.5;
				scene.environment = texture;

				// model

				scene.add( gltf.scene );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_gltf_compressed.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - glTF + compressed</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>glTF + Compression Extensions</span>
			</div>

			<small>
				glTF model loading with KTX2/Basis and Meshopt compression extensions.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
			import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 20 );
				camera.position.set( 2, 2, 2 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xEEEEEE );

				//lights

				const light = new THREE.PointLight( 0xffffff );
				light.power = 1300;
				camera.add( light );
				scene.add( camera );

				//renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 1;
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 3;
				controls.maxDistance = 6;
				controls.update();

				const ktx2Loader = await new KTX2Loader()
					.setTranscoderPath( 'jsm/libs/basis/' )
					.detectSupport( renderer );

				const loader = new GLTFLoader();
				loader.setKTX2Loader( ktx2Loader );
				loader.setMeshoptDecoder( MeshoptDecoder );
				loader.load( 'models/gltf/coffeemat.glb', function ( gltf ) {

					const gltfScene = gltf.scene;
					gltfScene.position.y = - .8;
					gltfScene.scale.setScalar( .01 );

					scene.add( gltfScene );

				} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_gltf_dispersion.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - glTF + dispersion</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>glTF + Dispersion</span>
			</div>

			<small>
				<a href="https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion" target="_blank" rel="noopener">KHR_materials_dispersion</a> HDR by <a href="https://polyhaven.com/a/studio_small_08" target="_blank" rel="noopener">Poly Haven</a> 
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			let camera, scene, renderer;

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 5 );
				camera.position.set( 0.1, 0.05, 0.15 );

				scene = new THREE.Scene();

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ReinhardToneMapping; // TODO: Add THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1;
				container.appendChild( renderer.domElement );

				const hdrTexture = await new HDRLoader().setPath( 'textures/equirectangular/' ).loadAsync( 'pedestrian_overpass_1k.hdr' );
				hdrTexture.mapping = THREE.EquirectangularReflectionMapping;

				scene = new THREE.Scene();
				scene.backgroundBlurriness = 0.5;
				scene.environment = hdrTexture;
				scene.background = hdrTexture;

				const loader = new GLTFLoader();
				const gltf = await loader.loadAsync( 'models/gltf/DispersionTest.glb' );

				scene.add( gltf.scene );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 0.1;
				controls.maxDistance = 10;
				controls.target.set( 0, 0, 0 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_gltf_iridescence.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - glTF + iridescence</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>glTF + Iridescence</span>
			</div>

			<small>
				<a href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence" target="_blank" rel="noopener">KHR_materials_iridescence</a> Iridescence Lamp from <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/IridescenceLamp" target="_blank" rel="noopener">glTF-Sample-Models</a><br />
				<a href="https://hdrihaven.com/hdri/?h=venice_sunset" target="_blank" rel="noopener">Venice Sunset</a> from <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			let renderer, scene, camera, controls;

			init().catch( function ( err ) {

				console.error( err );

			} );

			async function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setAnimationLoop( render );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.05, 20 );
				camera.position.set( 0.35, 0.05, 0.35 );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.autoRotate = true;
				controls.autoRotateSpeed = - 0.5;
				controls.target.set( 0, 0.2, 0 );
				controls.update();

				const hdrLoader = new HDRLoader()
					.setPath( 'textures/equirectangular/' );

				const gltfLoader = new GLTFLoader().setPath( 'models/gltf/' );

				const [ texture, gltf ] = await Promise.all( [
					hdrLoader.loadAsync( 'venice_sunset_1k.hdr' ),
					gltfLoader.loadAsync( 'IridescenceLamp.glb' ),
				] );

				// environment

				texture.mapping = THREE.EquirectangularReflectionMapping;

				scene.background = texture;
				scene.environment = texture;

				// model

				scene.add( gltf.scene );

				render();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function render() {

				controls.update();
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_gltf_sheen.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - sheen</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			body {
				background: #bbbbbb;
			}
		</style>
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>glTF + Anisotropy</span>
			</div>

			<small>
				<a href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen" target="_blank" rel="noopener">KHR_materials_sheen</a> Sheen Chair from <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/SheenChair" target="_blank" rel="noopener">glTF-Sample-Models</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, controls;

			init();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 20 );
				camera.position.set( - 0.75, 0.7, 1.25 );

				scene = new THREE.Scene();
				//scene.add( new THREE.DirectionalLight( 0xffffff, 2 ) );

				// model

				new GLTFLoader()
					.setPath( 'models/gltf/' )
					.load( 'SheenChair.glb', function ( gltf ) {

						scene.add( gltf.scene );

						const object = gltf.scene.getObjectByName( 'SheenChair_fabric' );

						const gui = renderer.inspector.createParameters( 'SheenChair_fabric' );

						gui.add( object.material, 'sheen', 0, 1 );

					} );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				scene.background = new THREE.Color( 0xAAAAAA );

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.background = texture;
						//scene.backgroundBlurriness = 1; // @TODO: Needs PMREM
						scene.environment = texture;

					} );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.target.set( 0, 0.35, 0 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				controls.update(); // required if damping enabled

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_gltf_transmission.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - glTF + transmission</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>glTF + Transmission</span>
			</div>

			<small>
				<a href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission" target="_blank" rel="noopener">KHR_materials_transmission</a> Iridescent Dish With Olives by <a href="https://github.com/echadwick-wayfair" target="_blank" rel="noopener">Eric Chadwick</a><br />
				<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> from <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

			let camera, scene, renderer, controls, clock, mixer;

			init();

			function init() {

				clock = new THREE.Clock();

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 0, 0.4, 0.7 );

				scene = new THREE.Scene();

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.background = texture;
						scene.backgroundBlurriness = 0.35;

						scene.environment = texture;

						// model

						new GLTFLoader()
							.setPath( 'models/gltf/' )
							.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) )
							.load( 'IridescentDishWithOlives.glb', function ( gltf ) {

								mixer = new THREE.AnimationMixer( gltf.scene );
								mixer.clipAction( gltf.animations[ 0 ] ).play();

								scene.add( gltf.scene );

							} );

					} );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setAnimationLoop( render );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.autoRotate = true;
				controls.autoRotateSpeed = - 0.75;
				controls.enableDamping = true;
				controls.minDistance = 0.5;
				controls.maxDistance = 1;
				controls.target.set( 0, 0.1, 0 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				if ( mixer ) mixer.update( clock.getDelta() );

				controls.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_materialx.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - materialx loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			.dg .property-name {
				width: 20% !important;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>MaterialX Loader</span>
			</div>

			<small>
				MaterialX Standard Surface loader.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Fn, length, fract, vec4, positionWorld, smoothstep, max, abs, float, fwidth } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { MaterialXLoader } from 'three/addons/loaders/MaterialXLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			const SAMPLE_PATH = 'https://raw.githubusercontent.com/materialx/MaterialX/main/resources/Materials/Examples/StandardSurface/';
			const LOCAL_SAMPLE_PATH = 'materialx/';
			const samples = [
				'standard_surface_brass_tiled.mtlx',
				'standard_surface_brick_procedural.mtlx',
				'standard_surface_carpaint.mtlx',
				//'standard_surface_chess_set.mtlx',
				'standard_surface_chrome.mtlx',
				'standard_surface_copper.mtlx',
				//'standard_surface_default.mtlx',
				//'standard_surface_glass.mtlx',
				//'standard_surface_glass_tinted.mtlx',
				'standard_surface_gold.mtlx',
				//'standard_surface_greysphere.mtlx',
				//'standard_surface_greysphere_calibration.mtlx',
				'standard_surface_jade.mtlx',
				//'standard_surface_look_brass_tiled.mtlx',
				//'standard_surface_look_wood_tiled.mtlx',
				'standard_surface_marble_solid.mtlx',
				'standard_surface_metal_brushed.mtlx',
				'standard_surface_plastic.mtlx',
				//'standard_surface_thin_film.mtlx',
				'standard_surface_velvet.mtlx',
				'standard_surface_wood_tiled.mtlx'
			];

			const localSamples = [
				'heightnormal.mtlx',
				'conditional_if_float.mtlx',
				'image_transform.mtlx',
				'color3_vec3_cm_test.mtlx',
				'rotate2d_test.mtlx',
				'rotate3d_test.mtlx',
				'heighttonormal_normal_input.mtlx',
				'roughness_test.mtlx',
				'opacity_test.mtlx',
				'opacity_only_test.mtlx',
				'specular_test.mtlx',
				'ior_test.mtlx',
				'combined_test.mtlx',
				'texture_opacity_test.mtlx',
				'transmission_test.mtlx',
				'transmission_only_test.mtlx',
				'transmission_rough.mtlx',
				'thin_film_rainbow_test.mtlx',
				'thin_film_ior_clamp_test.mtlx',
				'sheen_test.mtlx',
			];

			let camera, scene, renderer;
			let controls, prefab;
			const models = [];

			init();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.toneMappingExposure = .5;
				renderer.inspector = new Inspector();
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 200 );
				camera.position.set( 10, 10, 20 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );

				// Ground plane

				const material = new THREE.MeshBasicNodeMaterial();

				const gridXZ = Fn( ( [ gridSize = float( 1.0 ), dotWidth = float( 0.1 ), lineWidth = float( 0.02 ) ] ) => {

					const coord = positionWorld.xz.div( gridSize );
					const grid = fract( coord );

					// Screen-space derivative for automatic antialiasing
					const fw = fwidth( coord );
					const smoothing = max( fw.x, fw.y ).mul( 0.5 );

					// Create squares at cell centers
					const squareDist = max( abs( grid.x.sub( 0.5 ) ), abs( grid.y.sub( 0.5 ) ) );
					const dots = smoothstep( dotWidth.add( smoothing ), dotWidth.sub( smoothing ), squareDist );

					// Create grid lines
					const lineX = smoothstep( lineWidth.add( smoothing ), lineWidth.sub( smoothing ), abs( grid.x.sub( 0.5 ) ) );
					const lineZ = smoothstep( lineWidth.add( smoothing ), lineWidth.sub( smoothing ), abs( grid.y.sub( 0.5 ) ) );
					const lines = max( lineX, lineZ );

					return max( dots, lines );

				} );

				const radialGradient = Fn( ( [ radius = float( 10.0 ), falloff = float( 1.0 ) ] ) => {

					return smoothstep( radius, radius.sub( falloff ), length( positionWorld ) );

				} );

				// Create grid pattern
				const gridPattern = gridXZ( 1.0, 0.03, 0.005 );
				const baseColor = vec4( 1.0, 1.0, 1.0, 0.0 );
				const gridColor = vec4( 0.5, 0.5, 0.5, 1.0 );

				// Mix base color with grid lines
				material.colorNode = gridPattern.mix( baseColor, gridColor ).mul( radialGradient( 30.0, 20.0 ) );
				material.transparent = true;

				const plane = new THREE.Mesh( new THREE.CircleGeometry( 40 ), material );
				plane.rotation.x = - Math.PI / 2;
				plane.renderOrder = - 1;
				scene.add( plane );

				//

				controls = new OrbitControls( camera );
				controls.connect( renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 2;
				controls.maxDistance = 40;

				//

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'san_giuseppe_bridge_2k.hdr', async ( texture ) => {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.environment = texture;

						prefab = ( await new GLTFLoader().loadAsync( './models/gltf/ShaderBall.glb' ) ).scene;

						for ( const sample of samples ) {

							await addSample( sample, SAMPLE_PATH );

						}

						for ( const sample of localSamples ) {

							await addSample( sample, LOCAL_SAMPLE_PATH );

						}

						addGUI();

					} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function updateModelsAlign() {

				const COLUMN_COUNT = 6;
				const DIST_X = 3;
				const DIST_Z = 3;

				const lineCount = Math.floor( models.length / COLUMN_COUNT ) - 1.5;

				const offsetX = ( DIST_X * ( COLUMN_COUNT - 1 ) ) * - .5;
				const offsetZ = ( DIST_Z * lineCount ) * .5;

				for ( let i = 0; i < models.length; i ++ ) {

					const model = models[ i ];

					model.position.x = ( ( i % COLUMN_COUNT ) * DIST_X ) + offsetX;
					model.position.z = ( Math.floor( i / COLUMN_COUNT ) * - DIST_Z ) + offsetZ;

				}

			}

			async function addSample( sample, path ) {

				const model = prefab.clone();

				models.push( model );

				scene.add( model );

				updateModelsAlign();

				//

				const material = await new MaterialXLoader()
					.setPath( path )
					.loadAsync( sample )
					.then( ( { materials } ) => Object.values( materials ).pop() );

				const calibrationMesh = model.getObjectByName( 'Calibration_Mesh' );
				calibrationMesh.material = material;

				const previewMesh = model.getObjectByName( 'Preview_Mesh' );
				previewMesh.material = material;

				if ( material.transparent ) {

					calibrationMesh.renderOrder = 1;
					previewMesh.renderOrder = 2;

				}

			}

			function addGUI() {

				const gui = renderer.inspector.createParameters( 'MaterialX Loader' );

				const API = {
					showCalibrationMesh: true,
					showPreviewMesh: true
				};

				gui.add( API, 'showCalibrationMesh' )
					.name( 'Calibration Mesh' )
					.onChange( function ( value ) {

						setVisibility( 'Calibration_Mesh', value );

					} );

				gui.add( API, 'showPreviewMesh' )
					.name( 'Preview Mesh' )
					.onChange( function ( value ) {

						setVisibility( 'Preview_Mesh', value );

					} );

			}

			function setVisibility( name, visible ) {

				scene.traverse( function ( node ) {

					if ( node.isMesh ) {

						if ( node.name == name ) node.visible = visible;

					}

				} );

			}

			//

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				controls.update();
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_loader_texture_ktx2.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js WebGPU - KTX2 texture loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			* {
				box-sizing: border-box;
				-moz-box-sizing: border-box;
			}

			body {
				background-color: #fff;
				color: #444;
			}

			a {
				color: #08f;
			}

			#content {
				position: absolute;
				top: 0; width: 100%;
				z-index: 1;
				padding: 3em 0 0 0;
			}

			section {
				padding: 1em;
			}

			#c {
				position: absolute;
				left: 0;
				width: 100%;
				height: 100%;
			}

			section .description {
				max-width: 50em;
				text-wrap: pretty;
			}

			.list-item {
				display: inline-block;
				margin: 1em;
				padding: 1em;
				box-shadow: 1px 2px 4px 0px rgba(0,0,0,0.25);
			}

			.list-item > div:nth-child(1) {
				width: 200px;
				height: 200px;
			}

			.list-item > div:nth-child(2) {
				color: #888;
				font-family: sans-serif;
				width: 200px;
				margin-top: 0.5em;
			}
		</style>
	</head>
	<body>

		<canvas id="c"></canvas>

		<div id="content">
			<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - KTX2 texture loader</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';

			let canvas, renderer;

			const scenes = [];

			const sections = [
				{
					title: 'Uncompressed',
					description: 'Uncompressed formats (rgba8, rgba16, rgba32) load as THREE.DataTexture objects.'
						+ ' Lossless, easy to read/write, uncompressed on GPU, optionally compressed over the network.',
					textures: [
						{ path: '2d_rgba8.ktx2' },
						{ path: '2d_rgba8_linear.ktx2' },
						{ path: '2d_rgba16_linear.ktx2' },
						{ path: '2d_rgba32_linear.ktx2' },
						{ path: '2d_rgb9e5_linear.ktx2' },
						{ path: '2d_r11g11b10_linear.ktx2' },
					]
				},
				{
					title: 'Compressed',
					description: 'Compressed formats (ASTC, BCn, ...) load as THREE.CompressedTexture objects,'
						+ ' reducing memory cost. Requires native support on the device GPU: no single compressed'
						+ ' format is supported on every device.',
					textures: [
						{ path: '2d_astc4x4.ktx2' },
						{ path: '2d_etc1.ktx2' },
						{ path: '2d_etc2.ktx2' },
						{ path: '2d_bc1.ktx2' },
						{ path: '2d_bc3.ktx2' },
						{ path: '2d_bc4.ktx2' },
						{ path: '2d_bc5.ktx2' },
						{ path: '2d_bc7.ktx2' },
					]
				},

				{
					title: 'Universal',
					description: 'Basis Universal textures are specialized intermediate formats supporting fast'
						+ ' runtime transcoding into other GPU texture compression formats. After transcoding,'
						+ ' universal textures can be used on any device at reduced memory cost.',
					textures: [
						{ path: '2d_etc1s.ktx2' },
						{ path: '2d_uastc.ktx2' },
					]
				},
			];

			init();

			async function init() {

				canvas = document.getElementById( 'c' );

				renderer = new THREE.WebGPURenderer( { canvas, antialias: true, forceWebGL: false } );
				renderer.setClearColor( 0xffffff, 1 );
				renderer.setPixelRatio( window.devicePixelRatio );

				await renderer.init();

				const loader = new KTX2Loader()
					.setTranscoderPath( 'jsm/libs/basis/' )
					.setPath( 'textures/ktx2/' )
					.detectSupport( renderer );

				const geometry = flipY( new THREE.PlaneGeometry( 1, 1 ) );

				const content = document.getElementById( 'content' );

				for ( const section of sections ) {

					const sectionElement = document.createElement( 'section' );

					const sectionHeader = document.createElement( 'h2' );
					sectionHeader.textContent = section.title;
					sectionElement.appendChild( sectionHeader );

					const sectionDescription = document.createElement( 'p' );
					sectionDescription.className = 'description';
					sectionDescription.textContent = section.description;
					sectionElement.appendChild( sectionDescription );

					for ( const { path, supported } of section.textures ) {

						const scene = new THREE.Scene();

						// make a list item
						const element = document.createElement( 'div' );
						element.className = 'list-item';

						const sceneElement = document.createElement( 'div' );
						element.appendChild( sceneElement );

						const labelElement = document.createElement( 'div' );
						labelElement.innerText = 'file: ' + path;
						element.appendChild( labelElement );

						// the element that represents the area we want to render the scene
						scene.userData.element = sceneElement;
						sectionElement.appendChild( element );

						const camera = new THREE.PerspectiveCamera( 50, 1, 1, 10 );
						camera.position.z = 2;
						scene.userData.camera = camera;

						try {

							const texture = await loader.loadAsync( supported === false ? 'fail_load.ktx2' : path );
							const mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );

							labelElement.innerText += '\ncolorSpace: ' + texture.colorSpace;

							scene.add( mesh );
							scenes.push( scene );

						} catch ( e ) {

							console.error( `Failed to load ${path}`, e );

						}


					}

					content.appendChild( sectionElement );

				}

				renderer.setAnimationLoop( animate );


			}

			function updateSize() {

				const width = canvas.clientWidth;
				const height = canvas.clientHeight;

				if ( canvas.width !== width || canvas.height !== height ) {

					renderer.setSize( width, height, false );

				}

			}

			// Rewrite UVs for `flipY=false` textures.

			function flipY( geometry ) {

				const uv = geometry.attributes.uv;

				for ( let i = 0; i < uv.count; i ++ ) {

					uv.setY( i, 1 - uv.getY( i ) );

				}

				return geometry;

			}

			function animate() {

				updateSize();

				canvas.style.transform = `translateY(${window.scrollY}px)`;

				renderer.setClearColor( 0xffffff );
				renderer.setScissorTest( false );
				renderer.clear();

				renderer.setClearColor( 0xe0e0e0 );
				renderer.setScissorTest( true );

				scenes.forEach( function ( scene ) {

					// get the element that is a place holder for where we want to
					// draw the scene
					const element = scene.userData.element;

					// get its position relative to the page's viewport
					const rect = element.getBoundingClientRect();

					// check if it's offscreen. If so skip it
					if ( rect.top < 0 || rect.bottom > renderer.domElement.clientHeight ||
						 rect.left < 0 || rect.right > renderer.domElement.clientWidth ) {

						return; // it's off screen

					}

					// set the viewport
					const width = rect.right - rect.left;
					const height = rect.bottom - rect.top;
					const left = rect.left;
					const top = rect.top;

					renderer.setViewport( left, top, width, height );
					renderer.setScissor( left, top, width, height );

					const camera = scene.userData.camera;

					renderer.render( scene, camera );

				} );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - materials</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Materials</span>
			</div>

			<small>
				Examples of built-in materials and NodeMaterials.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import * as TSL from 'three/tsl';

			import { Fn, wgslFn, positionLocal, scriptable, positionWorld, normalLocal, normalWorld, normalView, color, texture, uv, float, vec2, vec3, vec4, oscSine, triplanarTexture, screenUV, js, string, Loop, cameraProjectionMatrix, ScriptableNodeResources } from 'three/tsl';

			import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			const objects = [], materials = [];

			init();

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 200, 800 );

				scene = new THREE.Scene();

				// Grid

				const helper = new THREE.GridHelper( 1000, 40, 0x303030, 0x303030 );
				helper.position.y = - 75;
				scene.add( helper );

				// Materials

				const textureLoader = new THREE.TextureLoader();

				const uvTexture = textureLoader.load( './textures/uv_grid_opengl.jpg' );
				uvTexture.wrapS = THREE.RepeatWrapping;
				uvTexture.wrapT = THREE.RepeatWrapping;

				const opacityTexture = textureLoader.load( './textures/alphaMap.jpg' );
				opacityTexture.wrapS = THREE.RepeatWrapping;
				opacityTexture.wrapT = THREE.RepeatWrapping;

				let material;

				//
				//	BASIC
				//

				// PositionLocal
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = positionLocal;
				materials.push( material );

				// PositionWorld
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = positionWorld;
				materials.push( material );

				// NormalLocal
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = normalLocal;
				materials.push( material );

				// NormalWorld
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = normalWorld;
				materials.push( material );

				// NormalView
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = normalView;
				materials.push( material );

				// Texture
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = texture( uvTexture );
				materials.push( material );

				// Opacity
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = color( 0x0099FF );
				material.opacityNode = texture( uvTexture );
				material.transparent = true;
				materials.push( material );

				// AlphaTest
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = texture( uvTexture );
				material.opacityNode = texture( opacityTexture );
				material.alphaTestNode = 0.5;
				materials.push( material );

				// camera
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = cameraProjectionMatrix.mul( positionLocal );
				materials.push( material );


				// Normal
				material = new THREE.MeshNormalMaterial();
				material.opacity = .5;
				material.transparent = true;
				materials.push( material );

				//
				//	ADVANCED
				//

				// Custom ShaderNode ( desaturate filter )

				const desaturateShaderNode = Fn( ( input ) => {

					return vec3( 0.299, 0.587, 0.114 ).dot( input.color.xyz );

				} );

				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = desaturateShaderNode( { color: texture( uvTexture ) } );
				materials.push( material );

				// Custom ShaderNode(no inputs) > Approach 2

				const desaturateNoInputsShaderNode = Fn( () => {

					return vec3( 0.299, 0.587, 0.114 ).dot( texture( uvTexture ).xyz );

				} );

				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = desaturateNoInputsShaderNode();
				materials.push( material );

				// Custom WGSL ( desaturate filter )

				const desaturateWGSLFn = wgslFn( `
					fn desaturate( color:vec3<f32> ) -> vec3<f32> {

						let lum = vec3<f32>( 0.299, 0.587, 0.114 );

						return vec3<f32>( dot( lum, color ) );

					}
				` );

				// include example

				const someWGSLFn = wgslFn( `
					fn someFn( color:vec3<f32> ) -> vec3<f32> {

						return desaturate( color );

					}
				`, [ desaturateWGSLFn ] );

				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = someWGSLFn( { color: texture( uvTexture ) } );
				materials.push( material );

				// Custom WGSL

				const getWGSLTextureSample = wgslFn( `
					fn getWGSLTextureSample( tex: texture_2d<f32>, tex_sampler: sampler, uv:vec2<f32> ) -> vec4<f32> {

						return textureSample( tex, tex_sampler, uv ) * vec4<f32>( 0.0, 1.0, 0.0, 1.0 );

					}
				` );

				const textureNode = texture( uvTexture );

				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = getWGSLTextureSample( { tex: textureNode, tex_sampler: textureNode, uv: uv() } );
				materials.push( material );

				// Triplanar Texture Mapping
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = triplanarTexture( texture( uvTexture ), null, null, float( .01 ) );
				materials.push( material );

				// Screen Projection Texture
				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = texture( uvTexture, screenUV.flipY() );
				materials.push( material );

				// Loop
				material = new THREE.MeshBasicNodeMaterial();
				materials.push( material );

				const loopCount = 10;
				material.colorNode = Loop( loopCount, ( { i } ) => {

					const output = vec4().toVar();
					const scale = oscSine().mul( .09 ); // just a value to test

					const scaleI = scale.mul( i );
					const scaleINeg = scaleI.negate();

					const leftUV = uv().add( vec2( scaleI, 0 ) );
					const rightUV = uv().add( vec2( scaleINeg, 0 ) );
					const topUV = uv().add( vec2( 0, scaleI ) );
					const bottomUV = uv().add( vec2( 0, scaleINeg ) );

					output.assign( output.add( texture( uvTexture, leftUV ) ) );
					output.assign( output.add( texture( uvTexture, rightUV ) ) );
					output.assign( output.add( texture( uvTexture, topUV ) ) );
					output.assign( output.add( texture( uvTexture, bottomUV ) ) );

					return output.div( loopCount * 4 );

				} );

				// Scriptable

				ScriptableNodeResources.set( 'TSL', TSL );

				const asyncNode = scriptable( js( `

					layout = {
						outputType: 'node'
					};

					const { float } = TSL;

					function init() {

						setTimeout( () => {

							local.set( 'result', float( 1.0 ) );

							refresh(); // refresh the node

						}, 1000 );

						return float( 0.0 );

					}

					function main() {

						const result = local.get( 'result', init );

						//console.log( 'result', result );

						return result;

					}

				` ) );

				const scriptableNode = scriptable( js( `

					layout = {
						outputType: 'node',
						elements: [
							{ name: 'source', inputType: 'node' },
							{ name: 'contrast', inputType: 'node' },
							{ name: 'vector3', inputType: 'Vector3' },
							{ name: 'message', inputType: 'string' },
							{ name: 'binary', inputType: 'ArrayBuffer' },
							{ name: 'object3d', inputType: 'Object3D' },
							{ name: 'execFrom', inputType: 'string' }
						]
					};

					const { saturation, float, oscSine, mul } = TSL;

					function helloWorld() {

						console.log( "Hello World!" );

					}

					function main() {

						const source = parameters.get( 'source' ) || float();
						const contrast = parameters.get( 'contrast' ) || float();

						const material = local.get( 'material' );

						//console.log( 'vector3', parameters.get( 'vector3' ) );

						if ( parameters.get( 'execFrom' ) === 'serialized' ) {

							//console.log( 'message', parameters.get( 'message' ).value );
							//console.log( 'binary', parameters.get( 'binary' ) );
							//console.log( 'object3d', parameters.get( 'object3d' ) ); // unserializable yet

							//console.log( global.get( 'renderer' ) );

						}

						if ( material ) material.needsUpdate = true;

						return mul( saturation( source, oscSine() ), contrast );

					}

					output = { helloWorld };

				` ) );

				scriptableNode.setParameter( 'source', texture( uvTexture ).xyz );
				scriptableNode.setParameter( 'contrast', asyncNode );
				scriptableNode.setParameter( 'vector3', vec3( new THREE.Vector3( 1, 1, 1 ) ) );
				scriptableNode.setParameter( 'message', string( 'Hello World!' ) );
				scriptableNode.setParameter( 'binary', new ArrayBuffer( 4 ) );
				scriptableNode.setParameter( 'object3d', new THREE.Group() );

				scriptableNode.call( 'helloWorld' );

				material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = scriptableNode;
				materials.push( material );

				scriptableNode.setLocal( 'material', material );

				//
				// Geometry
				//

				const geometry = new TeapotGeometry( 50, 18 );

				for ( let i = 0, l = materials.length; i < l; i ++ ) {

					addMesh( geometry, materials[ i ] );

				}

				const serializeMesh = scene.children[ scene.children.length - 1 ];

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );

				//

				setTimeout( () => testSerialization( serializeMesh ), 1000 );

			}

			function addMesh( geometry, material ) {

				const mesh = new THREE.Mesh( geometry, material );

				mesh.position.x = ( objects.length % 4 ) * 200 - 400;
				mesh.position.z = Math.floor( objects.length / 4 ) * 200 - 200;

				mesh.rotation.x = Math.random() * 200 - 100;
				mesh.rotation.y = Math.random() * 200 - 100;
				mesh.rotation.z = Math.random() * 200 - 100;

				objects.push( mesh );

				scene.add( mesh );

			}

			function moduleToLib( module ) {

				const lib = {};

				for ( const nodeElement of Object.values( module ) ) {

					if ( typeof nodeElement === 'function' && nodeElement.type !== undefined ) {

						lib[ nodeElement.type ] = nodeElement;

					}

				}

				return lib;

			}

			function testSerialization( mesh ) {

				const json = mesh.toJSON();
				const loader = new THREE.NodeObjectLoader().setNodes( moduleToLib( THREE ) ).setNodeMaterials( moduleToLib( THREE ) );
				const serializedMesh = loader.parse( json, () => {

					serializedMesh.position.x = ( objects.length % 4 ) * 200 - 400;
					serializedMesh.position.z = Math.floor( objects.length / 4 ) * 200 - 200;

					const scriptableNode = serializedMesh.material.colorNode;

					// it's because local.get( 'material' ) is used in the example ( local/global is unserializable )
					scriptableNode.setLocal( 'material', serializedMesh.material );
					scriptableNode.setParameter( 'execFrom', 'serialized' );

					objects.push( serializedMesh );

					scene.add( serializedMesh );

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				const timer = 0.0001 * Date.now();

				camera.position.x = Math.cos( timer ) * 1000;
				camera.position.z = Math.sin( timer ) * 1000;

				camera.lookAt( scene.position );

				for ( let i = 0, l = objects.length; i < l; i ++ ) {

					const object = objects[ i ];

					object.rotation.x += 0.01;
					object.rotation.y += 0.005;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_alphahash.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - alpha hash</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

			import { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';

			let camera, scene, renderer, controls, mesh, material, postProcessing;

			const amount = parseInt( window.location.search.slice( 1 ) ) || 3;
			const count = Math.pow( amount, 3 );

			const color = new THREE.Color();

			const params = {
				alpha: 0.5,
				alphaHash: true
			};

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( amount, amount, amount );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				const geometry = new THREE.IcosahedronGeometry( 0.5, 3 );

				material = new THREE.MeshStandardMaterial( {
					color: 0xffffff,
					alphaHash: params.alphaHash,
					opacity: params.alpha
				} );

				mesh = new THREE.InstancedMesh( geometry, material, count );

				let i = 0;
				const offset = ( amount - 1 ) / 2;

				const matrix = new THREE.Matrix4();

				for ( let x = 0; x < amount; x ++ ) {

					for ( let y = 0; y < amount; y ++ ) {

						for ( let z = 0; z < amount; z ++ ) {

							matrix.setPosition( offset - x, offset - y, offset - z );

							mesh.setMatrixAt( i, matrix );
							mesh.setColorAt( i, color.setHex( Math.random() * 0xffffff ) );

							i ++;

						}

					}

				}

				scene.add( mesh );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				//

				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene.environment = pmremGenerator.fromScene( environment ).texture;
				environment.dispose();

				//

				// postprocessing

				postProcessing = new THREE.PostProcessing( renderer );
				const scenePass = ssaaPass( scene, camera );
				scenePass.sampleLevel = 3;

				postProcessing.outputNode = scenePass;

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableZoom = false;
				controls.enablePan = false;

				//

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.add( params, 'alpha', 0, 1 ).onChange( onMaterialUpdate );
				gui.add( params, 'alphaHash' ).onChange( onMaterialUpdate );

				const ssaaFolder = gui.addFolder( 'SSAA' );
				ssaaFolder.add( scenePass, 'sampleLevel', 0, 4, 1 );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onMaterialUpdate() {

				material.opacity = params.alpha;
				material.alphaHash = params.alphaHash;
				material.transparent = ! params.alphaHash;
				material.depthWrite = params.alphaHash;

				material.needsUpdate = true;

			}

			function animate() {

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_arrays.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - materials arrays and geometry groups</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Material Array</span>
			</div>

			<small>
				Materials Arrays and Geometry Groups.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let renderer, scene, camera, controls;
			let planeMesh, boxMesh, boxMeshWireframe, planeMeshWireframe;
			let materials;

			const api = {
				webgpu: true
			};


			init( ! api.webgpu );

			function init( forceWebGL = false ) {

				if ( renderer ) {

					renderer.dispose();
					controls.dispose();
					document.body.removeChild( renderer.domElement );

				}

				// renderer
				renderer = new THREE.WebGPURenderer( {
					forceWebGL,
					antialias: true,
				} );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				// camera
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
				camera.position.set( 0, 0, 10 );

				// controls
				controls = new OrbitControls( camera, renderer.domElement );

				// materials
				materials = [
					new THREE.MeshBasicMaterial( { color: 0xff1493, side: THREE.DoubleSide } ),
					new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide } ),
					new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide } ),
				];

				// plane geometry
				const planeGeometry = new THREE.PlaneGeometry( 1, 1, 4, 4 );

				planeGeometry.clearGroups();
				const numFacesPerRow = 4; // Number of faces in a row (since each face is made of 2 triangles)

				planeGeometry.addGroup( 0, 6 * numFacesPerRow, 0 );
				planeGeometry.addGroup( 6 * numFacesPerRow, 6 * numFacesPerRow, 1 );
				planeGeometry.addGroup( 12 * numFacesPerRow, 6 * numFacesPerRow, 2 );

				// box geometry
				const boxGeometry = new THREE.BoxGeometry( .75, .75, .75 );

				boxGeometry.clearGroups();
				boxGeometry.addGroup( 0, 6, 0 ); // front face
				boxGeometry.addGroup( 6, 6, 0 ); // back face
				boxGeometry.addGroup( 12, 6, 2 ); // top face
				boxGeometry.addGroup( 18, 6, 2 ); // bottom face
				boxGeometry.addGroup( 24, 6, 1 ); // left face
				boxGeometry.addGroup( 30, 6, 1 ); // right face

				scene.background = forceWebGL ? new THREE.Color( 0x000000 ) : new THREE.Color( 0x222222 );

				// meshes
				planeMesh = new THREE.Mesh( planeGeometry, materials );

				const materialsWireframe = [];

				for ( let index = 0; index < materials.length; index ++ ) {

					const material = new THREE.MeshBasicMaterial( { color: materials[ index ].color, side: THREE.DoubleSide, wireframe: true } );
					materialsWireframe.push( material );

				}

				planeMeshWireframe = new THREE.Mesh( planeGeometry, materialsWireframe );
				boxMeshWireframe = new THREE.Mesh( boxGeometry, materialsWireframe );

				boxMesh = new THREE.Mesh( boxGeometry, materials );

				planeMesh.position.set( - 1.5, - 1, 0 );
				boxMesh.position.set( 1.5, - 0.75, 0 );
				boxMesh.rotation.set( - Math.PI / 8, Math.PI / 4, Math.PI / 4 );

				planeMeshWireframe.position.set( - 1.5, 1, 0 );
				boxMeshWireframe.position.set( 1.5, 1.25, 0 );
				boxMeshWireframe.rotation.set( - Math.PI / 8, Math.PI / 4, Math.PI / 4 );

				scene.add( planeMesh, planeMeshWireframe );
				scene.add( boxMesh, boxMeshWireframe );

			}

			function animate() {

				boxMesh.rotation.y += 0.005;
				boxMesh.rotation.x += 0.005;
				boxMeshWireframe.rotation.y += 0.005;
				boxMeshWireframe.rotation.x += 0.005;
				renderer.render( scene, camera );

			}


			// gui

			const gui = renderer.inspector.createParameters( 'Parameters' );

			gui.add( api, 'webgpu' ).onChange( () => {

				init( ! api.webgpu );

			} );

			// listeners

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_basic.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - basic material</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Basic Material</span>
			</div>

			<small>
				Basic Material example.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			const spheres = [];

			let mouseX = 0;
			let mouseY = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			const params = {
				color: '#ffffff',
				mapping: THREE.CubeReflectionMapping,
				refractionRatio: 0.98,
				transparent: false,
				opacity: 1
			};

			const mappings = { ReflectionMapping: THREE.CubeReflectionMapping, RefractionMapping: THREE.CubeRefractionMapping };

			document.addEventListener( 'mousemove', onDocumentMouseMove );

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.z = 3;

				const path = './textures/cube/pisa/';
				const format = '.png';
				const urls = [
					path + 'px' + format, path + 'nx' + format,
					path + 'py' + format, path + 'ny' + format,
					path + 'pz' + format, path + 'nz' + format
				];

				const textureCube = new THREE.CubeTextureLoader().load( urls );

				scene = new THREE.Scene();
				scene.background = textureCube;

				const geometry = new THREE.SphereGeometry( 0.1, 32, 16 );
				const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );

				for ( let i = 0; i < 500; i ++ ) {

					const mesh = new THREE.Mesh( geometry, material );

					mesh.position.x = Math.random() * 10 - 5;
					mesh.position.y = Math.random() * 10 - 5;
					mesh.position.z = Math.random() * 10 - 5;

					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1;

					scene.add( mesh );

					spheres.push( mesh );

				}

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.addColor( params, 'color' ).onChange( ( value ) => material.color.set( value ) );
				gui.add( params, 'mapping', mappings ).onChange( ( value ) => {

					textureCube.mapping = value;
					material.needsUpdate = true;
			
				} );
				gui.add( params, 'refractionRatio', 0, 1, 0.01 ).onChange( ( value ) => material.refractionRatio = value );
				gui.add( params, 'transparent' ).onChange( ( value ) => {
			
					material.transparent = value;
					material.needsUpdate = true;

				} );
				gui.add( params, 'opacity', 0, 1, 0.01 ).onChange( ( value ) => material.opacity = value );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );


			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 100;
				mouseY = ( event.clientY - windowHalfY ) / 100;

			}

			//

			function animate() {

				const timer = 0.0001 * Date.now();

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;

				camera.lookAt( scene.position );

				for ( let i = 0, il = spheres.length; i < il; i ++ ) {

					const sphere = spheres[ i ];

					sphere.position.x = 5 * Math.cos( timer + i );
					sphere.position.y = 5 * Math.sin( timer + i * 1.1 );

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_cubemap_mipmaps.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - cubemap mipmaps</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Custom CubeMap Mipmaps</span>
			</div>

			<small>
				Cubemap customized mipmaps demo.<br/>
				Left: WebGPU generated mipmaps<br/>
				Right: manual mipmaps<br/>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let container;

			let camera, scene, renderer;

			init();

			// load customized cube texture
			async function loadCubeTextureWithMipmaps() {

				const path = 'textures/cube/angus/';
				const format = '.jpg';
				const mipmaps = [];
				const maxLevel = 8;

				async function loadCubeTexture( urls ) {

					return new Promise( function ( resolve ) {

						new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {

							resolve( cubeTexture );

						} );


					} );

				}

				// load mipmaps
				const pendings = [];

				for ( let level = 0; level <= maxLevel; ++ level ) {

					const urls = [];

					for ( let face = 0; face < 6; ++ face ) {

						urls.push( path + 'cube_m0' + level + '_c0' + face + format );

					}

					const mipmapLevel = level;

					pendings.push( loadCubeTexture( urls ).then( function ( cubeTexture ) {

						mipmaps[ mipmapLevel ] = cubeTexture;

					} ) );

				}

				await Promise.all( pendings );

				const customizedCubeTexture = mipmaps.shift();
				customizedCubeTexture.mipmaps = mipmaps;
				customizedCubeTexture.colorSpace = THREE.SRGBColorSpace;
				customizedCubeTexture.minFilter = THREE.LinearMipMapLinearFilter;
				customizedCubeTexture.magFilter = THREE.LinearFilter;
				customizedCubeTexture.generateMipmaps = false;
				customizedCubeTexture.needsUpdate = true;

				return customizedCubeTexture;

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 500;

				scene = new THREE.Scene();

				loadCubeTextureWithMipmaps().then( function ( cubeTexture ) {

					// model
					const sphere = new THREE.SphereGeometry( 100, 128, 128 );

					// manual mipmaps
					let material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: cubeTexture } );
					material.name = 'manual mipmaps';

					let mesh = new THREE.Mesh( sphere, material );
					mesh.position.set( 100, 0, 0 );
					scene.add( mesh );


					// auto mipmaps
					material = material.clone();
					material.name = 'auto mipmaps';

					const autoCubeTexture = cubeTexture.clone();
					autoCubeTexture.mipmaps = [];
					autoCubeTexture.generateMipmaps = true;
					autoCubeTexture.needsUpdate = true;

					material.envMap = autoCubeTexture;

					mesh = new THREE.Mesh( sphere, material );
					mesh.position.set( - 100, 0, 0 );
					scene.add( mesh );

				} );

				//renderer
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				//controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minPolarAngle = Math.PI / 4;
				controls.maxPolarAngle = Math.PI / 1.5;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_displacementmap.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - displacement map</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Displacement Map</span>
			</div>

			<small>
				( normal + ao + displacement + environment ) maps.<br />
				Ninja head from <a href="https://gpuopen.com/archive/gamescgi/amd-gpu-meshmapper/" target="_blank" rel="noopener">AMD GPU MeshMapper</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

			let camera, scene, renderer, controls;

			const settings = {
				metalness: 1.0,
				roughness: 0.4,
				ambientIntensity: 0.2,
				aoMapIntensity: 1.0,
				envMapIntensity: 1.0,
				displacementScale: 2.436143, // from original model
				normalScale: 1.0
			};

			let mesh, material;

			let pointLight, ambientLight;

			const height = 500; // of camera frustum

			let r = 0.0;

			init();
			initGui();

			// Init gui
			function initGui() {

				const gui = renderer.inspector.createParameters( 'settings' );

				gui.add( settings, 'metalness', 0, 1 ).onChange( function ( value ) {

					material.metalness = value;

				} );

				gui.add( settings, 'roughness', 0, 1 ).onChange( function ( value ) {

					material.roughness = value;

				} );

				gui.add( settings, 'aoMapIntensity', 0, 1 ).onChange( function ( value ) {

					material.aoMapIntensity = value;

				} );

				gui.add( settings, 'ambientIntensity', 0, 1 ).onChange( function ( value ) {

					ambientLight.intensity = value;

				} );

				gui.add( settings, 'envMapIntensity', 0, 3 ).onChange( function ( value ) {

					material.envMapIntensity = value;

				} );

				gui.add( settings, 'displacementScale', 0, 3.0 ).onChange( function ( value ) {

					material.displacementScale = value;

				} );

				gui.add( settings, 'normalScale', - 1, 1 ).onChange( function ( value ) {

					material.normalScale.set( 1, - 1 ).multiplyScalar( value );

				} );

			}

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGPURenderer();
				renderer.setAnimationLoop( animate );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				scene = new THREE.Scene();

				const aspect = window.innerWidth / window.innerHeight;
				camera = new THREE.OrthographicCamera( - height * aspect, height * aspect, height, - height, 1, 10000 );
				camera.position.z = 1500;
				scene.add( camera );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableZoom = false;
				controls.enableDamping = true;

				// lights

				ambientLight = new THREE.AmbientLight( 0xffffff, settings.ambientIntensity );
				scene.add( ambientLight );

				pointLight = new THREE.PointLight( 0xff0000, 1.5, 0, 0 );
				pointLight.position.z = 2500;
				scene.add( pointLight );

				const pointLight2 = new THREE.PointLight( 0xff6666, 3, 0, 0 );
				camera.add( pointLight2 );

				const pointLight3 = new THREE.PointLight( 0x0000ff, 1.5, 0, 0 );
				pointLight3.position.x = - 1000;
				pointLight3.position.z = 1000;
				scene.add( pointLight3 );

				// env map

				const path = 'textures/cube/SwedishRoyalCastle/';
				const format = '.jpg';
				const urls = [
					path + 'px' + format, path + 'nx' + format,
					path + 'py' + format, path + 'ny' + format,
					path + 'pz' + format, path + 'nz' + format
				];

				const reflectionCube = new THREE.CubeTextureLoader().load( urls );

				// textures

				const textureLoader = new THREE.TextureLoader();
				const normalMap = textureLoader.load( 'models/obj/ninja/normal.png' );
				const aoMap = textureLoader.load( 'models/obj/ninja/ao.jpg' );
				const displacementMap = textureLoader.load( 'models/obj/ninja/displacement.jpg' );

				// material

				material = new THREE.MeshStandardNodeMaterial( {

					color: 0xc1c1c1,
					roughness: settings.roughness,
					metalness: settings.metalness,

					normalMap: normalMap,
					normalScale: new THREE.Vector2( 1, - 1 ), // why does the normal map require negation in this case?

					aoMap: aoMap,
					aoMapIntensity: 1,

					displacementMap: displacementMap,
					displacementScale: settings.displacementScale,
					displacementBias: - 0.428408, // from original model

					envMap: reflectionCube,
					envMapIntensity: settings.envMapIntensity,

					side: THREE.DoubleSide

				} );

				//

				const loader = new OBJLoader();
				loader.load( 'models/obj/ninja/ninjaHead_Low.obj', function ( group ) {

					const geometry = group.children[ 0 ].geometry;
					geometry.center();

					mesh = new THREE.Mesh( geometry, material );
					mesh.scale.multiplyScalar( 25 );
					scene.add( mesh );

				} );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const aspect = window.innerWidth / window.innerHeight;

				camera.left = - height * aspect;
				camera.right = height * aspect;
				camera.top = height;
				camera.bottom = - height;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				controls.update();

				render();

			}

			function render() {

				pointLight.position.x = 2500 * Math.cos( r );
				pointLight.position.z = 2500 * Math.sin( r );

				r += 0.01;

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_envmaps.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - environment maps</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Environment Mapping</span>
			</div>

			<small>
				Equirectangular Map by <a href="http://www.flickr.com/photos/jonragnarsson/2294472375/" target="_blank" rel="noopener">J&oacute;n Ragnarsson</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let controls, camera, scene, renderer;
			let textureEquirec, textureCube;
			let sphereMesh, sphereMaterial, params;

			init();

			function init() {

				// CAMERAS

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 0, 2.5 );

				// SCENE

				scene = new THREE.Scene();

				// Textures

				const loader = new THREE.CubeTextureLoader();
				loader.setPath( 'textures/cube/Bridge2/' );

				textureCube = loader.load( [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ] );

				const textureLoader = new THREE.TextureLoader();

				textureEquirec = textureLoader.load( 'textures/2294472375_24a3b8ef46_o.jpg' );
				textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
				textureEquirec.colorSpace = THREE.SRGBColorSpace;

				scene.background = textureCube;

				//

				const geometry = new THREE.IcosahedronGeometry( 1, 15 );
				sphereMaterial = new THREE.MeshBasicMaterial( { envMap: textureCube } );
				sphereMesh = new THREE.Mesh( geometry, sphereMaterial );
				scene.add( sphereMesh );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1.5;
				controls.maxDistance = 6;

				//

				params = {
					Type: 'Cube',
					Refraction: false,
					backgroundRotationX: false,
					backgroundRotationY: false,
					backgroundRotationZ: false,
					syncMaterial: false
				};

				const gui = renderer.inspector.createParameters( 'Parameters' );
				gui.add( params, 'Type', [ 'Cube', 'Equirectangular' ] ).onChange( function ( value ) {

					if ( value === 'Cube' ) {

						scene.background = textureCube;

						sphereMaterial.envMap = textureCube;
						sphereMaterial.needsUpdate = true;

					} else if ( value === 'Equirectangular' ) {

						scene.background = textureEquirec;

						sphereMaterial.envMap = textureEquirec;
						sphereMaterial.needsUpdate = true;

					}

				} );
				gui.add( params, 'Refraction' ).onChange( function ( value ) {

					if ( value ) {

						textureEquirec.mapping = THREE.EquirectangularRefractionMapping;
						textureCube.mapping = THREE.CubeRefractionMapping;

					} else {

						textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
						textureCube.mapping = THREE.CubeReflectionMapping;

					}

					sphereMaterial.needsUpdate = true;

				} );
				gui.add( params, 'backgroundRotationX' );
				gui.add( params, 'backgroundRotationY' );
				gui.add( params, 'backgroundRotationZ' );
				gui.add( params, 'syncMaterial' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				if ( params.backgroundRotationX ) {

					scene.backgroundRotation.x += 0.001;

				}

				if ( params.backgroundRotationY ) {

					scene.backgroundRotation.y += 0.001;

				}

				if ( params.backgroundRotationZ ) {

					scene.backgroundRotation.z += 0.001;

				}

				if ( params.syncMaterial ) {

					sphereMesh.material.envMapRotation.copy( scene.backgroundRotation );

				}

				camera.lookAt( scene.position );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_envmaps_bpcem.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - bpcem</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>BPCEM</span>
			</div>

			<small>
				Box projected cube environment mapping (BPCEM).
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { bumpMap, float, getParallaxCorrectNormal, pmremTexture, reflectVector, texture, uniform, vec3 } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
			import { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';

			let camera, scene, renderer;

			let controls, cubeCamera;

			let groundPlane, wallMat;

			init();

			function init() {

				THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() );

				// scene
			
				scene = new THREE.Scene();

				// camera

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( 0, 200, - 200 );

				// cube camera for environment map

				const renderTarget = new THREE.WebGLCubeRenderTarget( 512 );
				renderTarget.texture.type = THREE.HalfFloatType;
				renderTarget.texture.minFilter = THREE.LinearMipmapLinearFilter;
				renderTarget.texture.magFilter = THREE.LinearFilter;
				renderTarget.texture.generateMipmaps = true;
				renderTarget.texture.mapping = THREE.CubeReflectionMapping;

				cubeCamera = new THREE.CubeCamera( 1, 1000, renderTarget );
				cubeCamera.position.set( 0, - 100, 0 );

				// ground floor ( with box projected environment mapping )
			
				const loader = new THREE.TextureLoader();
				const rMap = loader.load( 'textures/lava/lavatile.jpg' );
				rMap.wrapS = THREE.RepeatWrapping;
				rMap.wrapT = THREE.RepeatWrapping;
				rMap.repeat.set( 2, 1 );

				const roughnessUniform = uniform( 0.25 );

				const defaultMat = new THREE.MeshStandardNodeMaterial();
				defaultMat.envNode = pmremTexture( renderTarget.texture );
				defaultMat.roughnessNode = texture( rMap ).mul( roughnessUniform );
				defaultMat.metalnessNode = float( 1 );

				const boxProjectedMat = new THREE.MeshStandardNodeMaterial();
				boxProjectedMat.envNode = pmremTexture( renderTarget.texture, getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) ) );
				boxProjectedMat.roughnessNode = texture( rMap ).mul( roughnessUniform );
				boxProjectedMat.metalnessNode = float( 1 );

				groundPlane = new THREE.Mesh( new THREE.PlaneGeometry( 200, 100, 100 ), boxProjectedMat );
				groundPlane.rotateX( - Math.PI / 2 );
				groundPlane.position.set( 0, - 49, 0 );
				scene.add( groundPlane );

				// walls
			
				const diffuseTex = loader.load( 'textures/brick_diffuse.jpg' );
				diffuseTex.colorSpace = THREE.SRGBColorSpace;
				const bumpTex = loader.load( 'textures/brick_bump.jpg' );

				wallMat = new THREE.MeshStandardNodeMaterial();

				wallMat.colorNode = texture( diffuseTex );
				wallMat.normalNode = bumpMap( texture( bumpTex ), float( 5 ) );

				const planeGeo = new THREE.PlaneGeometry( 100, 100 );

				const planeBack1 = new THREE.Mesh( planeGeo, wallMat );
				planeBack1.position.z = - 50;
				planeBack1.position.x = - 50;
				scene.add( planeBack1 );

				const planeBack2 = new THREE.Mesh( planeGeo, wallMat );
				planeBack2.position.z = - 50;
				planeBack2.position.x = 50;
				scene.add( planeBack2 );

				const planeFront1 = new THREE.Mesh( planeGeo, wallMat );
				planeFront1.position.z = 50;
				planeFront1.position.x = - 50;
				planeFront1.rotateY( Math.PI );
				scene.add( planeFront1 );

				const planeFront2 = new THREE.Mesh( planeGeo, wallMat );
				planeFront2.position.z = 50;
				planeFront2.position.x = 50;
				planeFront2.rotateY( Math.PI );
				scene.add( planeFront2 );

				const planeRight = new THREE.Mesh( planeGeo, wallMat );
				planeRight.position.x = 100;
				planeRight.rotateY( - Math.PI / 2 );
				scene.add( planeRight );

				const planeLeft = new THREE.Mesh( planeGeo, wallMat );
				planeLeft.position.x = - 100;
				planeLeft.rotateY( Math.PI / 2 );
				scene.add( planeLeft );

				// area lights

				const width = 50;
				const height = 50;
				const intensity = 5;
			
				const blueRectLight = new THREE.RectAreaLight( 0x9aaeff, intensity, width, height );
				blueRectLight.position.set( - 99, 5, 0 );
				blueRectLight.lookAt( 0, 5, 0 );
				scene.add( blueRectLight );

				const blueRectLightHelper = new RectAreaLightHelper( blueRectLight, 0xffffff );
				blueRectLight.add( blueRectLightHelper );

				const redRectLight = new THREE.RectAreaLight( 0xf3aaaa, intensity, width, height );
				redRectLight.position.set( 99, 5, 0 );
				redRectLight.lookAt( 0, 5, 0 );
				scene.add( redRectLight );

				const redRectLightHelper = new RectAreaLightHelper( redRectLight, 0xffffff );
				redRectLight.add( redRectLightHelper );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, - 10, 0 );
				controls.maxDistance = 400;
				controls.minDistance = 10;
				controls.update();

				// gui

				const gui = renderer.inspector.createParameters( 'Parameters' );
				const params = {
					'box projected': true
				};
				gui.add( params, 'box projected' ).onChange( ( value ) => {

					groundPlane.material = ( value ) ? boxProjectedMat : defaultMat;

				} );
				gui.add( roughnessUniform, 'value', 0, 1 ).name( 'roughness' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function updateCubeMap() {

				groundPlane.visible = false;

				cubeCamera.position.copy( groundPlane.position );

				cubeCamera.update( renderer, scene );

				groundPlane.visible = true;

			}

			function animate() {

				updateCubeMap();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_lightmap.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - lightmap</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { vec4, color, positionLocal, mix } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let container;
			let camera, scene, renderer;

			const params = {
				intensity: 1
			};

			init();

			async function init() {

				const { innerWidth, innerHeight } = window;

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// CAMERA

				camera = new THREE.PerspectiveCamera( 40, innerWidth / innerHeight, 1, 10000 );
				camera.position.set( 700, 200, - 500 );

				// SCENE

				scene = new THREE.Scene();

				// LIGHTS

				const light = new THREE.DirectionalLight( 0xd5deff );
				light.position.x = 300;
				light.position.y = 250;
				light.position.z = - 500;
				scene.add( light );

				// SKYDOME

				const topColor = new THREE.Color().copy( light.color );
				const bottomColor = new THREE.Color( 0xffffff );
				const offset = 400;
				const exponent = 0.6;

				const h = positionLocal.add( offset ).normalize().y;

				const skyMat = new THREE.MeshBasicNodeMaterial();
				skyMat.colorNode = vec4( mix( color( bottomColor ), color( topColor ), h.max( 0.0 ).pow( exponent ) ), 1.0 );
				skyMat.side = THREE.BackSide;

				const sky = new THREE.Mesh( new THREE.SphereGeometry( 4000, 32, 15 ), skyMat );
				scene.add( sky );

				// MODEL

				const loader = new THREE.ObjectLoader();
				const object = await loader.loadAsync( 'models/json/lightmap/lightmap.json' );
				scene.add( object );

				// RENDERER

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setAnimationLoop( animate );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( innerWidth, innerHeight );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				// CONTROLS

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = 0.9 * Math.PI / 2;
				controls.enableZoom = false;

				// GUI

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.add( params, 'intensity', 0, 1 ).name( 'Light Map Intensity' ).onChange( ( value ) => {

					for ( const material of object.material ) {

						material.lightMapIntensity = value;

					}

				} );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_matcap.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - matcap material</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Matcap Material</span>
			</div>

			<small>
				Drag-and-drop JPG, PNG, WebP, AVIF, or EXR MatCap image files.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { EXRLoader } from 'three/addons/loaders/EXRLoader.js';

			let mesh, renderer, scene, camera;

			const API = {
				color: 0xffffff, // sRGB
				exposure: 1.0
			};

			init();

			function init() {

				// renderer
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// tone mapping
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
			 	renderer.toneMappingExposure = API.exposure;

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
				camera.position.set( 0, 0, 13 );

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.enableZoom = false;
				controls.enablePan = false;

				// matcap
				const loaderEXR = new EXRLoader();
				const matcap = loaderEXR.load( 'textures/matcaps/040full.exr' );

				// normalmap
				const loader = new THREE.TextureLoader();

				const normalmap = loader.load( 'models/gltf/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg' );

				// model
				new GLTFLoader().load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {

					mesh = gltf.scene.children[ 0 ];
					mesh.position.y = - 0.25;

					mesh.material = new THREE.MeshMatcapNodeMaterial( {

						color: new THREE.Color().setHex( API.color ),
						matcap: matcap,
						normalMap: normalmap

					} );

					scene.add( mesh );

				} );

				// gui
				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.addColor( API, 'color' )
					.listen()
					.onChange( function () {

						mesh.material.color.set( API.color );

					} );

				gui.add( API, 'exposure', 0, 2 )
					.listen()
					.onChange( function () {

						renderer.toneMappingExposure = API.exposure;

					} );

				// drag 'n drop
				initDragAndDrop();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

			}

			function animate() {

				renderer.render( scene, camera );

			}

			//
			// drag and drop anywhere in document
			//

			function updateMatcap( texture ) {

				if ( mesh.material.matcap ) {

					mesh.material.matcap.dispose();

				}

				mesh.material.matcap = texture;

				texture.needsUpdate = true;

				mesh.material.needsUpdate = true; // because the color space can change

			}

			function handleJPG( event ) { // PNG, WebP, AVIF, too

				function imgCallback( event ) {

					const texture = new THREE.Texture( event.target );

					texture.colorSpace = THREE.SRGBColorSpace;

					updateMatcap( texture );

				}

				const img = new Image();

				img.onload = imgCallback;

				img.src = event.target.result;

			}

			function handleEXR( event ) {

				const contents = event.target.result;

				const loader = new EXRLoader();

				loader.setDataType( THREE.HalfFloatType );

				const texData = loader.parse( contents );

				const texture = new THREE.DataTexture();

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

				texture.format = texData.format;
				texture.type = texData.type;
				texture.colorSpace = THREE.LinearSRGBColorSpace;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.generateMipmaps = false;
				texture.flipY = false;

				updateMatcap( texture );

			}

			function loadFile( file ) {

				const filename = file.name;
				const extension = filename.split( '.' ).pop().toLowerCase();

				if ( extension === 'exr' ) {

					const reader = new FileReader();

					reader.addEventListener( 'load', function ( event ) {

						handleEXR( event );

					} );

					reader.readAsArrayBuffer( file );

				} else { // 'jpg', 'png'

					const reader = new FileReader();

					reader.addEventListener( 'load', function ( event ) {

						handleJPG( event );

					} );

					reader.readAsDataURL( file );

				}

			}

			function initDragAndDrop() {

				document.addEventListener( 'dragover', function ( event ) {

					event.preventDefault();
					event.dataTransfer.dropEffect = 'copy';

				} );

				document.addEventListener( 'drop', function ( event ) {

					event.preventDefault();

					loadFile( event.dataTransfer.files[ 0 ] );

				} );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_sss.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - sss</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>SSS</span>
			</div>

			<small>
				Fast subsurface scattering<br/>
				[Thanks for the art support from <a href="https://github.com/shaochun" target="_blank" rel="noopener">Shaochun Lin</a>]
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, uniform, vec3 } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

			let container;
			let camera, scene, renderer;
			let model;

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.set( 0.0, 300, 400 * 4 );

				scene = new THREE.Scene();

				// Lights

				scene.add( new THREE.AmbientLight( 0xc1c1c1 ) );

				const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.03 );
				directionalLight.position.set( 0.0, 0.5, 0.5 ).normalize();
				scene.add( directionalLight );

				const pointLight1 = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xc1c1c1 } ) );
				pointLight1.add( new THREE.PointLight( 0xc1c1c1, 4.0, 300, 0 ) );
				scene.add( pointLight1 );
				pointLight1.position.x = 0;
				pointLight1.position.y = - 50;
				pointLight1.position.z = 350;

				const pointLight2 = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xc1c100 } ) );
				pointLight2.add( new THREE.PointLight( 0xc1c100, 0.75, 500, 0 ) );
				scene.add( pointLight2 );
				pointLight2.position.x = - 100;
				pointLight2.position.y = 20;
				pointLight2.position.z = - 260;

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				//

				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.inspector.domElement );

				//

				const controls = new OrbitControls( camera, container );
				controls.minDistance = 500;
				controls.maxDistance = 3000;

				window.addEventListener( 'resize', onWindowResize );

				initMaterial();

			}

			function initMaterial() {

				const loader = new THREE.TextureLoader();
				const imgTexture = loader.load( 'models/fbx/white.jpg' );
				imgTexture.colorSpace = THREE.SRGBColorSpace;

				const thicknessTexture = loader.load( 'models/fbx/bunny_thickness.jpg' );
				imgTexture.wrapS = imgTexture.wrapT = THREE.RepeatWrapping;

				const material = new THREE.MeshSSSNodeMaterial();
				material.color = new THREE.Color( 1.0, 0.2, 0.2 );
				material.roughness = 0.3;
				material.thicknessColorNode = texture( thicknessTexture ).mul( vec3( 0.5, 0.3, 0.0 ) );
				material.thicknessDistortionNode = uniform( 0.1 );
				material.thicknessAmbientNode = uniform( 0.4 );
				material.thicknessAttenuationNode = uniform( 0.8 );
				material.thicknessPowerNode = uniform( 2.0 );
				material.thicknessScaleNode = uniform( 16.0 );

				// LOADER

				const loaderFBX = new FBXLoader();
				loaderFBX.load( 'models/fbx/stanford-bunny.fbx', function ( object ) {

					model = object.children[ 0 ];
					model.position.set( 0, 0, 10 );
					model.scale.setScalar( 1 );
					model.material = material;
					scene.add( model );

				} );

				initGUI( material );

			}

			function initGUI( material ) {

				const gui = renderer.inspector.createParameters( 'Parameters' );

				const ThicknessControls = function () {

					this.distortion = material.thicknessDistortionNode.value;
					this.ambient = material.thicknessAmbientNode.value;
					this.attenuation = material.thicknessAttenuationNode.value;
					this.power = material.thicknessPowerNode.value;
					this.scale = material.thicknessScaleNode.value;

				};

				const thicknessControls = new ThicknessControls();

				gui.add( thicknessControls, 'distortion', 0.01, 1, 0.01 ).onChange( function () {

					material.thicknessDistortionNode.value = thicknessControls.distortion;

				} );

				gui.add( thicknessControls, 'ambient', 0.01, 5.0, 0.05 ).onChange( function () {

					material.thicknessAmbientNode.value = thicknessControls.ambient;

				} );

				gui.add( thicknessControls, 'attenuation', 0.01, 5.0, 0.05 ).onChange( function () {

					material.thicknessAttenuationNode.value = thicknessControls.attenuation;

				} );

				gui.add( thicknessControls, 'power', 0.01, 16.0, 0.1 ).onChange( function () {

					material.thicknessPowerNode.value = thicknessControls.power;

				} );

				gui.add( thicknessControls, 'scale', 0.01, 50.0, 0.1 ).onChange( function () {

					material.thicknessScaleNode.value = thicknessControls.scale;

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				if ( model ) model.rotation.y = performance.now() / 5000;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_texture_manualmipmap.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - manual mipmaping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>

			.lbl { color:#fff; font-size:16px; font-weight:bold; position: absolute; bottom:0px; z-index:100; text-shadow:#000 1px 1px 1px; background-color:rgba(0,0,0,0.85); padding:1em }
			#lbl_left { text-align:left; left:0px }
			#lbl_right { text-align:left; right:0px }

			.g { color:#aaa }
			.c { color:#fa0 }

		</style>
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Texture Manual Mipmapping</span>
			</div>

			<small>
				Painting by <a href="http://en.wikipedia.org/wiki/Basket_of_Fruit_%28Caravaggio%29">Caravaggio</a>.
			</small>
		</div>

		<div id="lbl_left" class="lbl">
		Floor <span class="g">(128x128)</span><br/>
		mag: <span class="c">Linear</span><br/>
		min: <span class="c">LinearMipmapLinear</span><br/>
		<br/>
		Painting <span class="g">(748x600)</span><br/>
		mag: <span class="c">Linear</span><br/>
		min: <span class="c">Linear</span>
		</div>

		<div id="lbl_right" class="lbl">
		Floor <br/>
		mag: <span class="c">Nearest</span><br/>
		min: <span class="c">NearestMipmapNearestFilter</span><br/>
		<br/>
		Painting <br/>
		mag: <span class="c">Nearest</span><br/>
		min: <span class="c">Nearest</span>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			const SCREEN_WIDTH = window.innerWidth;
			const SCREEN_HEIGHT = window.innerHeight;

			let container;

			let camera, scene1, scene2, renderer;

			let mouseX = 0, mouseY = 0;

			const windowHalfX = window.innerWidth / 2;
			const windowHalfY = window.innerHeight / 2;

			init();

			async function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 35, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 5000 );
				camera.position.z = 1500;

				scene1 = new THREE.Scene();
				scene1.background = new THREE.Color( 0x000000 );
				scene1.fog = new THREE.Fog( 0x000000, 1500, 4000 );

				scene2 = new THREE.Scene();
				scene2.background = new THREE.Color( 0x000000 );
				scene2.fog = new THREE.Fog( 0x000000, 1500, 4000 );

				// GROUND

				const canvas = mipmap( 128, '#f00' );
				const textureCanvas1 = new THREE.CanvasTexture( canvas );
				textureCanvas1.mipmaps[ 0 ] = canvas;
				textureCanvas1.mipmaps[ 1 ] = mipmap( 64, '#0f0' );
				textureCanvas1.mipmaps[ 2 ] = mipmap( 32, '#00f' );
				textureCanvas1.mipmaps[ 3 ] = mipmap( 16, '#400' );
				textureCanvas1.mipmaps[ 4 ] = mipmap( 8, '#040' );
				textureCanvas1.mipmaps[ 5 ] = mipmap( 4, '#004' );
				textureCanvas1.mipmaps[ 6 ] = mipmap( 2, '#044' );
				textureCanvas1.mipmaps[ 7 ] = mipmap( 1, '#404' );
				textureCanvas1.colorSpace = THREE.SRGBColorSpace;
				textureCanvas1.repeat.set( 1000, 1000 );
				textureCanvas1.wrapS = THREE.RepeatWrapping;
				textureCanvas1.wrapT = THREE.RepeatWrapping;

				const textureCanvas2 = textureCanvas1.clone();
				textureCanvas2.magFilter = THREE.NearestFilter;
				textureCanvas2.minFilter = THREE.NearestMipmapNearestFilter;

				const materialCanvas1 = new THREE.MeshBasicMaterial( { map: textureCanvas1 } );
				const materialCanvas2 = new THREE.MeshBasicMaterial( { color: 0xffccaa, map: textureCanvas2 } );

				const geometry = new THREE.PlaneGeometry( 100, 100 );

				const meshCanvas1 = new THREE.Mesh( geometry, materialCanvas1 );
				meshCanvas1.rotation.x = - Math.PI / 2;
				meshCanvas1.scale.set( 1000, 1000, 1000 );

				const meshCanvas2 = new THREE.Mesh( geometry, materialCanvas2 );
				meshCanvas2.rotation.x = - Math.PI / 2;
				meshCanvas2.scale.set( 1000, 1000, 1000 );

				scene1.add( meshCanvas1 );
				scene2.add( meshCanvas2 );

				// PAINTING

				const texturePainting1 = await new THREE.TextureLoader().loadAsync( 'textures/758px-Canestra_di_frutta_(Caravaggio).jpg' );
				const texturePainting2 = texturePainting1.clone();

				texturePainting1.colorSpace = THREE.SRGBColorSpace;
				texturePainting2.colorSpace = THREE.SRGBColorSpace;

				texturePainting1.minFilter = texturePainting1.magFilter = THREE.LinearFilter;
				texturePainting2.minFilter = texturePainting2.magFilter = THREE.NearestFilter;

				const materialPainting1 = new THREE.MeshBasicMaterial( { color: 0xffffff, map: texturePainting1 } );
				const materialPainting2 = new THREE.MeshBasicMaterial( { color: 0xffccaa, map: texturePainting2 } );

				const geometryPainting = new THREE.PlaneGeometry( 100, 100 );
				const mesh1 = new THREE.Mesh( geometryPainting, materialPainting1 );
				const mesh2 = new THREE.Mesh( geometryPainting, materialPainting2 );

				addPainting( scene1, mesh1 );
				addPainting( scene2, mesh2 );

				function addPainting( zscene, zmesh ) {

					const image = texturePainting1.image;

					zmesh.scale.x = image.width / 100;
					zmesh.scale.y = image.height / 100;

					zscene.add( zmesh );

					const meshFrame = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );
					meshFrame.position.z = - 10.0;
					meshFrame.scale.x = 1.1 * image.width / 100;
					meshFrame.scale.y = 1.1 * image.height / 100;
					zscene.add( meshFrame );

					const meshShadow = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.75, transparent: true } ) );
					meshShadow.position.y = - 1.1 * image.height / 2;
					meshShadow.position.z = - 1.1 * image.height / 2;
					meshShadow.rotation.x = - Math.PI / 2;
					meshShadow.scale.x = 1.1 * image.width / 100;
					meshShadow.scale.y = 1.1 * image.height / 100;
					zscene.add( meshShadow );

					const floorHeight = - 1.117 * image.height / 2;
					meshCanvas1.position.y = meshCanvas2.position.y = floorHeight;

				}

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.setAnimationLoop( animate );
				renderer.autoClear = false;

				renderer.domElement.style.position = 'relative';
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove );

			}

			function mipmap( size, color ) {

				const imageCanvas = document.createElement( 'canvas' );
				const context = imageCanvas.getContext( '2d' );

				imageCanvas.width = imageCanvas.height = size;

				context.fillStyle = '#444';
				context.fillRect( 0, 0, size, size );

				context.fillStyle = color;
				context.fillRect( 0, 0, size / 2, size / 2 );
				context.fillRect( size / 2, size / 2, size / 2, size / 2 );
				return imageCanvas;

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );

			}


			function animate() {

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - ( mouseY - 200 ) - camera.position.y ) * .05;

				camera.lookAt( scene1.position );

				renderer.clear();
				renderer.setScissorTest( true );

				renderer.setScissor( 0, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );
				renderer.render( scene1, camera );

				renderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );
				renderer.render( scene2, camera );

				renderer.setScissorTest( false );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_toon.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - toon material</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Toon Material</span>
			</div>

			<small>
				Toon material and outline post-processing effect.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { toonOutlinePass } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

			let container;

			let camera, scene, renderer, postProcessing;
			let particleLight;

			const loader = new FontLoader();
			loader.load( 'fonts/gentilis_regular.typeface.json', function ( font ) {

				init( font );

			} );

			function init( font ) {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2500 );
				camera.position.set( 0.0, 400, 400 * 3.5 );

				//

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x444488 );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				postProcessing = new THREE.PostProcessing( renderer );

				postProcessing.outputNode = toonOutlinePass( scene, camera );


				// Materials

				const cubeWidth = 400;
				const numberOfSpheresPerSide = 5;
				const sphereRadius = ( cubeWidth / numberOfSpheresPerSide ) * 0.8 * 0.5;
				const stepSize = 1.0 / numberOfSpheresPerSide;

				const geometry = new THREE.SphereGeometry( sphereRadius, 32, 16 );

				for ( let alpha = 0, alphaIndex = 0; alpha <= 1.0; alpha += stepSize, alphaIndex ++ ) {

					const colors = new Uint8Array( alphaIndex + 2 );

					for ( let c = 0; c <= colors.length; c ++ ) {

						colors[ c ] = ( c / colors.length ) * 256;

					}

					const gradientMap = new THREE.DataTexture( colors, colors.length, 1, THREE.RedFormat );
					gradientMap.needsUpdate = true;

					for ( let beta = 0; beta <= 1.0; beta += stepSize ) {

						for ( let gamma = 0; gamma <= 1.0; gamma += stepSize ) {

							// basic monochromatic energy preservation
							const diffuseColor = new THREE.Color().setHSL( alpha, 0.5, gamma * 0.5 + 0.1 ).multiplyScalar( 1 - beta * 0.2 );

							const material = new THREE.MeshToonNodeMaterial( {
								color: diffuseColor,
								gradientMap: gradientMap
							} );

							const mesh = new THREE.Mesh( geometry, material );

							mesh.position.x = alpha * 400 - 200;
							mesh.position.y = beta * 400 - 200;
							mesh.position.z = gamma * 400 - 200;

							scene.add( mesh );

						}

					}

				}

				function addLabel( name, location ) {

					const textGeo = new TextGeometry( name, {

						font: font,

						size: 20,
						depth: 1,
						curveSegments: 1

					} );

					const textMaterial = new THREE.MeshBasicNodeMaterial();
					const textMesh = new THREE.Mesh( textGeo, textMaterial );
					textMesh.position.copy( location );
					scene.add( textMesh );

				}

				addLabel( '-gradientMap', new THREE.Vector3( - 350, 0, 0 ) );
				addLabel( '+gradientMap', new THREE.Vector3( 350, 0, 0 ) );

				addLabel( '-diffuse', new THREE.Vector3( 0, 0, - 300 ) );
				addLabel( '+diffuse', new THREE.Vector3( 0, 0, 300 ) );

				particleLight = new THREE.Mesh(
					new THREE.SphereGeometry( 4, 8, 8 ),
					new THREE.MeshBasicNodeMaterial( { color: 0xffffff } )
				);
				scene.add( particleLight );

				// Lights

				scene.add( new THREE.AmbientLight( 0xc1c1c1, 3 ) );

				const pointLight = new THREE.PointLight( 0xffffff, 2, 800, 0 );
				particleLight.add( pointLight );

				//

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 200;
				controls.maxDistance = 2000;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				const timer = Date.now() * 0.00025;

				particleLight.position.x = Math.sin( timer * 7 ) * 300;
				particleLight.position.y = Math.cos( timer * 5 ) * 400;
				particleLight.position.z = Math.cos( timer * 3 ) * 300;

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_transmission.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>threejs webgpu - transmission</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Transmission</span>
			</div>

			<small>
				Transmissive PBR material.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			const params = {
				color: 0xffffff,
				transmission: 1,
				opacity: 1,
				metalness: 0,
				roughness: 0,
				ior: 1.5,
				thickness: 0.01,
				specularIntensity: 1,
				specularColor: 0xffffff,
				envMapIntensity: 1,
				lightIntensity: 1,
				exposure: 1
			};

			let camera, scene, renderer;

			let mesh;

			const hdrEquirect = new HDRLoader()
				.setPath( 'textures/equirectangular/' )
				.load( 'royal_esplanade_1k.hdr', function () {

					hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;

					init();

				} );

			function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = params.exposure;


				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 0, 120 );

				//

				scene.background = hdrEquirect;

				//

				const geometry = new THREE.SphereGeometry( 20, 64, 32 );

				const texture = new THREE.CanvasTexture( generateTexture() );
				texture.magFilter = THREE.NearestFilter;
				texture.wrapT = THREE.RepeatWrapping;
				texture.wrapS = THREE.RepeatWrapping;
				texture.repeat.set( 1, 3.5 );

				const material = new THREE.MeshPhysicalMaterial( {
					color: params.color,
					metalness: params.metalness,
					roughness: params.roughness,
					ior: params.ior,
					alphaMap: texture,
					envMap: hdrEquirect,
					envMapIntensity: params.envMapIntensity,
					transmission: params.transmission, // use material.transmission for glass materials
					specularIntensity: params.specularIntensity,
					specularColor: params.specularColor,
					opacity: params.opacity,
					side: THREE.DoubleSide,
					transparent: true
				} );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				//

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 10;
				controls.maxDistance = 150;

				window.addEventListener( 'resize', onWindowResize );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.addColor( params, 'color' )
					.onChange( function () {

						material.color.set( params.color );

					} );

				gui.add( params, 'transmission', 0, 1, 0.01 )
					.onChange( function () {

						material.transmission = params.transmission;

					} );

				gui.add( params, 'opacity', 0, 1, 0.01 )
					.onChange( function () {

						material.opacity = params.opacity;

					} );

				gui.add( params, 'metalness', 0, 1, 0.01 )
					.onChange( function () {

						material.metalness = params.metalness;

					} );

				gui.add( params, 'roughness', 0, 1, 0.01 )
					.onChange( function () {

						material.roughness = params.roughness;

					} );

				gui.add( params, 'ior', 1, 2, 0.01 )
					.onChange( function () {

						material.ior = params.ior;

					} );

				gui.add( params, 'thickness', 0, 5, 0.01 )
					.onChange( function () {

						material.thickness = params.thickness;

					} );

				gui.add( params, 'specularIntensity', 0, 1, 0.01 )
					.name( 'specular intensity' )
					.onChange( function () {

						material.specularIntensity = params.specularIntensity;

					} );

				gui.addColor( params, 'specularColor' )
					.name( 'specular color' )
					.onChange( function () {

						material.specularColor.set( params.specularColor );

					} );

				gui.add( params, 'envMapIntensity', 0, 1, 0.01 )
					.name( 'envMap intensity' )
					.onChange( function () {

						material.envMapIntensity = params.envMapIntensity;

					} );

				gui.add( params, 'exposure', 0, 1, 0.01 )
					.onChange( function () {

						renderer.toneMappingExposure = params.exposure;

					} );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			//

			function generateTexture() {

				const canvas = document.createElement( 'canvas' );
				canvas.width = 2;
				canvas.height = 2;

				const context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 1, 2, 1 );

				return canvas;

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materials_video.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - video material</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="overlay">
			<button id="startButton">Play</button>
		</div>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Video Material</span>
			</div>

			<small>
				Playing <a href="http://durian.blender.org/" target="_blank" rel="noopener">sintel</a> trailer.
			</small>
		</div>

		<video id="video" loop crossOrigin="anonymous" playsinline style="display:none">
			<source src="textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
			<source src="textures/sintel.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			let container;

			let camera, scene, renderer;

			let video, texture, material, mesh;

			let mouseX = 0;
			let mouseY = 0;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

			let cube_count;

			const meshes = [],
				materials = [],

				xgrid = 20,
				ygrid = 10;

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {

				init();

			} );

			function init() {

				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 500;

				scene = new THREE.Scene();

				const light = new THREE.DirectionalLight( 0xffffff, 7 );
				light.position.set( 0.5, 1, 1 ).normalize();
				scene.add( light );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				video = document.getElementById( 'video' );
				video.play();
				video.addEventListener( 'play', function () {

					this.currentTime = 3;

				} );

				texture = new THREE.VideoTexture( video );
				texture.colorSpace = THREE.SRGBColorSpace;

				//

				let i, j, ox, oy, geometry;

				const ux = 1 / xgrid;
				const uy = 1 / ygrid;

				const xsize = 480 / xgrid;
				const ysize = 204 / ygrid;

				const parameters = { color: 0xffffff, map: texture };

				cube_count = 0;

				for ( i = 0; i < xgrid; i ++ ) {

					for ( j = 0; j < ygrid; j ++ ) {

						ox = i;
						oy = j;

						geometry = new THREE.BoxGeometry( xsize, ysize, xsize );

						change_uvs( geometry, ux, uy, ox, oy );

						materials[ cube_count ] = new THREE.MeshPhongMaterial( parameters );

						material = materials[ cube_count ];

						material.hue = i / xgrid;
						material.saturation = 1 - j / ygrid;

						material.color.setHSL( material.hue, material.saturation, 0.5 );

						mesh = new THREE.Mesh( geometry, material );

						mesh.position.x = ( i - xgrid / 2 ) * xsize;
						mesh.position.y = ( j - ygrid / 2 ) * ysize;
						mesh.position.z = 0;

						mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;

						scene.add( mesh );

						mesh.dx = 0.001 * ( 0.5 - Math.random() );
						mesh.dy = 0.001 * ( 0.5 - Math.random() );

						meshes[ cube_count ] = mesh;

						cube_count += 1;

					}

				}

				document.addEventListener( 'mousemove', onDocumentMouseMove );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function change_uvs( geometry, unitx, unity, offsetx, offsety ) {

				const uvs = geometry.attributes.uv.array;

				for ( let i = 0; i < uvs.length; i += 2 ) {

					uvs[ i ] = ( uvs[ i ] + offsetx ) * unitx;
					uvs[ i + 1 ] = ( uvs[ i + 1 ] + offsety ) * unity;

				}

			}


			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY ) * 0.3;

			}

			//

			let h, counter = 1;

			function render() {

				const time = Date.now() * 0.00005;

				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

				camera.lookAt( scene.position );

				for ( let i = 0; i < cube_count; i ++ ) {

					material = materials[ i ];

					h = ( 360 * ( material.hue + time ) % 360 ) / 360;
					material.color.setHSL( h, material.saturation, 0.5 );

				}

				if ( counter % 1000 > 200 ) {

					for ( let i = 0; i < cube_count; i ++ ) {

						mesh = meshes[ i ];

						mesh.rotation.x += 10 * mesh.dx;
						mesh.rotation.y += 10 * mesh.dy;

						mesh.position.x -= 150 * mesh.dx;
						mesh.position.y += 150 * mesh.dy;
						mesh.position.z += 300 * mesh.dx;

					}

				}

				if ( counter % 1000 === 0 ) {

					for ( let i = 0; i < cube_count; i ++ ) {

						mesh = meshes[ i ];

						mesh.dx *= - 1;
						mesh.dy *= - 1;

					}

				}

				counter ++;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_materialx_noise.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - materialx noise</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>MaterialX Noise</span>
			</div>

			<small>MaterialX noise functions.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { normalWorld, time, mx_noise_vec3, mx_worley_noise_vec3, mx_cell_noise_float, mx_fractal_noise_vec3 } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';

			let container;

			let camera, scene, renderer;

			let particleLight;
			let group;

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 100;

				scene = new THREE.Scene();

				group = new THREE.Group();
				scene.add( group );

				new HDRCubeTextureLoader()
					.setPath( 'textures/cube/pisaHDR/' )
					.load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],
						function ( hdrTexture ) {

							const geometry = new THREE.SphereGeometry( 8, 64, 32 );

							const customUV = normalWorld.mul( 10 ).add( time );

							// left top

							let material = new THREE.MeshPhysicalNodeMaterial();
							material.colorNode = mx_noise_vec3( customUV );

							let mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = - 10;
							mesh.position.y = 10;
							group.add( mesh );

							// right top

							material = new THREE.MeshPhysicalNodeMaterial();
							material.colorNode = mx_cell_noise_float( customUV );

							mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = 10;
							mesh.position.y = 10;
							group.add( mesh );

							// left bottom

							material = new THREE.MeshPhysicalNodeMaterial();
							material.colorNode = mx_worley_noise_vec3( customUV );

							mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = - 10;
							mesh.position.y = - 10;
							group.add( mesh );

							// right bottom

							material = new THREE.MeshPhysicalNodeMaterial();
							material.colorNode = mx_fractal_noise_vec3( customUV.mul( .2 ) );

							mesh = new THREE.Mesh( geometry, material );
							mesh.position.x = 10;
							mesh.position.y = - 10;
							group.add( mesh );

							//

							scene.background = hdrTexture;
							scene.environment = hdrTexture;

						}

					);

				// LIGHTS

				particleLight = new THREE.Mesh(
					new THREE.SphereGeometry( 0.4, 8, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				scene.add( particleLight );

				particleLight.add( new THREE.PointLight( 0xffffff, 1000 ) );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setAnimationLoop( render );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.25;

				// EVENTS

				new OrbitControls( camera, renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			//

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			//

			function render() {

				const timer = Date.now() * 0.00025;

				particleLight.position.x = Math.sin( timer * 7 ) * 30;
				particleLight.position.y = Math.cos( timer * 5 ) * 40;
				particleLight.position.z = Math.cos( timer * 3 ) * 30;

				for ( let i = 0; i < group.children.length; i ++ ) {

					const child = group.children[ i ];
					child.rotation.y += 0.005;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_mesh_batch.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgpu - batch mesh</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="example.css">
</head>
<body>

	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

		<div class="title-wrapper">
			<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Batch Mesh</span>
		</div>

		<small>Mirror reflections using procedural effects.</small>
	</div>

	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.webgpu.js",
				"three/webgpu": "../build/three.webgpu.js",
				"three/tsl": "../build/three.tsl.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

	<script type="module">

		import * as THREE from 'three/webgpu';

		import { Inspector } from 'three/addons/inspector/Inspector.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { radixSort } from 'three/addons/utils/SortUtils.js';

		import { normalView, directionToColor, diffuseColor } from 'three/tsl';

		let camera, scene, renderer;
		let controls;
		let gui;
		let geometries, mesh, material;
		const ids = [];

		const matrix = new THREE.Matrix4();

		//

		const position = new THREE.Vector3();
		const rotation = new THREE.Euler();
		const quaternion = new THREE.Quaternion();
		const scale = new THREE.Vector3();

		//

		const MAX_GEOMETRY_COUNT = 20000;

		const api = {
			webgpu: true,
			count: 512,
			dynamic: 16,

			sortObjects: true,
			perObjectFrustumCulled: true,
			opacity: 1,
			useCustomSort: true,
			randomizeGeometry: ()=>{

				for ( let i = 0; i < api.count; i ++ ) {

					mesh.setGeometryIdAt( i, Math.floor( Math.random() * geometries.length ) );
		
				}
		
			}
		};


		init();

		//

		function randomizeMatrix( matrix ) {

			position.x = Math.random() * 40 - 20;
			position.y = Math.random() * 40 - 20;
			position.z = Math.random() * 40 - 20;

			rotation.x = Math.random() * 2 * Math.PI;
			rotation.y = Math.random() * 2 * Math.PI;
			rotation.z = Math.random() * 2 * Math.PI;

			quaternion.setFromEuler( rotation );

			scale.x = scale.y = scale.z = 0.5 + ( Math.random() * 0.5 );

			return matrix.compose( position, quaternion, scale );

		}

		function randomizeRotationSpeed( rotation ) {

			rotation.x = Math.random() * 0.01;
			rotation.y = Math.random() * 0.01;
			rotation.z = Math.random() * 0.01;
			return rotation;

		}

		function initGeometries() {

			geometries = [
				new THREE.ConeGeometry( 1.0, 2.0 ),
				new THREE.BoxGeometry( 2.0, 2.0, 2.0 ),
				new THREE.SphereGeometry( 1.0, 16, 8 ),
			];

		}

		function createMaterial() {

			if ( ! material ) {

				material = new THREE.MeshBasicNodeMaterial();
				material.outputNode = diffuseColor.mul( directionToColor( normalView ).y.add( 0.5 ) );
		
	}

			return material;

		}

		function cleanup() {

			if ( mesh ) {

				mesh.parent.remove( mesh );

				if ( mesh.dispose ) {

					mesh.dispose();

				}

			}

		}

		function initMesh() {

			cleanup();
			initBatchedMesh();

		}

		function initBatchedMesh() {

			const geometryCount = api.count;
			const vertexCount = geometries.length * 512;
			const indexCount = geometries.length * 1024;

			const euler = new THREE.Euler();
			const matrix = new THREE.Matrix4();
			mesh = new THREE.BatchedMesh( geometryCount, vertexCount, indexCount, createMaterial() );
			mesh.userData.rotationSpeeds = [];

			// disable full-object frustum culling since all of the objects can be dynamic.
			mesh.frustumCulled = false;

			ids.length = 0;

			const geometryIds = [
				mesh.addGeometry( geometries[ 0 ] ),
				mesh.addGeometry( geometries[ 1 ] ),
				mesh.addGeometry( geometries[ 2 ] ),
			];
			for ( let i = 0; i < api.count; i ++ ) {

				const id = mesh.addInstance( geometryIds[ i % geometryIds.length ] );
				mesh.setMatrixAt( id, randomizeMatrix( matrix ) );
				mesh.setColorAt( id, new THREE.Color( Math.random() * 0xffffff ) );

				const rotationMatrix = new THREE.Matrix4();
				rotationMatrix.makeRotationFromEuler( randomizeRotationSpeed( euler ) );
				mesh.userData.rotationSpeeds.push( rotationMatrix );

				ids.push( id );

			}

			scene.add( mesh );

		}

		function init( forceWebGL = false ) {

			if ( renderer ) {

				renderer.dispose();
				controls.dispose();
				document.body.removeChild( renderer.domElement );

			}

			// camera

			const aspect = window.innerWidth / window.innerHeight;

			camera = new THREE.PerspectiveCamera( 70, aspect, 1, 100 );
			camera.position.z = 30;

			// renderer

			renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.inspector = new Inspector();
			renderer.setAnimationLoop( animate );

			// scene

			scene = new THREE.Scene();
			scene.background = forceWebGL ? new THREE.Color( 0xffc1c1 ) : new THREE.Color( 0xc1c1ff );

			document.body.appendChild( renderer.domElement );



			initGeometries();
			initMesh();

			// controls

			controls = new OrbitControls( camera, renderer.domElement );
			controls.autoRotate = true;
			controls.autoRotateSpeed = 1.0;

			// gui

			gui = renderer.inspector.createParameters( 'Settings' );
			gui.add( api, 'webgpu' ).onChange( () => {

				init( ! api.webgpu );

			} );
			gui.add( api, 'count', 1, MAX_GEOMETRY_COUNT, 1 ).onChange( initMesh );
			gui.add( api, 'dynamic', 0, MAX_GEOMETRY_COUNT, 1 );

			gui.add( api, 'opacity', 0, 1 ).onChange( v => {

				if ( v < 1 ) {

					material.transparent = true;
					material.depthWrite = false;

				} else {

					material.transparent = false;
					material.depthWrite = true;

				}

				material.opacity = v;
				material.needsUpdate = true;

			} );
			gui.add( api, 'sortObjects' );
			gui.add( api, 'perObjectFrustumCulled' );
			gui.add( api, 'useCustomSort' );
			gui.add( api, 'randomizeGeometry' ).name( 'randomize geometry' );


			// listeners

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}


			async function animate() {

				animateMeshes();

				controls.update();

				if ( mesh.isBatchedMesh ) {

					mesh.sortObjects = api.sortObjects;
					mesh.perObjectFrustumCulled = api.perObjectFrustumCulled;
					mesh.setCustomSort( api.useCustomSort ? sortFunction : null );

				}

				renderer.render( scene, camera );

			}

			function animateMeshes() {

				const loopNum = Math.min( api.count, api.dynamic );


				for ( let i = 0; i < loopNum; i ++ ) {

					const rotationMatrix = mesh.userData.rotationSpeeds[ i ];
					const id = ids[ i ];

					mesh.getMatrixAt( id, matrix );
					matrix.multiply( rotationMatrix );
					mesh.setMatrixAt( id, matrix );

				}

			}

		}

		//

		function sortFunction( list, camera ) {

			// initialize options
			this._options = this._options || {
				get: el => el.z,
				aux: new Array( this.maxInstanceCount )
			};

			const options = this._options;
			options.reversed = this.material.transparent;

			// convert depth to unsigned 32 bit range
			const factor = ( 2 ** 32 - 1 ) / camera.far; // UINT32_MAX / max_depth
			for ( let i = 0, l = list.length; i < l; i ++ ) {

				list[ i ].z *= factor;

			}

			// perform a fast-sort using the hybrid radix sort function
			radixSort( list, options );

		}

	</script>

</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_mirror.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - mirror</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Mirror</span>
			</div>

			<small>Mirror reflections using procedural effects.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { reflector, uv, texture, color } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			let cameraControls;

			let sphereGroup, smallSphere;

			init();

			function init() {

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
				camera.position.set( 0, 75, 160 );

				//

				let geometry, material;

				//

				sphereGroup = new THREE.Object3D();
				scene.add( sphereGroup );

				geometry = new THREE.CylinderGeometry( 0.1, 15 * Math.cos( Math.PI / 180 * 30 ), 0.1, 24, 1 );
				material = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x8d8d8d } );
				const sphereCap = new THREE.Mesh( geometry, material );
				sphereCap.position.y = - 15 * Math.sin( Math.PI / 180 * 30 ) - 0.05;
				sphereCap.rotateX( - Math.PI );

				geometry = new THREE.SphereGeometry( 15, 24, 24, Math.PI / 2, Math.PI * 2, 0, Math.PI / 180 * 120 );
				const halfSphere = new THREE.Mesh( geometry, material );
				halfSphere.add( sphereCap );
				halfSphere.rotateX( - Math.PI / 180 * 135 );
				halfSphere.rotateZ( - Math.PI / 180 * 20 );
				halfSphere.position.y = 7.5 + 15 * Math.sin( Math.PI / 180 * 30 );

				sphereGroup.add( halfSphere );

				geometry = new THREE.IcosahedronGeometry( 5, 0 );
				material = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x7b7b7b, flatShading: true } );
				smallSphere = new THREE.Mesh( geometry, material );
				scene.add( smallSphere );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );
				floorNormal.wrapS = THREE.RepeatWrapping;
				floorNormal.wrapT = THREE.RepeatWrapping;

				const decalDiffuse = textureLoader.load( 'textures/decal/decal-diffuse.png' );
				decalDiffuse.colorSpace = THREE.SRGBColorSpace;

				const decalNormal = textureLoader.load( 'textures/decal/decal-normal.jpg' );

				// reflectors / mirrors

				const groundReflector = reflector().toInspector( 'Ground Reflector' );
				const verticalReflector = reflector().toInspector( 'Vertical Reflector' );

				const groundNormalScale = - 0.08;
				const verticalNormalScale = 0.1;

				const groundUVOffset = texture( decalNormal ).xy.mul( 2 ).sub( 1 ).mul( groundNormalScale );
				const verticalUVOffset = texture( floorNormal, uv().mul( 5 ) ).xy.mul( 2 ).sub( 1 ).mul( verticalNormalScale );

				groundReflector.uvNode = groundReflector.uvNode.add( groundUVOffset );
				verticalReflector.uvNode = verticalReflector.uvNode.add( verticalUVOffset );

				const groundNode = texture( decalDiffuse ).a.mix( color( 0xffffff ), groundReflector );
				const verticalNode = color( 0x0000ff ).mul( .1 ).add( verticalReflector );

				// walls

				const planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );

				//

				const planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongNodeMaterial( {
					colorNode: groundNode
				} ) );
				planeBottom.rotateX( - Math.PI / 2 );
				planeBottom.add( groundReflector.target );
				scene.add( planeBottom );

				const planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongNodeMaterial( {
					colorNode: verticalNode
				} ) );
				planeBack.position.z = - 50;
				planeBack.position.y = 50;
				planeBack.add( verticalReflector.target );
				scene.add( planeBack );

				//

				const planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
				planeTop.position.y = 100;
				planeTop.rotateX( Math.PI / 2 );
				scene.add( planeTop );

				const planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );
				planeFront.position.z = 50;
				planeFront.position.y = 50;
				planeFront.rotateY( Math.PI );
				scene.add( planeFront );

				const planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );
				planeRight.position.x = 50;
				planeRight.position.y = 50;
				planeRight.rotateY( - Math.PI / 2 );
				scene.add( planeRight );

				const planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );
				planeLeft.position.x = - 50;
				planeLeft.position.y = 50;
				planeLeft.rotateY( Math.PI / 2 );
				scene.add( planeLeft );

				// lights

				const mainLight = new THREE.PointLight( 0xe7e7e7, 2.5, 250, 0 );
				mainLight.position.y = 60;
				scene.add( mainLight );

				const greenLight = new THREE.PointLight( 0x00ff00, 0.5, 1000, 0 );
				greenLight.position.set( 550, 50, 0 );
				scene.add( greenLight );

				const redLight = new THREE.PointLight( 0xff0000, 0.5, 1000, 0 );
				redLight.position.set( - 550, 50, 0 );
				scene.add( redLight );

				const blueLight = new THREE.PointLight( 0xbbbbfe, 0.5, 1000, 0 );
				blueLight.position.set( 0, 50, 550 );
				scene.add( blueLight );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				cameraControls = new OrbitControls( camera, renderer.domElement );
				cameraControls.target.set( 0, 40, 0 );
				cameraControls.maxDistance = 400;
				cameraControls.minDistance = 10;
				cameraControls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const timer = Date.now() * 0.01;

				sphereGroup.rotation.y -= 0.002;

				smallSphere.position.set(
					Math.cos( timer * 0.1 ) * 30,
					Math.abs( Math.cos( timer * 0.2 ) ) * 20 + 5,
					Math.sin( timer * 0.1 ) * 30
				);
				smallSphere.rotation.y = ( Math.PI / 2 ) - timer * 0.1;
				smallSphere.rotation.z = timer * 0.8;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_modifier_curve.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - curve modifier</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="example.css" />
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Curve Modifier</span>
			</div>

			<small>Deform a mesh along a curve using GPU acceleration.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { TransformControls } from 'three/addons/controls/TransformControls.js';

			import { Flow } from 'three/addons/modifiers/CurveModifierGPU.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

			const ACTION_SELECT = 1, ACTION_NONE = 0;
			const curveHandles = [];
			const mouse = new THREE.Vector2();

			let scene,
				camera,
				renderer,
				rayCaster,
				control,
				flow,
				action = ACTION_NONE;

			init();

			function init() {

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(
					40,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.set( 2, 2, 4 );
				camera.lookAt( scene.position );

				const initialPoints = [
					{ x: 1, y: 0, z: - 1 },
					{ x: 1, y: 0, z: 1 },
					{ x: - 1, y: 0, z: 1 },
					{ x: - 1, y: 0, z: - 1 },
				];

				const boxGeometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );
				const boxMaterial = new THREE.MeshBasicNodeMaterial();

				for ( const handlePos of initialPoints ) {

					const handle = new THREE.Mesh( boxGeometry, boxMaterial );
					handle.position.copy( handlePos );
					curveHandles.push( handle );
					scene.add( handle );

				}

				const curve = new THREE.CatmullRomCurve3(
					curveHandles.map( ( handle ) => handle.position )
				);
				curve.curveType = 'centripetal';
				curve.closed = true;

				const points = curve.getPoints( 50 );
				const line = new THREE.Line(
					new THREE.BufferGeometry().setFromPoints( points ),
					new THREE.LineBasicMaterial( { color: 0x00ff00 } )
				);

				scene.add( line );

				//

				const light = new THREE.DirectionalLight( 0xffaa33, 3 );
				light.position.set( - 10, 10, 10 );
				scene.add( light );

				const light2 = new THREE.AmbientLight( 0x003973, 3 );
				scene.add( light2 );

				//

				const loader = new FontLoader();
				loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

					const geometry = new TextGeometry( 'Hello three.js!', {
						font: font,
						size: 0.2,
						depth: 0.05,
						curveSegments: 12,
						bevelEnabled: true,
						bevelThickness: 0.02,
						bevelSize: 0.01,
						bevelOffset: 0,
						bevelSegments: 5,
					} );

					geometry.rotateX( Math.PI );

					const material = new THREE.MeshStandardNodeMaterial( {
						color: 0x99ffff
					} );

					const objectToCurve = new THREE.Mesh( geometry, material );

					flow = new Flow( objectToCurve );
					flow.updateCurve( 0, curve );
					scene.add( flow.object3D );

				} );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				renderer.domElement.addEventListener( 'pointerdown', onPointerDown );

				rayCaster = new THREE.Raycaster();
				control = new TransformControls( camera, renderer.domElement );
				control.addEventListener( 'dragging-changed', function ( event ) {

					if ( ! event.value ) {

						const points = curve.getPoints( 50 );
						line.geometry.setFromPoints( points );
						flow.updateCurve( 0, curve );

					}

				} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerDown( event ) {

				action = ACTION_SELECT;
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function animate() {

				if ( action === ACTION_SELECT ) {

					rayCaster.setFromCamera( mouse, camera );
					action = ACTION_NONE;
					const intersects = rayCaster.intersectObjects( curveHandles, false );
					if ( intersects.length ) {

						const target = intersects[ 0 ].object;
						control.attach( target );
						scene.add( control.getHelper() );

					}

				}

				if ( flow ) {

					flow.moveAlongCurve( 0.001 );

				}

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}
		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_morphtargets.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - morph targets</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>
		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Morph Targets</span>
			</div>

			<small>
				Morph targets / blend shapes example with a simple geometry.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let container, camera, scene, renderer, mesh;

			init();

			function init() {

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x8FBCD4 );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );
				camera.position.z = 10;
				scene.add( camera );

				scene.add( new THREE.AmbientLight( 0x8FBCD4, 1.5 ) );

				const pointLight = new THREE.PointLight( 0xffffff, 200 );
				camera.add( pointLight );

				const geometry = createGeometry();

				const material = new THREE.MeshPhongMaterial( {
					color: 0xff0000,
					flatShading: true
				} );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.inspector = new Inspector();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( function () {

					renderer.render( scene, camera );

				} );
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.enableZoom = false;

				window.addEventListener( 'resize', onWindowResize );

				initGUI();

			}

			function createGeometry() {

				const geometry = new THREE.BoxGeometry( 2, 2, 2, 32, 32, 32 );

				// create an empty array to hold targets for the attribute we want to morph
				// morphing positions and normals is supported
				geometry.morphAttributes.position = [];

				// the original positions of the cube's vertices
				const positionAttribute = geometry.attributes.position;

				// for the first morph target we'll move the cube's vertices onto the surface of a sphere
				const spherePositions = [];

				// for the second morph target, we'll twist the cubes vertices
				const twistPositions = [];
				const direction = new THREE.Vector3( 1, 0, 0 );
				const vertex = new THREE.Vector3();

				for ( let i = 0; i < positionAttribute.count; i ++ ) {

					const x = positionAttribute.getX( i );
					const y = positionAttribute.getY( i );
					const z = positionAttribute.getZ( i );

					spherePositions.push(

						x * Math.sqrt( 1 - ( y * y / 2 ) - ( z * z / 2 ) + ( y * y * z * z / 3 ) ),
						y * Math.sqrt( 1 - ( z * z / 2 ) - ( x * x / 2 ) + ( z * z * x * x / 3 ) ),
						z * Math.sqrt( 1 - ( x * x / 2 ) - ( y * y / 2 ) + ( x * x * y * y / 3 ) )

					);

					// stretch along the x-axis so we can see the twist better
					vertex.set( x * 2, y, z );

					vertex.applyAxisAngle( direction, Math.PI * x / 2 ).toArray( twistPositions, twistPositions.length );

				}

				// add the spherical positions as the first morph target
				geometry.morphAttributes.position[ 0 ] = new THREE.Float32BufferAttribute( spherePositions, 3 );

				// add the twisted positions as the second morph target
				geometry.morphAttributes.position[ 1 ] = new THREE.Float32BufferAttribute( twistPositions, 3 );

				return geometry;

			}

			function initGUI() {

				// Set up dat.GUI to control targets
				const params = {
					Spherify: 0,
					Twist: 0,
				};

				const gui = renderer.inspector.createParameters( 'Morph Targets' );

				gui.add( params, 'Spherify', 0, 1, 0.01 ).onChange( function ( value ) {

					mesh.morphTargetInfluences[ 0 ] = value;

				} );
				gui.add( params, 'Twist', 0, 1, 0.01 ).onChange( function ( value ) {

					mesh.morphTargetInfluences[ 1 ] = value;

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_morphtargets_face.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - morph face targets</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #666666;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - morph face targets<br/>
			model by <a href="https://www.bannaflak.com/face-cap" target="_blank" rel="noopener">Face Cap</a>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
			import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			init();

			async function init() {

				let mixer;

				const clock = new THREE.Clock();

				const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );
				camera.position.set( - 1.8, 0.8, 3 );

				const scene = new THREE.Scene();

				const renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene.background = new THREE.Color( 0x666666 );
				scene.environment = pmremGenerator.fromScene( environment ).texture;

				const ktx2Loader = await new KTX2Loader()
					.setTranscoderPath( 'jsm/libs/basis/' )
					.detectSupport( renderer );

				new GLTFLoader()
					.setKTX2Loader( ktx2Loader )
					.setMeshoptDecoder( MeshoptDecoder )
					.load( 'models/gltf/facecap.glb', ( gltf ) => {

						const mesh = gltf.scene.children[ 0 ];

						scene.add( mesh );

						mixer = new THREE.AnimationMixer( mesh );

						mixer.clipAction( gltf.animations[ 0 ] ).play();

						// GUI

						const head = mesh.getObjectByName( 'mesh_2' );
						const influences = head.morphTargetInfluences;

						const gui = renderer.inspector.createParameters( 'Morph Targets' );

						for ( const [ key, value ] of Object.entries( head.morphTargetDictionary ) ) {

							gui.add( influences, value, 0, 1, 0.01 )
								.name( key.replace( 'blendShape1.', '' ) )
								.listen();

						}

					} );

				scene.background = new THREE.Color( 0x666666 );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 2.5;
				controls.maxDistance = 5;
				controls.minAzimuthAngle = - Math.PI / 2;
				controls.maxAzimuthAngle = Math.PI / 2;
				controls.maxPolarAngle = Math.PI / 1.8;
				controls.target.set( 0, 0.15, - 0.2 );

				function animate() {

					const delta = clock.getDelta();

					if ( mixer ) {

						mixer.update( delta );

					}

					renderer.render( scene, camera );

					controls.update();

				}

				window.addEventListener( 'resize', () => {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

				} );

			}
		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_mrt.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - mrt</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Multiple Render Targets (MRT)</span>
			</div>

			<small>
				Final / Beauty / Normal / Emissive / Diffuse
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { output, normalView, pass, step, diffuseColor, emissive, directionToColor, screenUV, mix, mrt, Fn } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;
			let postProcessing;

			init();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				// scene

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, 0.6, 2.7 );

				scene = new THREE.Scene();

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.background = texture;
						scene.environment = texture;

						// model

						const loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
						loader.load( 'DamagedHelmet.gltf', function ( gltf ) {

							scene.add( gltf.scene );

						} );

					} );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				// post processing

				const scenePass = pass( scene, camera, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter } );
				scenePass.setMRT( mrt( {
					output: output,
					normal: directionToColor( normalView ),
					diffuse: diffuseColor,
					emissive: emissive
				} ) );

				// optimize textures

				const normalTexture = scenePass.getTexture( 'normal' );
				const diffuseTexture = scenePass.getTexture( 'diffuse' );
				const emissiveTexture = scenePass.getTexture( 'emissive' );

				normalTexture.type = diffuseTexture.type = emissiveTexture.type = THREE.UnsignedByteType;

				// post processing - mrt

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputColorTransform = false;
				postProcessing.outputNode = Fn( () => {

					const output = scenePass.getTextureNode( 'output' ); // output name is optional here
					const normal = scenePass.getTextureNode( 'normal' );
					const diffuse = scenePass.getTextureNode( 'diffuse' );
					const emissive = scenePass.getTextureNode( 'emissive' );

					const out = mix( output.renderOutput(), output, step( 0.2, screenUV.x ) );
					const nor = mix( out, normal, step( 0.4, screenUV.x ) );
					const emi = mix( nor, emissive, step( 0.6, screenUV.x ) );
					const dif = mix( emi, diffuse, step( 0.8, screenUV.x ) );

					return dif;

				} )();

				// controls

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.target.set( 0, 0, - 0.2 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_mrt_mask.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - mrt mask</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>MRT Mask</span>
			</div>

			<small>
				The mask is applied followed by a gaussian blur only on some selected materials.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, screenUV, mrt, output, pass, vec4 } from 'three/tsl';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;
			let postProcessing;
			let spheres, rotate = true;
			let mixer, clock;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.set( 1, 2, 3 );

				scene = new THREE.Scene();
				scene.backgroundNode = screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) ).mul( .05 );
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				// lights

				const light = new THREE.SpotLight( 0xffffff, 1 );
				light.power = 2000;
				camera.add( light );
				scene.add( camera );

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					const object = gltf.scene;
					mixer = new THREE.AnimationMixer( object );

					const material = object.children[ 0 ].children[ 0 ].material;

					// add glow effect
					material.mrtNode = mrt( { mask: output.add( 1 ) } );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					scene.add( object );

				} );

				// spheres

				const geometry = new THREE.SphereGeometry( .3, 32, 16 );

				spheres = new THREE.Group();
				scene.add( spheres );

				function addSphere( color, mrtNode = null ) {

					const distance = 1;
					const id = spheres.children.length;
					const rotation = THREE.MathUtils.degToRad( id * 90 );

					const material = new THREE.MeshStandardNodeMaterial( { color } );
					material.mrtNode = mrtNode;

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.set(
						Math.cos( rotation ) * distance,
						1,
						Math.sin( rotation ) * distance
					);

					spheres.add( mesh );

				}

				addSphere( 0x0000ff, mrt( { mask: output } ) );
				addSphere( 0x00ff00 );
				addSphere( 0xff0000 );
				addSphere( 0x00ffff );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 0.4;
				document.body.appendChild( renderer.domElement );

				// post processing

				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output: output.renderOutput(),
					mask: vec4( 0 ) // empty as default, custom materials can set this
				} ) );

				const colorPass = scenePass.getTextureNode();
				const maskPass = scenePass.getTextureNode( 'mask' );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputColorTransform = false;
				postProcessing.outputNode = colorPass.add( gaussianBlur( maskPass, 1, 20 ).mul( .3 ) ).renderOutput();

				// controls

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 1, 0 );
				controls.addEventListener( 'start', () => rotate = false );
				controls.addEventListener( 'end', () => rotate = true );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				if ( mixer ) mixer.update( delta );

				if ( rotate ) spheres.rotation.y += delta * 0.5;

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_multiple_canvas.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - multiple canvas</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>

			* {
				box-sizing: border-box;
				-moz-box-sizing: border-box;
			}

			body {
				background-color: #fff;
				color: #444;
			}

			a {
				color: #08f;
			}

			#content {
				position: absolute;
				top: 0; width: 100%;
				z-index: 1;
				padding: 3em 0 0 0;
			}

			.list-item {
				display: inline-block;
				margin: 1em;
				padding: 1em;
				box-shadow: 1px 2px 4px 0px rgba(0,0,0,0.25);
			}

			.list-item > canvas:nth-child(1) {
				width: 200px;
				height: 200px;
			}

			.list-item > div:nth-child(2) {
				color: #888;
				font-family: sans-serif;
				font-size: large;
				width: 200px;
				margin-top: 0.5em;
			}

		</style>
	</head>
	<body>

		<div id="content">
			<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - multiple canvas</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { color } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			//

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			//

			let renderer;

			const scenes = [];

			init();

			function init() {

				const geometries = [
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.SphereGeometry( 0.5, 12, 8 ),
					new THREE.DodecahedronGeometry( 0.5 ),
					new THREE.CylinderGeometry( 0.5, 0.5, 1, 12 )
				];

				const content = document.getElementById( 'content' );

				for ( let i = 0; i < 40; i ++ ) {

					const scene = new THREE.Scene();
					scene.backgroundNode = color( 0xeeeeee );

					// make a list item
					const element = document.createElement( 'div' );
					element.className = 'list-item';

					const sceneCanvas = document.createElement( 'canvas' );
					element.appendChild( sceneCanvas );

					const descriptionElement = document.createElement( 'div' );
					descriptionElement.innerText = 'Scene ' + ( i + 1 );
					element.appendChild( descriptionElement );

					const canvasTarget = new THREE.CanvasTarget( sceneCanvas );
					canvasTarget.setPixelRatio( window.devicePixelRatio );
					canvasTarget.setSize( 200, 200 );

					// the element that represents the area we want to render the scene
					scene.userData.canvasTarget = canvasTarget;
					content.appendChild( element );

					const camera = new THREE.PerspectiveCamera( 50, 1, 1, 10 );
					camera.position.z = 2;
					scene.userData.camera = camera;

					const controls = new OrbitControls( scene.userData.camera, scene.userData.canvasTarget.domElement );
					controls.minDistance = 2;
					controls.maxDistance = 5;
					controls.enablePan = false;
					controls.enableZoom = false;
					scene.userData.controls = controls;

					// add one random mesh to each scene
					const geometry = geometries[ geometries.length * Math.random() | 0 ];

					const material = new THREE.MeshStandardMaterial( {

						color: new THREE.Color().setHSL( Math.random(), 1, 0.75, THREE.SRGBColorSpace ),
						roughness: 0.5,
						metalness: 0,
						flatShading: true

					} );

					scene.add( new THREE.Mesh( geometry, material ) );

					scene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444, 3 ) );

					const light = new THREE.DirectionalLight( 0xffffff, 1.5 );
					light.position.set( 1, 1, 1 );
					scene.add( light );

					scenes.push( scene );

				}

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setClearColor( 0xffffff, 1 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setAnimationLoop( animate );

			}

			function animate() {

				scenes.forEach( function ( scene ) {

					// so something moves
					//scene.children[ 0 ].rotation.y = Date.now() * 0.001;

					// get the canvas and camera for this scene
					const { canvasTarget, camera } = scene.userData;

					//camera.aspect = width / height; // not changing in this example
					//camera.updateProjectionMatrix();

					//scene.userData.controls.update();

					renderer.setCanvasTarget( canvasTarget );
					renderer.render( scene, camera );

				} );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_multiple_elements.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - multiple elements</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>

			* {
				box-sizing: border-box;
				-moz-box-sizing: border-box;
			}

			body {
				background-color: #fff;
				color: #444;
			}

			a {
				color: #08f;
			}

			#content {
				position: absolute;
				top: 0; width: 100%;
				z-index: 1;
				padding: 3em 0 0 0;
			}

			#c {
				position: absolute;
				left: 0;
				width: 100%;
				height: 100%;
			}

			.list-item {
				display: inline-block;
				margin: 1em;
				padding: 1em;
				box-shadow: 1px 2px 4px 0px rgba(0,0,0,0.25);
			}

			.list-item > div:nth-child(1) {
				width: 200px;
				height: 200px;
			}

			.list-item > div:nth-child(2) {
				color: #888;
				font-family: sans-serif;
				font-size: large;
				width: 200px;
				margin-top: 0.5em;
			}

		</style>
	</head>
	<body>

		<canvas id="c"></canvas>

		<div id="content">
			<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - multiple elements</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { color } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let canvas, renderer;

			const scenes = [];

			init();

			function init() {

				canvas = document.getElementById( 'c' );

				const geometries = [
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.SphereGeometry( 0.5, 12, 8 ),
					new THREE.DodecahedronGeometry( 0.5 ),
					new THREE.CylinderGeometry( 0.5, 0.5, 1, 12 )
				];

				const content = document.getElementById( 'content' );

				for ( let i = 0; i < 40; i ++ ) {

					const scene = new THREE.Scene();
					scene.backgroundNode = color( 0xeeeeee );

					// make a list item
					const element = document.createElement( 'div' );
					element.className = 'list-item';

					const sceneElement = document.createElement( 'div' );
					element.appendChild( sceneElement );

					const descriptionElement = document.createElement( 'div' );
					descriptionElement.innerText = 'Scene ' + ( i + 1 );
					element.appendChild( descriptionElement );

					// the element that represents the area we want to render the scene
					scene.userData.element = sceneElement;
					content.appendChild( element );

					const camera = new THREE.PerspectiveCamera( 50, 1, 1, 10 );
					camera.position.z = 2;
					scene.userData.camera = camera;

					const controls = new OrbitControls( scene.userData.camera, scene.userData.element );
					controls.minDistance = 2;
					controls.maxDistance = 5;
					controls.enablePan = false;
					controls.enableZoom = false;
					scene.userData.controls = controls;

					// add one random mesh to each scene
					const geometry = geometries[ geometries.length * Math.random() | 0 ];

					const material = new THREE.MeshStandardMaterial( {

						color: new THREE.Color().setHSL( Math.random(), 1, 0.75, THREE.SRGBColorSpace ),
						roughness: 0.5,
						metalness: 0,
						flatShading: true

					} );

					scene.add( new THREE.Mesh( geometry, material ) );

					scene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444, 3 ) );

					const light = new THREE.DirectionalLight( 0xffffff, 1.5 );
					light.position.set( 1, 1, 1 );
					scene.add( light );

					scenes.push( scene );

				}


				renderer = new THREE.WebGPURenderer( { canvas: canvas, antialias: true } );
				renderer.setClearColor( 0xffffff, 1 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setAnimationLoop( animate );

			}

			function updateSize() {

				const width = canvas.clientWidth;
				const height = canvas.clientHeight;

				if ( canvas.width !== width || canvas.height !== height ) {

					renderer.setSize( width, height, false );

				}

			}

			function animate() {

				updateSize();

				canvas.style.transform = `translateY(${window.scrollY}px)`;

				renderer.setClearColor( 0xffffff );
				renderer.setScissorTest( false );
				renderer.setViewport( 0, 0, canvas.width, canvas.height );
				renderer.clear();

				//renderer.setClearColor( 0xe0e0e0 );
				renderer.setScissorTest( true );

				scenes.forEach( function ( scene ) {

					// so something moves
					scene.children[ 0 ].rotation.y = Date.now() * 0.001;

					// get the element that is a place holder for where we want to
					// draw the scene
					const element = scene.userData.element;

					// get its position relative to the page's viewport
					const rect = element.getBoundingClientRect();

					// check if it's offscreen. If so skip it
					if ( rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||
						 rect.right < 0 || rect.left > renderer.domElement.clientWidth ) {

						return; // it's off screen

					}

					// set the viewport
					const width = rect.right - rect.left;
					const height = rect.bottom - rect.top;
					const left = rect.left;
					const top = rect.top;

					renderer.setViewport( left, top, width, height );
					renderer.setScissor( left, top, width, height );

					const camera = scene.userData.camera;

					//camera.aspect = width / height; // not changing in this example
					//camera.updateProjectionMatrix();

					//scene.userData.controls.update();

					renderer.render( scene, camera );

				} );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_multiple_rendertargets.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - multiple render targets</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Multiple Render Targets</span>
			</div>

			<small>
				Using multiple render targets to output color and normals to separate buffers.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mix, vec2, step, texture, uv, screenUV, normalWorld, output, mrt } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, torus;
			let postProcessing, renderTarget;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				// Create a multi render target with Float buffers

				renderTarget = new THREE.RenderTarget(
					window.innerWidth * window.devicePixelRatio,
					window.innerHeight * window.devicePixelRatio,
					{ count: 2, minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter }
				);

				// Name our G-Buffer attachments for debugging

				renderTarget.textures[ 0 ].name = 'output';
				renderTarget.textures[ 1 ].name = 'normal';

				// Scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
				camera.position.z = 4;

				const loader = new THREE.TextureLoader();

				const diffuse = loader.load( 'textures/hardwood2_diffuse.jpg' );
				diffuse.colorSpace = THREE.SRGBColorSpace;
				diffuse.wrapS = THREE.RepeatWrapping;
				diffuse.wrapT = THREE.RepeatWrapping;

				const torusMaterial = new THREE.NodeMaterial();
				torusMaterial.colorNode = texture( diffuse, uv().mul( vec2( 10, 4 ) ) );

				torus = new THREE.Mesh( new THREE.TorusKnotGeometry( 1, 0.3, 128, 32 ), torusMaterial );
				scene.add( torus );

				// MRT

				renderer.setMRT( mrt( {
					'output': output,
					'normal': normalWorld
				} ) );

				// Post Processing

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = mix( texture( renderTarget.textures[ 0 ] ), texture( renderTarget.textures[ 1 ] ), step( 0.5, screenUV.x ) );

				// Controls

				new OrbitControls( camera, renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				const dpr = renderer.getPixelRatio();
				renderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );

			}

			function render( time ) {

				torus.rotation.y = ( time / 1000 ) * .4;

				// render scene into target
				renderer.setRenderTarget( renderTarget );
				renderer.render( scene, camera );

				// render post FX
				renderer.setRenderTarget( null );
				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_multiple_rendertargets_readback.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - mrt readback</title>
		<meta charset="utf-8">
		<link rel="shortcut icon" href="#">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Multiple Render Targets</span>
			</div>

			<small>
				Using multiple render targets to output color and normals to separate buffers.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mix, step, texture, screenUV, mrt, output, normalWorld, uv, vec2 } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, torus;
			let quadMesh, sceneMRT, renderTarget, readbackTarget, material, readbackMaterial, pixelBuffer, pixelBufferTexture;

			const options = {
				selection: 'mrt',
			};

			init();

			function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				//

				renderer.inspector = new Inspector();

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( options, 'selection', [ 'mrt', 'diffuse', 'normal' ] );

				// Create a multi render target with Float buffers

				renderTarget = new THREE.RenderTarget(
					window.innerWidth * window.devicePixelRatio,
					window.innerHeight * window.devicePixelRatio,
					{ count: 2, minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter }
				);

				// Name our G-Buffer attachments for debugging

				renderTarget.textures[ 0 ].name = 'output';
				renderTarget.textures[ 1 ].name = 'normal';

				// Init readback render target, readback data texture, readback material
				// Be careful with the size! 512 is already big. Reading data back from the GPU is computationally intensive

				const size = 512;

				readbackTarget = new THREE.RenderTarget( size, size, { count: 2 } );

				pixelBuffer = new Uint8Array( size ** 2 * 4 ).fill( 0 );
				pixelBufferTexture = new THREE.DataTexture( pixelBuffer, size, size );
				pixelBufferTexture.type = THREE.UnsignedByteType;
				pixelBufferTexture.format = THREE.RGBAFormat;

				readbackMaterial = new THREE.MeshBasicNodeMaterial();
				readbackMaterial.colorNode = texture( pixelBufferTexture );

				// MRT

				sceneMRT = mrt( {
					'output': output,
					'normal': normalWorld
				} );

				// Scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
				camera.position.z = 4;

				const loader = new THREE.TextureLoader();

				const diffuse = loader.load( 'textures/hardwood2_diffuse.jpg' );
				diffuse.colorSpace = THREE.SRGBColorSpace;
				diffuse.wrapS = THREE.RepeatWrapping;
				diffuse.wrapT = THREE.RepeatWrapping;

				const torusMaterial = new THREE.NodeMaterial();
				torusMaterial.colorNode = texture( diffuse, uv().mul( vec2( 10, 4 ) ) );

				torus = new THREE.Mesh( new THREE.TorusKnotGeometry( 1, 0.3, 128, 32 ), torusMaterial );
				scene.add( torus );

				// Output

				material = new THREE.NodeMaterial();
				material.colorNode = mix( texture( renderTarget.textures[ 0 ] ), texture( renderTarget.textures[ 1 ] ), step( 0.5, screenUV.x ) );

				quadMesh = new THREE.QuadMesh( material );

				// Controls

				new OrbitControls( camera, renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				const dpr = renderer.getPixelRatio();
				renderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );

			}

			async function render( time ) {

				const selection = options.selection;

				torus.rotation.y = ( time / 1000 ) * .4;

				const isMRT = selection === 'mrt';

				// render scene into target
				renderer.setMRT( isMRT ? sceneMRT : null );
				renderer.setRenderTarget( isMRT ? renderTarget : readbackTarget );
				renderer.render( scene, camera );

				// render post FX
				renderer.setMRT( null );
				renderer.setRenderTarget( null );

				if ( isMRT ) {

					quadMesh.material = material;

				} else {

					quadMesh.material = readbackMaterial;

					await readback();

				}

				quadMesh.render( renderer );

			}

			async function readback() {

				const width = readbackTarget.width;
				const height = readbackTarget.height;

				const selection = options.selection;

				if ( selection === 'diffuse' ) {

					pixelBuffer = await renderer.readRenderTargetPixelsAsync( readbackTarget, 0, 0, width, height, 0 ); // zero is optional

					pixelBufferTexture.image.data = pixelBuffer;
					pixelBufferTexture.needsUpdate = true;

				} else if ( selection === 'normal' ) {

					pixelBuffer = await renderer.readRenderTargetPixelsAsync( readbackTarget, 0, 0, width, height, 1 );

					pixelBufferTexture.image.data = pixelBuffer;
					pixelBufferTexture.needsUpdate = true;

				}

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_multisampled_renderbuffers.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - multisampled renderbuffers</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Multisampled Renderbuffers</span>
			</div>

			<small>
				Using multisampled renderbuffers for anti-aliasing.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			const mouse = new THREE.Vector2();

			let quadMesh, renderTarget;

			let box, box2;

			const dpr = 1;

			const params = {
				animated: true,
				samples: 4
			};

			const mat4 = new THREE.Matrix4();

			const count = 50;
			const fullRadius = 20; // Radius of the sphere
			const halfRadius = 10; // Radius of the sphere
			const positions = new Array( count ).fill().map( ( _, i ) => {

				const radius = ( i % 2 === 0 ) ? fullRadius : halfRadius;

				const phi = Math.acos( 2 * Math.random() - 1 ) - Math.PI / 2; // phi: latitude, range -π/2 to π/2
				const theta = 2 * Math.PI * Math.random(); // theta: longitude, range 0 to 2π

				return new THREE.Vector3(
					radius * Math.cos( phi ) * Math.cos( theta ), // x
					radius * Math.sin( phi ), // y
					radius * Math.cos( phi ) * Math.sin( theta ) // z
				);

			} );

			init();
			initGUI();

			function initGUI() {

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( params, 'samples', 0, 4, 1 );
				gui.add( params, 'animated' );

			}

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
				camera.position.z = 3;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x111111 );

				// textured mesh

				const geometryBox = new THREE.BoxGeometry( 7, 7, 7, 12, 12, 12 );
				const materialBox = new THREE.MeshBasicNodeMaterial();
				const materialBoxInner = new THREE.MeshBasicNodeMaterial( { color: 0xff0000 } );

				materialBox.wireframe = true;

				//

				box = new THREE.InstancedMesh( geometryBox, materialBox, count );
				box2 = new THREE.InstancedMesh( geometryBox, materialBoxInner, count );

				for ( let i = 0; i < count; i ++ ) {

					box.setMatrixAt( i, mat4.identity().setPosition( positions[ i ] ) );
					box2.setMatrixAt( i, mat4.multiplyScalar( 0.996 ).setPosition( positions[ i ] ) );

				}

				scene.add( box, box2 );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.inspector = new Inspector();
				renderer.setPixelRatio( dpr );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				renderTarget = new THREE.RenderTarget( window.innerWidth * dpr, window.innerHeight * dpr, {
					samples: params.samples,
					depthBuffer: true,
				} );

				window.addEventListener( 'mousemove', onWindowMouseMove );
				window.addEventListener( 'resize', onWindowResize );

				// FX

				// modulate the final color based on the mouse position

				const materialFX = new THREE.MeshBasicNodeMaterial();
				materialFX.colorNode = texture( renderTarget.texture ).rgb;

				quadMesh = new THREE.QuadMesh( materialFX );

			}

			function onWindowMouseMove( e ) {

				mouse.x = e.offsetX / window.innerWidth;
				mouse.y = e.offsetY / window.innerHeight;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				renderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );

			}

			function animate() {

				if ( params.animated ) {

					box.rotation.x += 0.001;
					box.rotation.y += 0.002;
					box2.rotation.x += 0.001;
					box2.rotation.y += 0.002;

				}

				renderTarget.samples = params.samples;

				renderer.setRenderTarget( renderTarget );
				renderer.render( scene, camera );

				renderer.setRenderTarget( null );
				quadMesh.render( renderer );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_occlusion.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - occlusion</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Occlusion</span>
			</div>

			<small>
				The plane is green when the sphere is completely occluded.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { nodeObject, uniform } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, controls;

			class OcclusionNode extends THREE.Node {

				constructor( testObject, normalColor, occludedColor ) {

					super( 'vec3' );

					this.updateType = THREE.NodeUpdateType.OBJECT;

					this.uniformNode = uniform( new THREE.Color() );

					this.testObject = testObject;
					this.normalColor = normalColor;
					this.occludedColor = occludedColor;

				}

				async update( frame ) {

					const isOccluded = frame.renderer.isOccluded( this.testObject );

					this.uniformNode.value.copy( isOccluded ? this.occludedColor : this.normalColor );

				}

				setup( /* builder */ ) {

					return this.uniformNode;

				}

			}

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.z = 7;

				scene = new THREE.Scene();

				// lights

				const ambientLight = new THREE.AmbientLight( 0xb0b0b0 );

				const light = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
				light.position.set( 0.32, 0.39, 0.7 );

				scene.add( ambientLight );
				scene.add( light );

				// models

				const planeGeometry = new THREE.PlaneGeometry( 2, 2 );
				const sphereGeometry = new THREE.SphereGeometry( 0.5 );

				const plane = new THREE.Mesh( planeGeometry, new THREE.MeshPhongNodeMaterial( { color: 0x00ff00, side: THREE.DoubleSide } ) );
				const sphere = new THREE.Mesh( sphereGeometry, new THREE.MeshPhongNodeMaterial( { color: 0xffff00 } ) );

				const instanceUniform = nodeObject( new OcclusionNode( sphere, new THREE.Color( 0x0000ff ), new THREE.Color( 0x00ff00 ) ) );

				plane.material.colorNode = instanceUniform;

				sphere.position.z = - 1;
				sphere.occlusionTest = true;

				scene.add( plane );
				scene.add( sphere );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 3;
				controls.maxDistance = 25;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_ocean.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - ocean</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Occlusion</span>
			</div>

			<small>
				The plane is green when the sphere is completely occluded.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { WaterMesh } from 'three/addons/objects/WaterMesh.js';
			import { SkyMesh } from 'three/addons/objects/SkyMesh.js';

			let container;
			let camera, scene, renderer;
			let controls, water, sun, mesh;

			init();

			function init() {

				container = document.getElementById( 'container' );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 1, 20000 );
				camera.position.set( 30, 30, 100 );

				//

				sun = new THREE.Vector3();

				// Water

				const waterGeometry = new THREE.PlaneGeometry( 10000, 10000 );
				const loader = new THREE.TextureLoader();
				const waterNormals = loader.load( 'textures/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

				water = new WaterMesh(
					waterGeometry,
					{
						waterNormals: waterNormals,
						sunDirection: new THREE.Vector3(),
						sunColor: 0xffffff,
						waterColor: 0x001e0f,
						distortionScale: 3.7
					}
				);

				water.rotation.x = - Math.PI / 2;

				scene.add( water );

				// Skybox

				const sky = new SkyMesh();
				sky.scale.setScalar( 10000 );
				scene.add( sky );

				sky.turbidity.value = 10;
				sky.rayleigh.value = 2;
				sky.mieCoefficient.value = 0.005;
				sky.mieDirectionalG.value = 0.8;

				const parameters = {
					elevation: 2,
					azimuth: 180
				};

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				const sceneEnv = new THREE.Scene();

				let renderTarget;

				function updateSun() {

					const phi = THREE.MathUtils.degToRad( 90 - parameters.elevation );
					const theta = THREE.MathUtils.degToRad( parameters.azimuth );

					sun.setFromSphericalCoords( 1, phi, theta );

					sky.sunPosition.value.copy( sun );
					water.sunDirection.value.copy( sun ).normalize();

					if ( renderTarget !== undefined ) renderTarget.dispose();

					sceneEnv.add( sky );
					renderTarget = pmremGenerator.fromScene( sceneEnv );
					scene.add( sky );

					scene.environment = renderTarget.texture;

				}

				renderer.init().then( updateSun );

				//

				const geometry = new THREE.BoxGeometry( 30, 30, 30 );
				const material = new THREE.MeshStandardMaterial( { roughness: 0 } );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.495;
				controls.target.set( 0, 10, 0 );
				controls.minDistance = 40.0;
				controls.maxDistance = 200.0;
				controls.update();

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );

				const folderSky = gui.addFolder( 'Sky' );
				folderSky.add( parameters, 'elevation', 0, 90, 0.1 ).onChange( updateSun );
				folderSky.add( parameters, 'azimuth', - 180, 180, 0.1 ).onChange( updateSun );


				const folderWater = gui.addFolder( 'Water' );
				folderWater.add( water.distortionScale, 'value', 0, 8, 0.1 ).name( 'distortionScale' );
				folderWater.add( water.size, 'value', 0.1, 10, 0.1 ).name( 'size' );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				const time = performance.now() * 0.001;

				mesh.position.y = Math.sin( time ) * 20 + 5;
				mesh.rotation.x = time * 0.5;
				mesh.rotation.z = time * 0.51;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_parallax_uv.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - parallax uv</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Parallax UV</span>
			</div>

			<small>
				Textures by <a href="https://ambientcg.com/view?id=Ice002" target="_blank" rel="noopener">ambientCG</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, parallaxUV, blendOverlay, uv } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;

			let controls;

			init();

			async function init() {

				// scene

				scene = new THREE.Scene();

				// camera

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .1, 50 );
				camera.position.set( 10, 14, 10 );

				// environment

				const environmentTexture = await new THREE.CubeTextureLoader()
					.setPath( './textures/cube/Park2/' )
					.loadAsync( [ 'posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg' ] );


				scene.environment = environmentTexture;
				scene.background = environmentTexture;

				// textures

				const loader = new THREE.TextureLoader();

				const topTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_Color.jpg' );
				topTexture.colorSpace = THREE.SRGBColorSpace;

				const roughnessTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_Roughness.jpg' );
				roughnessTexture.colorSpace = THREE.NoColorSpace;

				const normalTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_NormalGL.jpg' );
				normalTexture.colorSpace = THREE.NoColorSpace;

				const displaceTexture = await loader.loadAsync( 'textures/ambientcg/Ice002_1K-JPG_Displacement.jpg' );
				displaceTexture.colorSpace = THREE.NoColorSpace;

				//

				const bottomTexture = await loader.loadAsync( 'textures/ambientcg/Ice003_1K-JPG_Color.jpg' );
				bottomTexture.colorSpace = THREE.SRGBColorSpace;
				bottomTexture.wrapS = THREE.RepeatWrapping;
				bottomTexture.wrapT = THREE.RepeatWrapping;

				// parallax effect

				const parallaxScale = .3;
				const offsetUV = texture( displaceTexture ).mul( parallaxScale );

				const parallaxUVOffset = parallaxUV( uv(), offsetUV );
				const parallaxResult = texture( bottomTexture, parallaxUVOffset );

				const iceNode = blendOverlay( texture( topTexture ), parallaxResult );

				// material

				const material = new THREE.MeshStandardNodeMaterial();
				material.colorNode = iceNode.mul( 5 ); // increase the color intensity to 5 ( contrast )
				material.roughnessNode = texture( roughnessTexture );
				material.normalMap = normalTexture;
				material.metalness = 0;

				const geometry = new THREE.BoxGeometry( 10, 10, 10 );

				const ground = new THREE.Mesh( geometry, material );
				ground.rotateX( - Math.PI / 2 );
				scene.add( ground );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 6;
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, 0 );
				controls.maxDistance = 40;
				controls.minDistance = 10;
				controls.autoRotate = true;
				controls.autoRotateSpeed = - 1;
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_particles.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Particles</span>
			</div>

			<small>Fire and smoke particles.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { range, texture, mix, uv, color, rotateUV, positionLocal, time, uniform } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let camera, scene, renderer;
			let controls;

			init();

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				const { innerWidth, innerHeight } = window;

				camera = new THREE.PerspectiveCamera( 60, innerWidth / innerHeight, 1, 5000 );
				camera.position.set( 1300, 500, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x333333 );

				// textures

				const textureLoader = new THREE.TextureLoader();
				const map = textureLoader.load( 'textures/opengameart/smoke1.png' );

				// create nodes

				const lifeRange = range( .1, 1 );
				const offsetRange = range( new THREE.Vector3( - 2, 3, - 2 ), new THREE.Vector3( 2, 5, 2 ) );

				const speed = uniform( .2 );
				const scaledTime = time.add( 5 ).mul( speed );

				const lifeTime = scaledTime.mul( lifeRange ).mod( 1 );
				const scaleRange = range( .3, 2 );
				const rotateRange = range( .1, 4 );

				const life = lifeTime.div( lifeRange );

				const fakeLightEffect = positionLocal.y.oneMinus().max( 0.2 );

				const textureNode = texture( map, rotateUV( uv(), scaledTime.mul( rotateRange ) ) );

				const opacityNode = textureNode.a.mul( life.oneMinus() );

				const smokeColor = mix( color( 0x2c1501 ), color( 0x222222 ), positionLocal.y.mul( 3 ).clamp() );

				// create particles

				const smokeNodeMaterial = new THREE.SpriteNodeMaterial();
				smokeNodeMaterial.colorNode = mix( color( 0xf27d0c ), smokeColor, life.mul( 2.5 ).min( 1 ) ).mul( fakeLightEffect );
				smokeNodeMaterial.opacityNode = opacityNode;
				smokeNodeMaterial.positionNode = offsetRange.mul( lifeTime );
				smokeNodeMaterial.scaleNode = scaleRange.mul( lifeTime.max( 0.3 ) );
				smokeNodeMaterial.depthWrite = false;

				const smokeInstancedSprite = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), smokeNodeMaterial );
				smokeInstancedSprite.scale.setScalar( 400 );
				smokeInstancedSprite.count = 2000;
				scene.add( smokeInstancedSprite );

				//

				const fireGeometry = new THREE.PlaneGeometry( 1, 1 );
				const fireCount = 1000;

				const fireNodeMaterial = new THREE.SpriteNodeMaterial();
				fireNodeMaterial.colorNode = mix( color( 0xb72f17 ), color( 0xb72f17 ), life );
				fireNodeMaterial.positionNode = range( new THREE.Vector3( - 1, 1, - 1 ), new THREE.Vector3( 1, 2, 1 ) ).mul( lifeTime );
				fireNodeMaterial.scaleNode = smokeNodeMaterial.scaleNode;
				fireNodeMaterial.opacityNode = opacityNode.mul( .5 );
				fireNodeMaterial.blending = THREE.AdditiveBlending;
				fireNodeMaterial.transparent = true;
				fireNodeMaterial.depthWrite = false;

				const fireInstancedSprite = new THREE.Mesh( fireGeometry, fireNodeMaterial );
				fireInstancedSprite.scale.setScalar( 400 );
				fireInstancedSprite.count = fireCount;
				fireInstancedSprite.position.y = - 100;
				fireInstancedSprite.renderOrder = 1;
				scene.add( fireInstancedSprite );

				// indirect draw ( optional )
				// each indirect draw call is 5 uint32 values for indexes ( different structure for non-indexed draw calls using 4 uint32 values )

				const indexCount = fireGeometry.index.array.length;

				const uint32 = new Uint32Array( 5 );
				uint32[ 0 ] = indexCount;	// indexCount
				uint32[ 1 ] = fireCount; 	// instanceCount
				uint32[ 2 ] = 0;			// firstIndex
				uint32[ 3 ] = 0;			// baseVertex
				uint32[ 4 ] = 0;			// firstInstance

				const indirectAttribute = new THREE.IndirectStorageBufferAttribute( uint32, 5 );
				fireGeometry.setIndirect( indirectAttribute );

				//

				const helper = new THREE.GridHelper( 3000, 40, 0x444444, 0x444444 );
				helper.position.y = - 75;
				scene.add( helper );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxDistance = 2700;
				controls.target.set( 0, 500, 0 );
				controls.update();

				//

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( speed, 'value', 0, 1, 0.01 ).name( 'speed' );

			}

			function onWindowResize() {

				const { innerWidth, innerHeight } = window;

				camera.aspect = innerWidth / innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( innerWidth, innerHeight );

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_performance.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - performance</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Performance</span>
			</div>

			<small>
				Dungeon - Low Poly Game Level Challenge by
				<a href="https://sketchfab.com/warkarma" target="_blank" rel="noopener">Warkarma</a><br />
				<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> from <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"

				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			let camera, scene, renderer;
			let model;

			const options = { static: true };

			init();

			function setStatic( object, value ) {

				object.traverse( child => {

					if ( child.isMesh ) {

						child.static = value;

					}

				} );

			}

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 60, 60, 60 );

				scene = new THREE.Scene();


				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.inspector = new Inspector();
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				//

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.environment = texture;

						// model

						const dracoLoader = new DRACOLoader();
						dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

						const loader = new GLTFLoader().setPath( 'models/gltf/' );
						loader.setDRACOLoader( dracoLoader );

						loader.load( 'dungeon_warkarma.glb', async function ( gltf ) {

							model = gltf.scene;

							// wait until the model can be added to the scene without blocking due to shader compilation

							await renderer.compileAsync( model, camera, scene );

							scene.add( model );

							//

							setStatic( model, options.static );
			
						} );

					} );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 60;
				controls.target.set( 0, 0, - 0.2 );
				controls.update();

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( options, 'static' ).onChange( () => {

					setStatic( model, options.static );

				} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_performance_renderbundle.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgpu - renderbundle</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="example.css">
</head>

<body>

	<style>

		#backend {
			position: absolute;
			top: 70px;
			left: 0;
			color: #fff;
			background-color: rgba( 0, 0, 0, 0.75 );
			padding: 5px;
			width: 100%;
			font-size: 13px;
			text-align: center;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			z-index: 1;
		}

	</style>

	<div id="info" class="invert">
		<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

		<div class="title-wrapper">
			<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
			<span>Render Bundle</span>
		</div>

		<small>
			(WebGL uses 10 times fewer meshes to prevent performance issues.)
		</small>
	</div>

	<div id="backend">
		Draw Calls: 0
	</div>

	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.webgpu.js",
				"three/webgpu": "../build/three.webgpu.js",
				"three/tsl": "../build/three.tsl.js",
				"three/addons/": "./jsm/",
				"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@3.6.0/dist/main.js"
			}
		}
	</script>

	<script type="module">

		import * as THREE from 'three/webgpu';

		import { Inspector } from 'three/addons/inspector/Inspector.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		let camera, scene, renderer;
		let controls;
		let gui;
		let geometries, group;

		let renderTimeAverages = [];
		//

		const position = new THREE.Vector3();
		const rotation = new THREE.Euler();
		const quaternion = new THREE.Quaternion();
		const scale = new THREE.Vector3();

		//

		const MAX_GEOMETRY_COUNT = 4000;

		const api = {
			webgpu: true,
			renderBundle: true,
			count: MAX_GEOMETRY_COUNT,
			opacity: 1,
			dynamic: false
		};


		init( ! api.webgpu );

		//

		function randomizeMatrix( matrix ) {

			position.x = Math.random() * 80 - 40;
			position.y = Math.random() * 80 - 40;
			position.z = Math.random() * 80 - 40;

			rotation.x = Math.random() * 2 * Math.PI;
			rotation.y = Math.random() * 2 * Math.PI;
			rotation.z = Math.random() * 2 * Math.PI;

			quaternion.setFromEuler( rotation );

			const factorScale = api.webgpu ? 1 : 2.0;
			scale.x = scale.y = scale.z = 0.35 * factorScale + ( Math.random() * 0.5 * factorScale );

			return matrix.compose( position, quaternion, scale );

		}

		function randomizeRotationSpeed( rotation ) {

			rotation.x = Math.random() * .05;
			rotation.y = Math.random() * .05;
			rotation.z = Math.random() * .05;
			return rotation;

		}

		function initGeometries() {

			geometries = [
				new THREE.ConeGeometry( 1.0, 2.0, 3, 1 ),
				new THREE.BoxGeometry( 2.0, 2.0, 2.0 ),
				new THREE.PlaneGeometry( 2.0, 2, 1, 1 ),
				new THREE.CapsuleGeometry( ),
				new THREE.CircleGeometry( 1.0, 3 ),
				new THREE.CylinderGeometry( 1.0, 1.0, 2.0, 3, 1 ),
				new THREE.DodecahedronGeometry( 1.0, 0 ),
				new THREE.IcosahedronGeometry( 1.0, 0 ),
				new THREE.OctahedronGeometry( 1.0, 0 ),
				new THREE.PolyhedronGeometry( [ 0, 0, 0 ], [ 0, 0, 0 ], 1, 0 ),
				new THREE.RingGeometry( 1.0, 1.5, 3 ),
				new THREE.SphereGeometry( 1.0, 3, 2 ),
				new THREE.TetrahedronGeometry( 1.0, 0 ),
				new THREE.TorusGeometry( 1.0, 0.5, 3, 3 ),
				new THREE.TorusKnotGeometry( 1.0, 0.5, 20, 3, 1, 1 ),
			];

		}

		function cleanup() {

			if ( group ) {

				group.parent.remove( group );

				if ( group.dispose ) {

					group.dispose();

				}

			}

		}

		function initMesh( count ) {

			cleanup();
			initRegularMesh( count );

		}


		function initRegularMesh( count ) {

			group = api.renderBundle ? new THREE.BundleGroup() : new THREE.Group();

			for ( let i = 0; i < count; i ++ ) {

				const material = new THREE.MeshToonNodeMaterial( {
					color: new THREE.Color( Math.random() * 0xffffff ),
					side: THREE.DoubleSide,
				} );

				const child = new THREE.Mesh( geometries[ i % geometries.length ], material );
				randomizeMatrix( child.matrix );
				child.matrix.decompose( child.position, child.quaternion, child.scale );
				child.userData.rotationSpeed = randomizeRotationSpeed( new THREE.Euler() );
				child.frustumCulled = false;
				group.add( child );

			}

			scene.add( group );

		}

		async function init( forceWebGL = false ) {

			const count = api.count / ( api.webgpu ? 1 : 10 );

			renderTimeAverages = [];

			if ( renderer ) {

				renderer.dispose();
				controls.dispose();
				document.body.removeChild( renderer.domElement );

			}

			// camera

			const aspect = window.innerWidth / window.innerHeight;

			camera = new THREE.PerspectiveCamera( 70, aspect, 1, 100 );
			camera.position.z = 50;

			// renderer

			renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.inspector = new Inspector();
			renderer.setAnimationLoop( animate );

			// scene

			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xc1c1c1 );

			const light = new THREE.DirectionalLight( 0xffffff, 3.4 );
			scene.add( light );

			document.body.appendChild( renderer.domElement );

			await renderer.init();


			initGeometries();
			initMesh( count );

			controls = new OrbitControls( camera, renderer.domElement );
			controls.autoRotate = true;
			controls.autoRotateSpeed = 1.0;

			// gui

			gui = renderer.inspector.createParameters( 'Settings' );
			gui.add( api, 'renderBundle' ).name( 'render bundle' ).onChange( () => {

				init( ! api.webgpu );

			} );

			gui.add( api, 'webgpu' ).onChange( () => {

				init( ! api.webgpu );

			} );

			gui.add( api, 'dynamic' ).onChange( () => {

				group.static = ! group.static;

			} );


			// listeners

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				group.needsUpdate = true;
		
			}

			async function animate() {

				animateMeshes();

				controls.update();

				const renderTimeAverage = performance.now();
				renderer.render( scene, camera );

				// push only the last 60 render times
				renderTimeAverages.push( performance.now() - renderTimeAverage );
				if ( renderTimeAverages.length > 60 ) renderTimeAverages.shift();
		
				const average = renderTimeAverages.reduce( ( a, b ) => a + b, 0 ) / renderTimeAverages.length;

				document.getElementById( 'backend' ).innerText = `Average Render Time ${api.renderBundle ? '(Bundle)' : ''}: ` + average.toFixed( 2 ) + 'ms';

			}

			function animateMeshes() {

				const count = api.count / ( api.webgpu ? 1 : 10 );
				const loopNum = api.dynamic ? count : 0;

				for ( let i = 0; i < loopNum; i ++ ) {

					const child = group.children[ i ];
					const rotationSpeed = child.userData.rotationSpeed;

					child.rotation.set(
						child.rotation.x + rotationSpeed.x,
						child.rotation.y + rotationSpeed.y,
						child.rotation.z + rotationSpeed.z
					);

				}

			}

		}

	</script>

</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_pmrem_cubemap.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - pmrem cubemap</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { normalWorldGeometry, uniform, pmremTexture } from 'three/tsl';

			import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 0, 0, 8 );

				scene = new THREE.Scene();

				const forceWebGL = false;

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;

				await renderer.init();

				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.update();

				new HDRCubeTextureLoader()
					.setPath( './textures/cube/pisaHDR/' )
					.load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ], function ( map ) {

						scene.backgroundNode = pmremTexture( map, normalWorldGeometry, uniform( 0.5 ) );

						const geometry = new THREE.SphereGeometry( 0.4, 64, 64 );

						for ( let i = 0; i < 6; i ++ ) {

							for ( let j = 0; j < 5; j ++ ) {

								const material = new THREE.MeshPhysicalNodeMaterial( {
									roughness: i / 5,
									metalness: j / 4,
									envMap: map
								} );

								const mesh = new THREE.Mesh( geometry, material );
								mesh.position.x = i - 2.5;
								mesh.position.y = j - 2;
								scene.add( mesh );

							}

						}

					} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_pmrem_equirectangular.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - pmrem equirectangular</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { normalWorldGeometry, uniform, pmremTexture } from 'three/tsl';

			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer;

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 0, 0, 8 );

				scene = new THREE.Scene();

				const forceWebGL = false;

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;

				await renderer.init();

				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.update();

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( map ) {

						map.mapping = THREE.EquirectangularReflectionMapping;

						scene.backgroundNode = pmremTexture( map, normalWorldGeometry, uniform( 0.5 ) );

						const geometry = new THREE.SphereGeometry( 0.4, 64, 64 );

						for ( let i = 0; i < 6; i ++ ) {

							for ( let j = 0; j < 5; j ++ ) {

								const material = new THREE.MeshPhysicalNodeMaterial( {
									roughness: i / 5,
									metalness: j / 4,
									envMap: map
								} );

								const mesh = new THREE.Mesh( geometry, material );
								mesh.position.x = i - 2.5;
								mesh.position.y = j - 2;
								scene.add( mesh );

							}

						}

					} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_pmrem_scene.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - pmrem scene</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>PMREM Scene</span>
			</div>

			<small>
				PMREM generated from Scene.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { normalWorld, uniform, pmremTexture } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, 0.6, 2.7 );

				scene = new THREE.Scene();

				const forceWebGL = false;

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				await renderer.init();

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.update();

				//
				const loader = new THREE.CubeTextureLoader().setPath( './textures/cube/Park3Med/' );

				scene.background = await loader.loadAsync( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );

				let model;

				model = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0x0000ff } ) );
				model.position.z -= 1;
				scene.add( model );

				model = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0xff0000 } ) );
				model.position.z += 1;
				scene.add( model );

				model = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0xff00ff } ) );
				model.position.x += 1;
				scene.add( model );

				model = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0x00ffff } ) );
				model.position.x -= 1;
				scene.add( model );

				model = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0xffff00 } ) );
				model.position.y -= 1;
				scene.add( model );

				model = new THREE.Mesh( new THREE.SphereGeometry( .2, 64, 64 ), new THREE.MeshBasicMaterial( { color: 0x00ff00 } ) );
				model.position.y += 1;
				scene.add( model );

				//while ( scene.children.length > 0 ) scene.remove( scene.children[ 0 ] );

				const sceneRT = new THREE.PMREMGenerator( renderer ).fromScene( scene );


				//

				const pmremRoughness = uniform( .5 );
				const pmremNode = pmremTexture( sceneRT.texture, normalWorld, pmremRoughness );

				scene.add( new THREE.Mesh( new THREE.SphereGeometry( .5, 64, 64 ), new THREE.MeshBasicNodeMaterial( { colorNode: pmremNode } ) ) );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( pmremRoughness, 'value', 0, 1, 0.001 ).name( 'roughness' ).onChange( () => render() );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_pmrem_test.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - PMREM directional light test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>PMREM Directional Light Test</span>
			</div>

			<small>
				1: white metal. 2: white dielectric. 3: black dielectric.
				<br>PMREM on: HDR with a single bright pixel. PMREM off: DirectionalLight.
				<br>The difference between these renders indicates the error in the PMREM approximations.
				<br>PMREM test by <a href="https://github.com/elalish" target="_blank" rel="noopener">Emmett Lalish</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let scene, camera, controls, renderer;

			async function init() {

				const width = window.innerWidth;
				const height = window.innerHeight;
				const aspect = width / height;

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setAnimationLoop( render );
				renderer.inspector = new Inspector();

				// tonemapping
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;

				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

				await renderer.init();

				// scene

				scene = new THREE.Scene();

				// camera

				camera = new THREE.PerspectiveCamera( 40, aspect, 1, 30 );
				updateCamera();
				camera.position.set( 0, 0, 16 );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 4;
				controls.maxDistance = 20;

				// light

				const directionalLight = new THREE.DirectionalLight( 0xffffff, 0 ); // set intensity to 0 to start
				const x = 597;
				const y = 213;
				const theta = ( x + 0.5 ) * Math.PI / 512;
				const phi = ( y + 0.5 ) * Math.PI / 512;

				directionalLight.position.setFromSphericalCoords( 100, - phi, Math.PI / 2 - theta );

				scene.add( directionalLight );
				// scene.add( new THREE.DirectionalLightHelper( directionalLight ) );

				// The spot1Lux HDR environment map is expressed in nits (lux / sr). The directional light has units of lux,
				// so to match a 1 lux light, we set a single pixel with a value equal to 1 divided by the solid
				// angle of the pixel in steradians. This image is 1024 x 512,
				// so the value is 1 / ( sin( phi ) * ( pi / 512 ) ^ 2 ) = 27,490 nits.

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( { enabled: true }, 'enabled' )
					.name( 'PMREM' )
					.onChange( value => {

						directionalLight.intensity = value ? 0 : 1;

						scene.traverse( function ( child ) {

							if ( child.isMesh ) {

								child.material.envMapIntensity = 1 - directionalLight.intensity;

							}

						} );

					} );

			}

			function createObjects() {

				let radianceMap = null;
				new HDRLoader()
					// .setDataType( THREE.FloatType )
					.setPath( 'textures/equirectangular/' )
					.load( 'spot1Lux.hdr', function ( texture ) {

						radianceMap = pmremGenerator.fromEquirectangular( texture ).texture;
						pmremGenerator.dispose();

						scene.background = radianceMap;

						const geometry = new THREE.SphereGeometry( 0.4, 32, 32 );

						for ( let x = 0; x <= 10; x ++ ) {

							for ( let y = 0; y <= 2; y ++ ) {

								const material = new THREE.MeshPhysicalMaterial( {
									roughness: x / 10,
									metalness: y < 1 ? 1 : 0,
									color: y < 2 ? 0xffffff : 0x000000,
									envMap: radianceMap,
									envMapIntensity: 1
								} );

								const mesh = new THREE.Mesh( geometry, material );
								mesh.position.x = x - 5;
								mesh.position.y = 1 - y;
								scene.add( mesh );

							}

						}

					} );

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				updateCamera();

				renderer.setSize( width, height );

			}

			function updateCamera() {

				const horizontalFoV = 40;
				const verticalFoV = 2 * Math.atan( Math.tan( horizontalFoV / 2 * Math.PI / 180 ) / camera.aspect ) * 180 / Math.PI;
				camera.fov = verticalFoV;
				camera.updateProjectionMatrix();

			}

			function render() {

				renderer.render( scene, camera );

			}

			Promise.resolve()
				.then( init )
				.then( createObjects );

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_portal.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - portal</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Portal</span>
			</div>

			<small>
				The portal displays a different scene when viewed through it.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, color, mx_worley_noise_float, time, screenUV, vec2, uv, normalWorld, mx_fractal_noise_vec3 } from 'three/tsl';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, sceneMain, scenePortal, renderer;
			let clock;

			const mixers = [];

			init();

			function init() {

				//

				sceneMain = new THREE.Scene();
				sceneMain.background = new THREE.Color( 0x222222 );
				sceneMain.backgroundNode = normalWorld.y.mix( color( 0x0066ff ), color( 0xff0066 ) );

				scenePortal = new THREE.Scene();
				scenePortal.backgroundNode = mx_worley_noise_float( normalWorld.mul( 20 ).add( vec2( 0, time.oneMinus() ) ) ).mul( color( 0x0066ff ) );
				scenePortal.name = 'Portal Scene';

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 30 );
				camera.position.set( 2.5, 1, 3 );
				camera.position.multiplyScalar( .8 );
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				// lights

				const light = new THREE.PointLight( 0xffffff, 1 );
				light.position.set( 0, 1, 5 );
				light.power = 17000;

				sceneMain.add( new THREE.HemisphereLight( 0xff0066, 0x0066ff, 7 ) );
				sceneMain.add( light );
				scenePortal.add( light.clone() );

				// models

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Xbot.glb', function ( gltf ) {

					const createModel = ( colorNode = null ) => {

						let object;
			
						if ( mixers.length === 0 ) {

							object = gltf.scene;

						} else {

							object = gltf.scene.clone();

							const children = object.children[ 0 ].children;

							const applyFX = ( index ) => {

								children[ index ].material = children[ index ].material.clone();
								children[ index ].material.colorNode = colorNode;
								children[ index ].material.wireframe = true;

							};

							applyFX( 0 );
							applyFX( 1 );

						}

						const mixer = new THREE.AnimationMixer( object );

						const action = mixer.clipAction( gltf.animations[ 6 ] );
						action.play();

						mixers.push( mixer );

						return object;

					};

					const colorNode = mx_fractal_noise_vec3( uv().mul( 20 ).add( time ) );

					const modelMain = createModel();
					const modelPortal = createModel( colorNode );

					// model portal

					sceneMain.add( modelMain );
					scenePortal.add( modelPortal );

				} );

				// portal

				const geometry = new THREE.PlaneGeometry( 1.7, 2 );

				const material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = pass( scenePortal, camera ).context( { getUV: () => screenUV } );
				material.opacityNode = uv().distance( .5 ).remapClamp( .3, .5 ).oneMinus();
				material.side = THREE.DoubleSide;
				material.transparent = true;

				const plane = new THREE.Mesh( geometry, material );
				plane.position.set( 0, 1, .8 );
				sceneMain.add( plane );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.toneMappingExposure = 0.15;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 1, 0 );
				controls.update();


				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				for ( const mixer of mixers ) {

					mixer.update( delta );

				}

				renderer.render( sceneMain, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Post Processing</span>
			</div>

			<small>Mix of simple post processing effects.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass } from 'three/tsl';
			import { dotScreen } from 'three/addons/tsl/display/DotScreenNode.js';
			import { rgbShift } from 'three/addons/tsl/display/RGBShiftNode.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, renderer, postProcessing;
			let object;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;

				const scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 1, 1000 );

				object = new THREE.Object3D();
				scene.add( object );

				const geometry = new THREE.SphereGeometry( 1, 4, 4 );
				const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );

				for ( let i = 0; i < 100; i ++ ) {

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 ).normalize();
					mesh.position.multiplyScalar( Math.random() * 400 );
					mesh.rotation.set( Math.random() * 2, Math.random() * 2, Math.random() * 2 );
					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 50;
					object.add( mesh );

				}

				scene.add( new THREE.AmbientLight( 0xcccccc ) );

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 1, 1, 1 );
				scene.add( light );

				// postprocessing

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode().toInspector( 'Scene Color' );

				const dotScreenPass = dotScreen( scenePassColor );
				dotScreenPass.scale.value = 0.3;

				const rgbShiftPass = rgbShift( dotScreenPass );
				rgbShiftPass.amount.value = 0.001;

				postProcessing.outputNode = rgbShiftPass;

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				object.rotation.x += 0.005;
				object.rotation.y += 0.01;

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_3dlut.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - 3d luts</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>3D LUTs</span>
			</div>

			<small>
				3D Lookup-Tables for color grading, based on <a href="https://threejs-journey.com/lessons/coffee-smoke-shader" target="_blank" rel="noopener">Three.js Journey</a> lesson.<br />
				Perlin noise texture from <a href="http://kitfox.com/projects/perlinNoiseMaker/" target="_blank" rel="noopener">Perlin Noise Maker</a>, 
				LUTs from <a href="https://www.rocketstock.com/free-after-effects-templates/35-free-luts-for-color-grading-videos/">RocketStock</a>, <a href="https://www.freepresets.com/product/free-luts-cinematic/">FreePresets.com</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mix, mul, oneMinus, positionLocal, smoothstep, texture, time, rotateUV, Fn, uv, vec2, vec3, vec4, pass, texture3D, uniform, renderOutput } from 'three/tsl';
			import { lut3D } from 'three/addons/tsl/display/Lut3DNode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { LUTCubeLoader } from 'three/addons/loaders/LUTCubeLoader.js';
			import { LUT3dlLoader } from 'three/addons/loaders/LUT3dlLoader.js';
			import { LUTImageLoader } from 'three/addons/loaders/LUTImageLoader.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			const params = {
				lut: 'Bourbon 64.CUBE',
				intensity: 1
			};

			const lutMap = {
				'Bourbon 64.CUBE': null,
				'Chemical 168.CUBE': null,
				'Clayton 33.CUBE': null,
				'Cubicle 99.CUBE': null,
				'Remy 24.CUBE': null,
				'Presetpro-Cinematic.3dl': null,
				'NeutralLUT': null,
				'B&WLUT': null,
				'NightLUT': null
			};

			let camera, scene, renderer, postProcessing, controls, lutPass;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 8, 10, 12 );

				scene = new THREE.Scene();

				// Loaders

				const gltfLoader = new GLTFLoader();
				const textureLoader = new THREE.TextureLoader();

				// LUTs

				const lutCubeLoader = new LUTCubeLoader();
				const lutImageLoader = new LUTImageLoader();
				const lut3dlLoader = new LUT3dlLoader();

				for ( const name in lutMap ) {

					if ( /\.CUBE$/i.test( name ) ) {

						lutMap[ name ] = lutCubeLoader.loadAsync( 'luts/' + name );

					} else if ( /\LUT$/i.test( name ) ) {

						lutMap[ name ] = lutImageLoader.loadAsync( `luts/${name}.png` );

					} else {

						lutMap[ name ] = lut3dlLoader.loadAsync( 'luts/' + name );

					}

				}

				const pendings = Object.values( lutMap );
				await Promise.all( pendings );

				for ( const name in lutMap ) {

					lutMap[ name ] = await lutMap[ name ];

				}

				// baked model

				gltfLoader.load(
					'./models/gltf/coffeeMug.glb',
					( gltf ) => {

        				gltf.scene.getObjectByName( 'baked' ).material.map.anisotropy = 8;
						scene.add( gltf.scene );

					}
				);

				// geometry

				const smokeGeometry = new THREE.PlaneGeometry( 1, 1, 16, 64 );
				smokeGeometry.translate( 0, 0.5, 0 );
				smokeGeometry.scale( 1.5, 6, 1.5 );

				// texture

				const noiseTexture = textureLoader.load( './textures/noises/perlin/128x128.png' );
				noiseTexture.wrapS = THREE.RepeatWrapping;
				noiseTexture.wrapT = THREE.RepeatWrapping;

				// material

				const smokeMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, side: THREE.DoubleSide, depthWrite: false } );

				// position

				smokeMaterial.positionNode = Fn( () => {

					// twist

					const twistNoiseUv = vec2( 0.5, uv().y.mul( 0.2 ).sub( time.mul( 0.005 ) ).mod( 1 ) );
					const twist = texture( noiseTexture, twistNoiseUv ).r.mul( 10 );
					positionLocal.xz.assign( rotateUV( positionLocal.xz, twist, vec2( 0 ) ) );

					// wind

					const windOffset = vec2(
						texture( noiseTexture, vec2( 0.25, time.mul( 0.01 ) ).mod( 1 ) ).r.sub( 0.5 ),
						texture( noiseTexture, vec2( 0.75, time.mul( 0.01 ) ).mod( 1 ) ).r.sub( 0.5 ),
					).mul( uv().y.pow( 2 ).mul( 10 ) );
					positionLocal.addAssign( windOffset );

					return positionLocal;

				} )();

				// color

				smokeMaterial.colorNode = Fn( () => {

					// alpha

					const alphaNoiseUv = uv().mul( vec2( 0.5, 0.3 ) ).add( vec2( 0, time.mul( 0.03 ).negate() ) );
					const alpha = mul(

						// pattern
						texture( noiseTexture, alphaNoiseUv ).r.smoothstep( 0.4, 1 ),

						// edges fade
						smoothstep( 0, 0.1, uv().x ),
						smoothstep( 0, 0.1, oneMinus( uv().x ) ),
						smoothstep( 0, 0.1, uv().y ),
						smoothstep( 0, 0.1, oneMinus( uv().y ) )

					);

					// color

					const finalColor = mix( vec3( 0.6, 0.3, 0.2 ), vec3( 1, 1, 1 ), alpha.pow( 3 ) );

					return vec4( finalColor, alpha );

				} )();

				// mesh

				const smoke = new THREE.Mesh( smokeGeometry, smokeMaterial );
				smoke.position.y = 1.83;
				scene.add( smoke );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				// ignore default output color transform ( toneMapping and outputColorSpace )
				// use renderOutput() for control the sequence

				postProcessing.outputColorTransform = false;

				// scene pass

				const scenePass = pass( scene, camera );
				const outputPass = renderOutput( scenePass );

				const lut = lutMap[ params.lut ];
				lutPass = lut3D( outputPass, texture3D( lut.texture3D ), lut.texture3D.image.width, uniform( 1 ) );

				postProcessing.outputNode = lutPass;

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;
				controls.target.y = 3;

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( params, 'lut', Object.keys( lutMap ) );
				gui.add( params, 'intensity', 0, 1 );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				controls.update();

				lutPass.intensityNode.value = params.intensity;

				if ( lutMap[ params.lut ] ) {

					const lut = lutMap[ params.lut ];
					lutPass.lutNode.value = lut.texture3D;
					lutPass.size.value = lut.texture3D.image.width;

				}

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_afterimage.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing afterimage</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>After Image</span>
			</div>

			<small>
				Based on <a href="https://oosmoxiecode.com/archive/js_webgl/spiral/" target="_blank" rel="noopener">Particle Spiral</a>
				by <a href="https://github.com/oosmoxiecode" target="_blank" rel="noopener">oosmoxiecode</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { instancedBufferAttribute, uniform, mod, pass, texture, float, time, vec2, vec3, vec4, sin, cos } from 'three/tsl';
			import { afterImage } from 'three/addons/tsl/display/AfterImageNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, particles;
			let postProcessing, afterImagePass, scenePass;

			const params = {

				damp: uniform( 0.8, 'float' ).setName( 'damp' ),
				enabled: true

			};

			init();

			function init() {

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				scene = new THREE.Scene();

				const sprite = new THREE.TextureLoader().load( 'textures/sprites/circle.png' );

				// geometry

				const radius = 600;
				const count = 50000;

				const vertex = new THREE.Vector3();
				const color = new THREE.Color();

				const colors = [];
				const vertices = [];
				const timeOffsets = [];

				for ( var i = 0; i < count; i ++ ) {

					getRandomPointOnSphere( radius, vertex );
					vertices.push( vertex.x, vertex.y, vertex.z );

					color.setHSL( i / count, 0.7, 0.7, THREE.SRGBColorSpace );
					colors.push( color.r, color.g, color.b );

					timeOffsets.push( i / count );

				}

				const positionAttribute = new THREE.InstancedBufferAttribute( new Float32Array( vertices ), 3 );
				const colorAttribute = new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 );
				const timeAttribute = new THREE.InstancedBufferAttribute( new Float32Array( timeOffsets ), 1 );

				// material and TSL

				const material = new THREE.SpriteNodeMaterial( { blending: THREE.AdditiveBlending, depthWrite: false } );

				const localTime = instancedBufferAttribute( timeAttribute ).add( time.mul( 0.1 ) );
				const modTime = mod( localTime, 1.0 );
				const accTime = modTime.mul( modTime );

				const angle = accTime.mul( 40.0 );
				const pulse = vec2( sin( angle ).mul( 20.0 ), cos( angle ).mul( 20.0 ) );
				const pos = instancedBufferAttribute( positionAttribute );

				const animated = vec3( pos.x.mul( accTime ).add( pulse.x ), pos.y.mul( accTime ).add( pulse.y ), pos.z.mul( accTime ).mul( 1.75 ) );
				const fAlpha = modTime.oneMinus().mul( 2.0 );

				material.colorNode = texture( sprite ).mul( vec4( instancedBufferAttribute( colorAttribute ), fAlpha ) );
				material.positionNode = animated;
				material.scaleNode = float( 2 );

				particles = new THREE.Sprite( material );
				particles.count = count;
				scene.add( particles );

				// postprocessing

				postProcessing = new THREE.PostProcessing( renderer );

				scenePass = pass( scene, camera );

				afterImagePass = afterImage( scenePass, params.damp );

				postProcessing.outputNode = afterImagePass;

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( afterImagePass.damp, 'value', 0.25, 1 );
				gui.add( params, 'enabled' ).onChange( updatePassChain );

				window.addEventListener( 'resize', onWindowResize );

			}

			function updatePassChain() {

				if ( params.enabled === true ) {

					postProcessing.outputNode = afterImagePass;

				} else {

					postProcessing.outputNode = scenePass;

				}

				postProcessing.needsUpdate = true;


			}


			function getRandomPointOnSphere( r, v ) {

				const angle = Math.random() * Math.PI * 2;
				const u = Math.random() * 2 - 1;

				v.set(
					Math.cos( angle ) * Math.sqrt( 1 - Math.pow( u, 2 ) ) * r,
					Math.sin( angle ) * Math.sqrt( 1 - Math.pow( u, 2 ) ) * r,
					u * r
				);

				return v;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate( time ) {

				particles.rotation.z = time * 0.001;

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_anamorphic.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing anamorphic</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Anamorphic Lensflares</span>
			</div>

			<small>
				Battle Damaged Sci-fi Helmet by <a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, cubeTexture, screenUV, grayscale, uniform } from 'three/tsl';
			import { anamorphic } from 'three/addons/tsl/display/AnamorphicNode.js';

			import { HDRCubeTextureLoader } from 'three/addons/loaders/HDRCubeTextureLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let postProcessing;

			const params = {
				resolutionScale: 0.2
			};

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, - 0.6, 2.7 );

				scene = new THREE.Scene();

				const hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];
				const cube1Texture = await new HDRCubeTextureLoader()
					.setPath( './textures/cube/pisaHDR/' )
					.loadAsync( hdrUrls );

				scene.environment = cube1Texture;
				scene.backgroundNode = grayscale( cubeTexture( cube1Texture ).mul( screenUV.distance( .5 ).oneMinus().remapClamp( .1, 4 ) ) );

				const loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
				loader.load( 'DamagedHelmet.gltf', function ( gltf ) {

					scene.add( gltf.scene );

				} );

				renderer = new THREE.WebGPURenderer( { antialias: true } );

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.inspector = new Inspector();
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;

				// post-processing

				const scenePass = pass( scene, camera );

				const threshold = uniform( 1.4 );
				const scaleNode = uniform( 5 );
				const intensity = uniform( 1 );
				const samples = 64;

				const anamorphicPass = anamorphic( scenePass.getTextureNode().toInspector( 'Color' ), threshold, scaleNode, samples ).toInspector( 'Anamorphic' );
				anamorphicPass.resolutionScale = params.resolutionScale; // 1 = full resolution

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = scenePass.add( anamorphicPass.mul( intensity ) );
				//postProcessing.outputNode = scenePass.add( anamorphicPass.getTextureNode().gaussianBlur() );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( intensity, 'value', 0, 4, 0.1 ).name( 'intensity' );
				gui.add( threshold, 'value', .8, 3, .001 ).name( 'threshold' );
				gui.add( scaleNode, 'value', 1, 10, 0.1 ).name( 'scale' );
				gui.add( params, 'resolutionScale', .1, 1, 0.1 ).name( 'resolution scale' ).onChange( value => anamorphicPass.resolutionScale = value );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_ao.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - ambient occlusion</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>AO</span>
			</div>

			<small>
				Ambient Occlusion based on GTAO.<br />
				<a href="https://skfb.ly/oCnNx" target="_blank" rel="noopener">Minimalistic Modern Bedroom</a> by 
				<a href="https://sketchfab.com/dylanheyes" target="_blank" rel="noopener">dylanheyes</a> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">Creative Commons Attribution</a>.	
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, mrt, output, normalView, velocity, vec3, vec4, directionToColor, colorSpaceToWorking } from 'three/tsl';
			import { ao } from 'three/addons/tsl/display/GTAONode.js';
			import { traa } from 'three/addons/tsl/display/TRAANode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, postProcessing, controls;

			let aoPass, traaPass, blendPassAO, scenePassColor;

			const params = {
				samples: 16,
				distanceExponent: 1,
				distanceFallOff: 1,
				radius: 0.25,
				scale: 1,
				thickness: 1,
				aoOnly: false
			};

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 50 );
				camera.position.set( 1, 1.3, 5 );

				scene = new THREE.Scene();

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene.background = new THREE.Color( 0x666666 );
				scene.environment = pmremGenerator.fromScene( environment ).texture;
				environment.dispose();
				pmremGenerator.dispose();

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0.5, - 1 );
				controls.update();
				controls.enablePan = false;
				controls.enableDamping = true;
				controls.minDistance = 2;
				controls.maxDistance = 8;

				//

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output: output,
					normal: normalView,
					velocity: velocity
				} ) );

				scenePassColor = scenePass.getTextureNode( 'output' ).toInspector( 'Color' );
				const scenePassDepth = scenePass.getTextureNode( 'depth' ).toInspector( 'Depth', () => {

					return scenePass.getLinearDepthNode();

				} );
				const scenePassNormal = scenePass.getTextureNode( 'normal' ).toInspector( 'Normal', () => {

					return colorSpaceToWorking( directionToColor( scenePassNormal ), THREE.SRGBColorSpace );

				} );
				const scenePassVelocity = scenePass.getTextureNode( 'velocity' ).toInspector( 'Velocity' );

				// ao

				aoPass = ao( scenePassDepth, scenePassNormal, camera );
				aoPass.resolutionScale = 0.5; // running AO in half resolution is often sufficient
				aoPass.useTemporalFiltering = true;
				blendPassAO = vec4( scenePassColor.rgb.mul( aoPass.r.toInspector( 'AO' ) ), scenePassColor.a ); // the AO is stored only in the red channel

				// traa

				traaPass = traa( blendPassAO, scenePassDepth, scenePassVelocity, camera );
				postProcessing.outputNode = traaPass;

				//

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/' );
				dracoLoader.setDecoderConfig( { type: 'js' } );
				const loader = new GLTFLoader();
				loader.setDRACOLoader( dracoLoader );
				loader.setPath( 'models/gltf/' );

				const gltf = await loader.loadAsync( 'minimalistic_modern_bedroom.glb' );

				const model = gltf.scene;
				model.position.set( 0, 1, 0 );
				scene.add( model );

				model.traverse( ( o ) => {

					// Transparent objects (e.g. loaded via GLTFLoader) might have "depthWrite" set to "false".
					// This is wanted when rendering the beauty pass however it produces wrong results when computing
					// AO since depth and normal data are out of sync. Computing normals from depth by not using MRT
					// can mitigate the issue although the depth information (and thus the normals) are not correct in
					// first place. Besides, normal estimation is computationally more expensive than just sampling a
					// normal texture. So depending on your scene, consider to enable "depthWrite" for all transparent objects.

					if ( o.material ) o.material.depthWrite = true;

				} );

				window.addEventListener( 'resize', onWindowResize );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( params, 'samples', 4, 32, 1 ).onChange( updateParameters );
				gui.add( params, 'distanceExponent', 1, 2 ).onChange( updateParameters );
				gui.add( params, 'distanceFallOff', 0.01, 1 ).onChange( updateParameters );
				gui.add( params, 'radius', 0.1, 1 ).onChange( updateParameters );
				gui.add( params, 'scale', 0.01, 2 ).onChange( updateParameters );
				gui.add( params, 'thickness', 0.01, 2 ).onChange( updateParameters );
				gui.add( aoPass, 'useTemporalFiltering' ).name( 'temporal filtering' );
				gui.add( params, 'aoOnly' ).onChange( ( value ) => {

					if ( value === true ) {

						postProcessing.outputNode = vec4( vec3( aoPass.r ), 1 );

					} else {


						postProcessing.outputNode = traaPass;

					}

					postProcessing.needsUpdate = true;

				} );

			}

			function updateParameters() {

				aoPass.samples.value = params.samples;
				aoPass.distanceExponent.value = params.distanceExponent;
				aoPass.distanceFallOff.value = params.distanceFallOff;
				aoPass.radius.value = params.radius;
				aoPass.scale.value = params.scale;
				aoPass.thickness.value = params.thickness;

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_bloom.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing - bloom</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Bloom</span>
			</div>

			<small>
				Bloom pass by <a href="http://eduperiment.com" target="_blank" rel="noopener">Prashant Sharma</a> and <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a>.<br/>
				<a href="https://blog.sketchfab.com/art-spotlight-primary-ion-drive/" target="_blank" rel="noopener">Primary Ion Drive</a>
				by <a href="http://mjmurdock.com/" target="_blank" rel="noopener">Mike Murdock</a> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">Creative Commons Attribution</a>.<br />
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';


			let camera;
			let postProcessing, renderer, mixer, clock;

			const params = {
				threshold: 0,
				strength: 1,
				radius: 0,
				exposure: 1
			};

			init();

			async function init() {

				clock = new THREE.Clock();

				const scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
				camera.position.set( - 5, 2.5, - 3.5 );
				scene.add( camera );

				scene.add( new THREE.AmbientLight( 0xcccccc ) );

				const pointLight = new THREE.PointLight( 0xffffff, 100 );
				camera.add( pointLight );

				const loader = new GLTFLoader();
				const gltf = await loader.loadAsync( 'models/gltf/PrimaryIonDrive.glb' );

				const model = gltf.scene;
				scene.add( model );

				mixer = new THREE.AnimationMixer( model );
				const clip = gltf.animations[ 0 ];
				mixer.clipAction( clip.optimize() ).play();

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode( 'output' ).toInspector( 'Color' );

				const bloomPass = bloom( scenePassColor ).toInspector( 'Bloom' );

				postProcessing.outputNode = scenePassColor.add( bloomPass );

				//

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.5;
				controls.minDistance = 3;
				controls.maxDistance = 8;

				//

				const gui = renderer.inspector.createParameters( 'Settings' );

				const bloomFolder = gui.addFolder( 'bloom' );

				bloomFolder.add( params, 'threshold', 0.0, 1.0 ).onChange( function ( value ) {

					bloomPass.threshold.value = value;

				} );

				bloomFolder.add( params, 'strength', 0.0, 3.0 ).onChange( function ( value ) {

					bloomPass.strength.value = value;

				} );

				gui.add( params, 'radius', 0.0, 1.0, 0.01 ).onChange( function ( value ) {

					bloomPass.radius.value = value;

				} );

				const toneMappingFolder = gui.addFolder( 'tone mapping' );

				toneMappingFolder.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

					renderer.toneMappingExposure = Math.pow( value, 4.0 );

				} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				const delta = clock.getDelta();

				mixer.update( delta );

				postProcessing.render();

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_bloom_emissive.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - bloom emissive</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Emissive Bloom</span>
			</div>

			<small>Selective Bloom based on the "emissive" material property.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, mrt, output, emissive } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let postProcessing;

			init();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				//

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, 0.6, 2.7 );

				scene = new THREE.Scene();

				new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.load( 'moonless_golf_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.background = texture;
						scene.environment = texture;

						// model

						const loader = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
						loader.load( 'DamagedHelmet.gltf', function ( gltf ) {

							scene.add( gltf.scene );

						} );

					} );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				//

				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output,
					emissive
				} ) );

				const outputPass = scenePass.getTextureNode().toInspector( 'Color' );
				const emissivePass = scenePass.getTextureNode( 'emissive' ).toInspector( 'Emissive' );

				const bloomPass = bloom( emissivePass, 2.5, .5 );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = outputPass.add( bloomPass );

				//

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.target.set( 0, 0, - 0.2 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );

				const bloomFolder = gui.addFolder( 'Bloom' );
				bloomFolder.add( bloomPass.strength, 'value', 0.0, 5.0 ).name( 'strength' );
				bloomFolder.add( bloomPass.radius, 'value', 0.0, 1.0 ).name( 'radius' );

				const toneMappingFolder = gui.addFolder( 'Tone Mapping' );
				toneMappingFolder.add( renderer, 'toneMappingExposure', 0.1, 2 ).name( 'exposure' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_bloom_selective.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - bloom selective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Selective Bloom</span>
			</div>

			<small>Using MRT do define whether an object should be affected by Bloom or not.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, mrt, output, float, uniform } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			// scene

			const scene = new THREE.Scene();

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
			camera.position.set( 0, 0, 20 );
			camera.lookAt( 0, 0, 0 );

			const geometry = new THREE.IcosahedronGeometry( 1, 15 );

			for ( let i = 0; i < 50; i ++ ) {

				const color = new THREE.Color();
				color.setHSL( Math.random(), 0.7, Math.random() * 0.2 + 0.05 );

				const bloomIntensity = Math.random() > 0.5 ? 1 : 0;

				const material = new THREE.MeshBasicNodeMaterial( { color: color } );
				material.mrtNode = mrt( {
					bloomIntensity: uniform( bloomIntensity )
				} );

				const sphere = new THREE.Mesh( geometry, material );
				sphere.position.x = Math.random() * 10 - 5;
				sphere.position.y = Math.random() * 10 - 5;
				sphere.position.z = Math.random() * 10 - 5;
				sphere.position.normalize().multiplyScalar( Math.random() * 4.0 + 2.0 );
				sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
				scene.add( sphere );

			}

			// renderer

			const renderer = new THREE.WebGPURenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.inspector = new Inspector();
			renderer.toneMapping = THREE.NeutralToneMapping;
			document.body.appendChild( renderer.domElement );

			// post processing

			const scenePass = pass( scene, camera );
			scenePass.setMRT( mrt( {
				output,
				bloomIntensity: float( 0 ) // default bloom intensity
			} ) );

			const outputPass = scenePass.getTextureNode().toInspector( 'Color' );
			const bloomIntensityPass = scenePass.getTextureNode( 'bloomIntensity' ).toInspector( 'Bloom Intensity' );

			const bloomPass = bloom( outputPass.mul( bloomIntensityPass ) );

			const postProcessing = new THREE.PostProcessing( renderer );
			postProcessing.outputColorTransform = false;
			postProcessing.outputNode = outputPass.add( bloomPass ).renderOutput();

			// controls

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 100;

			// raycaster

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			window.addEventListener( 'pointerdown', ( event ) => {

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {

					const material = intersects[ 0 ].object.material;

					const bloomIntensity = material.mrtNode.get( 'bloomIntensity' );
					bloomIntensity.value = bloomIntensity.value === 0 ? 1 : 0;

				}

			} );

			// gui

			const gui = renderer.inspector.createParameters( 'Settings' );

			const bloomFolder = gui.addFolder( 'Bloom' );
			bloomFolder.add( bloomPass.threshold, 'value', 0.0, 1.0 ).name( 'threshold' );
			bloomFolder.add( bloomPass.strength, 'value', 0.0, 3 ).name( 'strength' );
			bloomFolder.add( bloomPass.radius, 'value', 0.0, 1.0 ).name( 'radius' );

			const toneMappingFolder = gui.addFolder( 'Tone Mapping' );
			toneMappingFolder.add( renderer, 'toneMappingExposure', 0.1, 3 ).name( 'exposure' );

			// events

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			};

			// animate

			function animate() {

				postProcessing.render();

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_ca.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - chromatic aberration</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>CA</span>
			</div>

			<small>Chromatic Aberration effect.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, renderOutput, uniform } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
			import { chromaticAberration } from 'three/addons/tsl/display/ChromaticAberrationNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			const params = {
				enabled: true,
				animated: true,
				strength: 1.5,
				center: new THREE.Vector2( 0.5, 0.5 ),
				scale: 1.2,
				autoRotate: true,
				cameraDistance: 40
			};

			let camera, scene, renderer, clock, mainGroup;
			let controls, postProcessing;

			init();

			async function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );
				camera.position.set( 0, 15, params.cameraDistance );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = 0.1;
				controls.autoRotate = true;
				controls.autoRotateSpeed = - 0.1;
				controls.target.set( 0, 0.5, 0 );
				controls.update();

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x0a0a0a );

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;

				clock = new THREE.Clock();

				// Create main group
				mainGroup = new THREE.Group();
				scene.add( mainGroup );

				// Create shapes
				createShapes();

				// Add a grid for reference
				const gridHelper = new THREE.GridHelper( 40, 20, 0x444444, 0x222222 );
				gridHelper.position.y = - 10;
				scene.add( gridHelper );

				// post processing
				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputColorTransform = false;

				// scene pass
				const scenePass = pass( scene, camera );
				const outputPass = renderOutput( scenePass );

				// Create uniform nodes for the static version that can be updated
				const staticStrength = uniform( params.strength );
				const staticCenter = uniform( new THREE.Vector2( params.center.x, params.center.y ) );
				const staticScale = uniform( params.scale );

				// With static values (using uniform nodes)
				const caPass = chromaticAberration( outputPass, staticStrength, staticCenter, staticScale );

				// Set initial output based on params
				postProcessing.outputNode = params.enabled ? caPass : outputPass;

				window.addEventListener( 'resize', onWindowResize );

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( params, 'enabled' ).onChange( ( value ) => {

					postProcessing.outputNode = value ? caPass : outputPass;
					postProcessing.needsUpdate = true;

				} );

				const staticFolder = gui.addFolder( 'Static Parameters' );

				staticFolder.add( staticStrength, 'value', 0, 3 ).name( 'Strength' );
				staticFolder.add( staticCenter.value, 'x', - 1, 1 ).name( 'Center X' );
				staticFolder.add( staticCenter.value, 'y', - 1, 1 ).name( 'Center Y' );
				staticFolder.add( staticScale, 'value', 0.5, 2 ).name( 'Scale' );

				const animationFolder = gui.addFolder( 'Animation' );
				animationFolder.add( params, 'animated' );
				animationFolder.add( params, 'autoRotate' ).onChange( ( value ) => {

					controls.autoRotate = value;

				} );

			}

			function createShapes() {

				const shapes = [];
				const materials = [];

				// Define colors for different materials
				const colors = [
					0xff0000, // Red
					0x00ff00, // Green
					0x0000ff, // Blue
					0xffff00, // Yellow
					0xff00ff, // Magenta
					0x00ffff, // Cyan
					0xffffff, // White
					0xff8800 // Orange
				];

				// Create materials
				colors.forEach( color => {

					materials.push( new THREE.MeshStandardMaterial( {
						color: color,
						roughness: 0.2,
						metalness: 0.8
					} ) );

				} );

				// Create geometries
				const geometries = [
					new THREE.BoxGeometry( 3, 3, 3 ),
					new THREE.SphereGeometry( 2, 32, 16 ),
					new THREE.ConeGeometry( 2, 4, 8 ),
					new THREE.CylinderGeometry( 1.5, 1.5, 4, 8 ),
					new THREE.TorusGeometry( 2, 0.8, 8, 16 ),
					new THREE.OctahedronGeometry( 2.5 ),
					new THREE.IcosahedronGeometry( 2.5 ),
					new THREE.TorusKnotGeometry( 1.5, 0.5, 64, 8 )
				];

				// Create central showcase
				const centralGroup = new THREE.Group();

				// Large central torus
				const centralTorus = new THREE.Mesh(
					new THREE.TorusGeometry( 5, 1.5, 16, 32 ),
					new THREE.MeshStandardMaterial( {
						color: 0xffffff,
						roughness: 0.1,
						metalness: 1,
						emissive: 0x222222
					} )
				);
				centralGroup.add( centralTorus );

				// Inner rotating shapes
				for ( let i = 0; i < 6; i ++ ) {

					const angle = ( i / 6 ) * Math.PI * 2;
					const radius = 3;

					const mesh = new THREE.Mesh(
						geometries[ i % geometries.length ],
						materials[ i % materials.length ]
					);

					mesh.position.set(
						Math.cos( angle ) * radius,
						0,
						Math.sin( angle ) * radius
					);

					mesh.scale.setScalar( 0.5 );
					centralGroup.add( mesh );
					shapes.push( mesh );

				}

				mainGroup.add( centralGroup );
				shapes.push( centralGroup );

				// Create outer ring of shapes
				const numShapes = 12;
				const outerRadius = 15;

				for ( let i = 0; i < numShapes; i ++ ) {

					const angle = ( i / numShapes ) * Math.PI * 2;
					const shapesGroup = new THREE.Group();

					const geometry = geometries[ i % geometries.length ];
					const material = materials[ i % materials.length ];

					const mesh = new THREE.Mesh( geometry, material );
					mesh.castShadow = true;
					mesh.receiveShadow = true;

					shapesGroup.add( mesh );
					shapesGroup.position.set(
						Math.cos( angle ) * outerRadius,
						Math.sin( i * 0.5 ) * 2,
						Math.sin( angle ) * outerRadius
					);

					mainGroup.add( shapesGroup );
					shapes.push( shapesGroup );

				}

				// Add floating particles
				const particlesGeometry = new THREE.BufferGeometry();
				const particlesCount = 200;
				const positions = new Float32Array( particlesCount * 3 );

				for ( let i = 0; i < particlesCount * 3; i += 3 ) {

					const radius = 25 + Math.random() * 10;
					const theta = Math.random() * Math.PI * 2;
					const phi = Math.random() * Math.PI;

					positions[ i ] = radius * Math.sin( phi ) * Math.cos( theta );
					positions[ i + 1 ] = radius * Math.cos( phi );
					positions[ i + 2 ] = radius * Math.sin( phi ) * Math.sin( theta );

				}

				particlesGeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

				const particlesMaterial = new THREE.PointsMaterial( {
					color: 0xffffff,
					size: 0.5,
					sizeAttenuation: true
				} );

				const particles = new THREE.Points( particlesGeometry, particlesMaterial );
				mainGroup.add( particles );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = clock.getElapsedTime();

				controls.update();

				if ( params.animated ) {

					// Animate individual shapes
					mainGroup.children.forEach( ( child, index ) => {

						if ( child.children.length > 0 ) {

							// Central group
							child.rotation.y = time * 0.5;
							child.children.forEach( ( subChild, subIndex ) => {

								if ( subChild.geometry ) {

									subChild.rotation.x = time * ( 1 + subIndex * 0.1 );
									subChild.rotation.z = time * ( 1 - subIndex * 0.1 );

								}

							} );

						} else if ( child.type === 'Group' ) {

							// Outer shapes
							child.rotation.x = time * 0.5 + index;
							child.rotation.y = time * 0.3 + index;
							child.position.y = Math.sin( time + index ) * 2;

						}

					} );

				}

				postProcessing.render();
			
			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_difference.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - frame difference</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Difference</span>
			</div>

			<small>Saturated color of objects according to the difference from one frame to another.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, luminance, saturation } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			const params = {
				speed: 0
			};

			let camera, renderer, postProcessing;
			let timer, mesh, controls;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				renderer.toneMapping = THREE.NeutralToneMapping;
				document.body.appendChild( renderer.domElement );

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 100 );
				camera.position.set( 1, 2, 3 );

				const scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x0487e2, 7, 25 );
				scene.background = new THREE.Color( 0x0487e2 );

				timer = new THREE.Timer();
				timer.connect( document );

				const texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
				texture.colorSpace = THREE.SRGBColorSpace;

				const geometry = new THREE.BoxGeometry();
				const material = new THREE.MeshBasicMaterial( { map: texture } );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );

				const currentTexture = scenePass.getTextureNode();
				const previousTexture = scenePass.getPreviousTextureNode();

				const frameDiff = previousTexture.sub( currentTexture ).abs();

				const saturationAmount = luminance( frameDiff ).mul( 1000 ).clamp( 0, 3 );

				postProcessing.outputNode = saturation( currentTexture, saturationAmount );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.enableDamping = true;
				controls.dampingFactor = 0.01;

				window.addEventListener( 'resize', onWindowResize );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( params, 'speed', 0, 2 );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				timer.update();

				controls.update();

				mesh.rotation.y += timer.getDelta() * 5 * params.speed;

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_dof.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing dof</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>DoF</span>
			</div>

			<small>High-Quality Depth-of-Field effect.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { cubeTexture, positionWorld, oscSine, time, pass, uniform } from 'three/tsl';
			import { dof } from 'three/addons/tsl/display/DepthOfFieldNode.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			//

			let camera, scene, renderer, mesh, controls;

			let width = window.innerWidth;
			let height = window.innerHeight;

			let postProcessing;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, width / height, 1, 3500 );
				camera.position.z = 200;

				scene = new THREE.Scene();

				const path = 'textures/cube/SwedishRoyalCastle/';
				const format = '.jpg';
				const urls = [
					path + 'px' + format, path + 'nx' + format,
					path + 'py' + format, path + 'ny' + format,
					path + 'pz' + format, path + 'nz' + format
				];

				const xgrid = 14, ygrid = 9, zgrid = 14;
				const count = xgrid * ygrid * zgrid;

				const textureCube = new THREE.CubeTextureLoader().load( urls );
				const cubeTextureNode = cubeTexture( textureCube );
				const oscPos = oscSine( positionWorld.div( 1000 /* scene distance */ ).add( time.mul( .2 ) ) );

				const geometry = new THREE.SphereGeometry( 60, 20, 10 );
				const material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = cubeTextureNode.mul( oscPos );

				mesh = new THREE.InstancedMesh( geometry, material, count );
				scene.add( mesh );

				const matrix = new THREE.Matrix4();

				let index = 0;

				for ( let i = 0; i < xgrid; i ++ ) {

					for ( let j = 0; j < ygrid; j ++ ) {

						for ( let k = 0; k < zgrid; k ++ ) {

							const x = 200 * ( i - xgrid / 2 );
							const y = 200 * ( j - ygrid / 2 );
							const z = 200 * ( k - zgrid / 2 );

							mesh.setMatrixAt( index, matrix.identity().setPosition( x, y, z ) );
							index ++;

						}

					}

				}

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				const effectController = {
					focusDistance: uniform( 500 ),
					focalLength: uniform( 200 ),
					bokehScale: uniform( 10 )
				};

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );

				const scenePassColor = scenePass.getTextureNode().toInspector( 'Color' );
				const scenePassViewZ = scenePass.getViewZNode();

				const dofPass = dof( scenePassColor, scenePassViewZ, effectController.focusDistance, effectController.focalLength, effectController.bokehScale );

				postProcessing.outputNode = dofPass;

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( effectController.focusDistance, 'value', 10.0, 3000.0 ).name( 'focus distance' );
				gui.add( effectController.focalLength, 'value', 50, 750 ).name( 'focal length' );
				gui.add( effectController.bokehScale, 'value', 1, 20 ).name( 'bokeh scale' );

			}

			function onWindowResize() {

				width = window.innerWidth;
				height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_dof_basic.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing dof - basic</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>DoF Basic</span>
			</div>

			<small>
				Performant Depth-of-Field effect with a simple box blur. Click on a position in the scene to focus it.<br />
				<a href="https://skfb.ly/opNFG" target="_blank" rel="noopener">Bath day</a> by 
				<a href="https://sketchfab.com/stanst" target="_blank" rel="noopener">Stan.St</a> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">Creative Commons Attribution</a>.<br />
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mix, pass, renderOutput, smoothstep, uniform, vec3 } from 'three/tsl';
			import { boxBlur } from 'three/addons/tsl/display/boxBlur.js';
			import { fxaa } from 'three/addons/tsl/display/FXAANode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';
			import TWEEN from 'three/addons/libs/tween.module.js';

			let camera, controls, scene, timer, renderer, model, mixer, raycaster, postProcessing;

			const pointerCoords = new THREE.Vector2();
			const focusPoint = new THREE.Vector3( 1, 1.75, - 0.4 );
			const focusPointView = uniform( vec3() );

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( - 6, 5, 6 );

				controls = new OrbitControls( camera );
				controls.target.set( 0, 2, 0 );
				controls.enableDamping = true;
				controls.update();

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x90D5FF );

				raycaster = new THREE.Raycaster();

				timer = new THREE.Timer();

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );
			
				const loader = new GLTFLoader();
				loader.setDRACOLoader( dracoLoader );
				const gltf = await loader.loadAsync( 'models/gltf/bath_day.glb' );

				model = gltf.scene;
				scene.add( model );

				mixer = new THREE.AnimationMixer( model );
				const action = mixer.clipAction( gltf.animations[ 0 ] );
				action.play();

				//

				const hdrLoader = new UltraHDRLoader();
				hdrLoader.setDataType( THREE.HalfFloatType );
				const envMap = await hdrLoader.loadAsync( 'textures/equirectangular/spruit_sunrise_2k.hdr.jpg' );
				envMap.mapping = THREE.EquirectangularReflectionMapping;
				scene.environmentRotation.y = Math.PI * 0.5;
				scene.environment = envMap;

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				renderer.toneMapping = THREE.NeutralToneMapping;
				document.body.appendChild( renderer.domElement );

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputColorTransform = false;

				// DOF uniforms

				const blurSize = uniform( 2 ); // determines the kernel size of the blur
				const blurSpread = uniform( 4 ); // determines how far the blur is spread
				const minDistance = uniform( 1 ); // all positions at or below minDistance will be completely in focus.
				const maxDistance = uniform( 3 ); // all positions at or beyond maxDistance will be completely out of focus.

				// beauty and blur/out-of-focus pass

				const scenePass = pass( scene, camera );
			
				const scenePassColor = scenePass.getTextureNode().toInspector( 'Color' );
				const scenePassViewZ = scenePass.getViewZNode();
				const scenePassBlurred = boxBlur( scenePassColor, { size: blurSize, separation: blurSpread } );

				// simple DOF from https://lettier.github.io/3d-game-shaders-for-beginners/depth-of-field.html

				const blur = smoothstep( minDistance, maxDistance, scenePassViewZ.sub( focusPointView.z ).abs() );
				const dofPass = mix( scenePassColor, scenePassBlurred, blur );

				const outputPass = renderOutput( dofPass );
				const fxaaPass = fxaa( outputPass );

				postProcessing.outputNode = fxaaPass;

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( minDistance, 'value', 0, 3 ).name( 'min distance' );
				gui.add( maxDistance, 'value', 0, 5 ).name( 'max distance' );
				gui.add( blurSize, 'value', 1, 3, 1 ).name( 'blur size' );
				gui.add( blurSpread, 'value', 1, 7, 1 ).name( 'blur spread' );

				//

				controls.connect( renderer.domElement );

				renderer.domElement.addEventListener( 'pointerdown', onPointerDown );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onPointerDown( event ) {

				pointerCoords.set(
					( event.clientX / window.innerWidth ) * 2 - 1,
					- ( event.clientY / window.innerHeight ) * 2 + 1
				);

				raycaster.setFromCamera( pointerCoords, camera );

				const intersects = raycaster.intersectObject( model );

				if ( intersects.length > 0 ) {

					TWEEN.removeAll();

					new TWEEN.Tween( focusPoint )
						.to( intersects[ 0 ].point, 500 )
						.easing( TWEEN.Easing.Cubic.InOut )
						.start();

				}
			
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				TWEEN.update();

				controls.update();

				timer.update();

				mixer.update( timer.getDelta() );

				// since the focus point is expressed in view space, it must be updated on every
				// camera change. for simplicity, do this every frame.

				camera.updateMatrixWorld();
				focusPointView.value.copy( focusPoint ).applyMatrix4( camera.matrixWorldInverse );

				postProcessing.render();


			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_fxaa.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - FXAA</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>FXAA</span>
			</div>

			<small>Fast Approximate Anti-Aliasing.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, renderOutput } from 'three/tsl';
			import { fxaa } from 'three/addons/tsl/display/FXAANode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			const params = {
				enabled: true,
				animated: false
			};

			let camera, scene, renderer, clock, group;
			let postProcessing;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );
				camera.position.z = 50;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );

				clock = new THREE.Clock();

				//

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d );
				hemiLight.position.set( 0, 1000, 0 );
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.position.set( - 3000, 1000, - 1000 );
				scene.add( dirLight );

				//

				group = new THREE.Group();

				const geometry = new THREE.TetrahedronGeometry();
				const material = new THREE.MeshStandardMaterial( { color: 0xf73232, flatShading: true } );

				for ( let i = 0; i < 100; i ++ ) {

					const mesh = new THREE.Mesh( geometry, material );

					mesh.position.x = Math.random() * 50 - 25;
					mesh.position.y = Math.random() * 50 - 25;
					mesh.position.z = Math.random() * 50 - 25;

					mesh.scale.setScalar( Math.random() * 2 + 1 );

					mesh.rotation.x = Math.random() * Math.PI;
					mesh.rotation.y = Math.random() * Math.PI;
					mesh.rotation.z = Math.random() * Math.PI;

					group.add( mesh );

				}

				scene.add( group );

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				// ignore default output color transform ( toneMapping and outputColorSpace )
				// use renderOutput() for control the sequence

				postProcessing.outputColorTransform = false;

				// scene pass

				const scenePass = pass( scene, camera ).toInspector( 'Color' );
				const outputPass = renderOutput( scenePass );

				// FXAA must be computed in sRGB color space (so after tone mapping and color space conversion)

				const fxaaPass = fxaa( outputPass );
				postProcessing.outputNode = fxaaPass;

				//

				window.addEventListener( 'resize', onWindowResize );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( params, 'enabled' ).onChange( ( value ) => {
			
					if ( value === true ) {

						postProcessing.outputNode = fxaaPass;

					} else {

						postProcessing.outputNode = outputPass;

					}

					postProcessing.needsUpdate = true;

				} );
				gui.add( params, 'animated' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				const delta = clock.getDelta();

				if ( params.animated === true ) {

					group.rotation.y += delta * 0.1;

				}

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_lensflare.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing lensflares</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Lensflares</span>
			</div>

			<small>
				Bloom based Lensflares via Post Processing.<br />
				<a href="https://skfb.ly/6SqUF" target="_blank" rel="noopener">Space Ship Hallway</a> by 
				<a href="https://sketchfab.com/yeeyeeman" target="_blank" rel="noopener">yeeyeeman</a> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">Creative Commons Attribution</a>.<br />
				<a href="https://www.spacespheremaps.com/planetary-spheremaps/" target="_blank" rel="noopener">Ice Planet Close</a> from <a href="https://www.spacespheremaps.com/" target="_blank" rel="noopener">Space Spheremaps</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, mrt, output, emissive, uniform } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';
			import { lensflare } from 'three/addons/tsl/display/LensflareNode.js';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, controls;
			let postProcessing;

			init();

			async function init() {

				//

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 0.5, - 0.5 );

				scene = new THREE.Scene();

				const texture = await new UltraHDRLoader().loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );

				texture.mapping = THREE.EquirectangularReflectionMapping;

				scene.background = texture;
				scene.environment = texture;

				scene.backgroundIntensity = 2;
				scene.environmentIntensity = 15;

				// model

				const loader = new GLTFLoader();
				const gltf = await loader.loadAsync( 'models/gltf/space_ship_hallway.glb' );

				const object = gltf.scene;

				const aabb = new THREE.Box3().setFromObject( object );
				const center = aabb.getCenter( new THREE.Vector3() );

				object.position.x += ( object.position.x - center.x );
				object.position.y += ( object.position.y - center.y );
				object.position.z += ( object.position.z - center.z );

				scene.add( object );
			
				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output,
					emissive
				} ) );

				const outputPass = scenePass.getTextureNode().toInspector( 'Color' );
				const emissivePass = scenePass.getTextureNode( 'emissive' ).toInspector( 'Emissive' );

				const bloomPass = bloom( emissivePass, 1, 1 ).toInspector( 'Bloom' );

				const threshold = uniform( 0.5 );
				const ghostAttenuationFactor = uniform( 25 );
				const ghostSpacing = uniform( 0.25 );

				const flarePass = lensflare( bloomPass, {
					threshold,
					ghostAttenuationFactor,
					ghostSpacing
				} );

				const blurPass = gaussianBlur( flarePass, 8 ); // optional (blurring produces better flare quality but also adds some overhead)

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = outputPass.add( bloomPass ).add( blurPass );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.enablePan = false;
				controls.enableZoom = false;
				controls.target.copy( camera.position );
				controls.target.z -= 0.01;
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );

				const bloomFolder = gui.addFolder( 'bloom' );
				bloomFolder.add( bloomPass.strength, 'value', 0.0, 2.0 ).name( 'strength' );
				bloomFolder.add( bloomPass.radius, 'value', 0.0, 1.0 ).name( 'radius' );
			
				const lensflareFolder = gui.addFolder( 'lensflare' );
				lensflareFolder.add( threshold, 'value', 0.0, 1.0 ).name( 'threshold' );
				lensflareFolder.add( ghostAttenuationFactor, 'value', 10.0, 50.0 ).name( 'attenuation' );
				lensflareFolder.add( ghostSpacing, 'value', 0.0, 0.3 ).name( 'spacing' );

				const toneMappingFolder = gui.addFolder( 'tone mapping' );
				toneMappingFolder.add( renderer, 'toneMappingExposure', 0.1, 2 ).name( 'exposure' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				controls.update();

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_masking.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - masking</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Masking</span>
			</div>

			<small>Masking via Post Processing.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, texture } from 'three/tsl';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, postProcessing, renderer;
			let box, torus;

			init();

			function init() {

				// scene

				const baseScene = new THREE.Scene();
				baseScene.background = new THREE.Color( 0xe0e0e0 );

				const maskScene1 = new THREE.Scene();
				box = new THREE.Mesh( new THREE.BoxGeometry( 4, 4, 4 ) );
				maskScene1.add( box );

				const maskScene2 = new THREE.Scene();
				torus = new THREE.Mesh( new THREE.TorusGeometry( 3, 1, 16, 32 ) );
				maskScene2.add( torus );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 10;

				// textures

				const texture1 = new THREE.TextureLoader().load( 'textures/758px-Canestra_di_frutta_(Caravaggio).jpg' );
				texture1.colorSpace = THREE.SRGBColorSpace;
				texture1.minFilter = THREE.LinearFilter;
				texture1.generateMipmaps = false;
				texture1.flipY = false;

				const texture2 = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );
				texture2.colorSpace = THREE.SRGBColorSpace;
				texture2.flipY = false;

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

				// post processing

				const base = pass( baseScene, camera );
				const sceneMask1 = pass( maskScene1, camera ).a;
				const sceneMask2 = pass( maskScene2, camera ).a;

				let compose = base;
				compose = sceneMask1.mix( compose, texture( texture1 ) );
				compose = sceneMask2.mix( compose, texture( texture2 ) );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = compose;

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				const time = performance.now() * 0.001 + 6000;

				box.position.x = Math.cos( time / 1.5 ) * 2;
				box.position.y = Math.sin( time ) * 2;
				box.rotation.x = time;
				box.rotation.y = time / 2;

				torus.position.x = Math.cos( time ) * 2;
				torus.position.y = Math.sin( time / 1.5 ) * 2;
				torus.rotation.x = time;
				torus.rotation.y = time / 2;

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_motion_blur.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - motion blur</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Motion Blur</span>
			</div>

			<small>Motion Blur based on Velocity (Motion Vectors).</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, texture, uniform, output, mrt, velocity, uv, screenUV } from 'three/tsl';
			import { motionBlur } from 'three/addons/tsl/display/MotionBlur.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let boxLeft, boxRight, model, mixer, clock;
			let postProcessing;
			let controls;

			const params = {
				speed: 1.0
			};

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );
				camera.position.set( 0, 1.5, 4.5 );

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x0487e2, 7, 25 );

				const sunLight = new THREE.DirectionalLight( 0xFFE499, 5 );
				sunLight.castShadow = true;
				sunLight.shadow.camera.near = .1;
				sunLight.shadow.camera.far = 10;
				sunLight.shadow.camera.right = 2;
				sunLight.shadow.camera.left = - 2;
				sunLight.shadow.camera.top = 2;
				sunLight.shadow.camera.bottom = - 2;
				sunLight.shadow.mapSize.width = 2048;
				sunLight.shadow.mapSize.height = 2048;
				sunLight.shadow.bias = - 0.001;
				sunLight.position.set( 4, 4, 2 );

				const waterAmbientLight = new THREE.HemisphereLight( 0x333366, 0x74ccf4, 5 );
				const skyAmbientLight = new THREE.HemisphereLight( 0x74ccf4, 0, 1 );

				scene.add( sunLight );
				scene.add( skyAmbientLight );
				scene.add( waterAmbientLight );

				clock = new THREE.Clock();

				// animated model

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Xbot.glb', function ( gltf ) {

					model = gltf.scene;

					model.rotation.y = Math.PI / 2;

					model.traverse( function ( child ) {

						if ( child.isMesh ) {

							child.castShadow = true;
							child.receiveShadow = true;

						}

					} );

					mixer = new THREE.AnimationMixer( model );

					const action = mixer.clipAction( gltf.animations[ 3 ] );
					action.play();

					scene.add( model );

				} );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const floorColor = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );
				floorColor.wrapS = THREE.RepeatWrapping;
				floorColor.wrapT = THREE.RepeatWrapping;
				floorColor.colorSpace = THREE.SRGBColorSpace;

				const floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );
				floorNormal.wrapS = THREE.RepeatWrapping;
				floorNormal.wrapT = THREE.RepeatWrapping;

				// floor

				const floorUV = uv().mul( 5 );

				const floorMaterial = new THREE.MeshPhongNodeMaterial();
				floorMaterial.colorNode = texture( floorColor, floorUV );

				const floor = new THREE.Mesh( new THREE.BoxGeometry( 15, .001, 15 ), floorMaterial );
				floor.receiveShadow = true;

				floor.position.set( 0, 0, 0 );
				scene.add( floor );

				const walls = new THREE.Mesh( new THREE.BoxGeometry( 15, 15, 15 ), new THREE.MeshPhongNodeMaterial( { colorNode: floorMaterial.colorNode, side: THREE.BackSide } ) );
				scene.add( walls );

				const map = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );
				map.colorSpace = THREE.SRGBColorSpace;

				const geometry = new THREE.TorusGeometry( .8 );
				const material = new THREE.MeshBasicMaterial( { map } );

				boxRight = new THREE.Mesh( geometry, material );
				boxRight.position.set( 3.5, 1.5, - 4 );
				scene.add( boxRight );

				boxLeft = new THREE.Mesh( geometry, material );
				boxLeft.position.set( - 3.5, 1.5, - 4 );
				scene.add( boxLeft );

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI / 2;
				controls.autoRotate = true;
				controls.autoRotateSpeed = 1;
				controls.target.set( 0, 1, 0 );
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;
				controls.update();

				// post-processing

				const blurAmount = uniform( 1 );

				const scenePass = pass( scene, camera );

				scenePass.setMRT( mrt( {
					output,
					velocity
				} ) );

				const beauty = scenePass.getTextureNode().toInspector( 'Color' );
				const vel = scenePass.getTextureNode( 'velocity' ).toInspector( 'Velocity' ).mul( blurAmount );

				const mBlur = motionBlur( beauty, vel );

				const vignette = screenUV.distance( .5 ).remap( .6, 1 ).mul( 2 ).clamp().oneMinus();

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = mBlur.mul( vignette );

				//

				const gui = renderer.inspector.createParameters( 'Motion Blur Settings' );
				gui.add( controls, 'autoRotate' );
				gui.add( blurAmount, 'value', 0, 3 ).name( 'blur amount' );
				gui.add( params, 'speed', 0, 2 );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				const delta = clock.getDelta();
				const speed = params.speed;

				boxRight.rotation.y += delta * 4 * speed;
				boxLeft.scale.setScalar( 1 + Math.sin( clock.elapsedTime * 10 * speed ) * .2 );

				if ( model ) {

					mixer.update( delta * speed );

				}

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_outline.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - post processing - Outline Pass</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Outline</span>
			</div>

			<small>Outline Pass by <a href="http://eduperiment.com" target="_blank" rel="noopener">Prashant Sharma</a> and <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a>.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, uniform, time, oscSine } from 'three/tsl';
			import { outline } from 'three/addons/tsl/display/OutlineNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

			let camera, scene, renderer, controls;
			let postProcessing, outlinePass;

			let selectedObjects = [];

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			const obj3d = new THREE.Object3D();
			const group = new THREE.Group();

			init();

			function init() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				renderer.shadowMap.enabled = true;
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
				camera.position.set( 0, 0, 8 );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 5;
				controls.maxDistance = 20;
				controls.enablePan = false;
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;

				//

				scene.add( new THREE.AmbientLight( 0xaaaaaa, 0.6 ) );

				const light = new THREE.DirectionalLight( 0xddffdd, 2 );
				light.position.set( 5, 5, 5 );
				light.castShadow = true;
				light.shadow.mapSize.width = 2048;
				light.shadow.mapSize.height = 2048;
				light.shadow.bias = - 0.005;

				const d = 10;

				light.shadow.camera.left = - d;
				light.shadow.camera.right = d;
				light.shadow.camera.top = d;
				light.shadow.camera.bottom = - d;
				light.shadow.camera.far = 25;

				scene.add( light );

				// model

				const loader = new OBJLoader();
				loader.load( 'models/obj/tree.obj', function ( object ) {

					let scale = 1.0;

					object.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							child.geometry.center();
							child.geometry.computeBoundingSphere();
							scale = 0.2 * child.geometry.boundingSphere.radius;

							const phongMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x111111, shininess: 5 } );
							child.material = phongMaterial;
							child.receiveShadow = true;
							child.castShadow = true;

						}

					} );

					object.position.y = 1;
					object.scale.divideScalar( scale );
					obj3d.add( object );

				} );

				scene.add( group );

				group.add( obj3d );

				//

				const geometry = new THREE.SphereGeometry( 3, 48, 24 );

				for ( let i = 0; i < 20; i ++ ) {

					const material = new THREE.MeshLambertMaterial();
					material.color.setHSL( Math.random(), 1.0, 0.3 );

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 4 - 2;
					mesh.position.y = Math.random() * 4 - 2;
					mesh.position.z = Math.random() * 4 - 2;
					mesh.receiveShadow = true;
					mesh.castShadow = true;
					mesh.scale.multiplyScalar( Math.random() * 0.3 + 0.1 );
					group.add( mesh );

				}

				const floorMaterial = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );

				const floorGeometry = new THREE.PlaneGeometry( 12, 12 );
				const floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
				floorMesh.rotation.x -= Math.PI * 0.5;
				floorMesh.position.y -= 1.5;
				group.add( floorMesh );
				floorMesh.receiveShadow = true;

				const torusGeometry = new THREE.TorusGeometry( 1, 0.3, 16, 100 );
				const torusMaterial = new THREE.MeshPhongMaterial( { color: 0xffaaff } );
				const torus = new THREE.Mesh( torusGeometry, torusMaterial );
				torus.position.z = - 4;
				group.add( torus );
				torus.receiveShadow = true;
				torus.castShadow = true;

				// outline pass

				const edgeStrength = uniform( 3.0 );
				const edgeGlow = uniform( 0.0 );
				const edgeThickness = uniform( 1.0 );
				const pulsePeriod = uniform( 0 );
				const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );
				const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );

				outlinePass = outline( scene, camera, {
					selectedObjects,
					edgeGlow,
					edgeThickness
				} );

				const { visibleEdge, hiddenEdge } = outlinePass;

				const period = time.div( pulsePeriod ).mul( 2 );
				const osc = oscSine( period ).mul( .5 ).add( .5 ); // osc [ 0.5, 1.0 ]

				const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );
				const outlinePulse = pulsePeriod.greaterThan( 0 ).select( outlineColor.mul( osc ), outlineColor );

				// postprocessing

				const scenePass = pass( scene, camera ).toInspector( 'Color' );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = outlinePulse.add( scenePass );

				// gui

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( edgeStrength, 'value', 0.01, 10 ).name( 'edgeStrength' );
				gui.add( edgeGlow, 'value', 0.0, 1 ).name( 'edgeGlow' );
				gui.add( edgeThickness, 'value', 1, 4 ).name( 'edgeThickness' );
				gui.add( pulsePeriod, 'value', 0.0, 5 ).name( 'pulsePeriod' );
				gui.addColor( { color: visibleEdgeColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' ).onChange( ( value ) => {

					visibleEdgeColor.value.set( value );

				} ).name( 'visibleEdgeColor' );
				gui.addColor( { color: hiddenEdgeColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' ).onChange( ( value ) => {

					hiddenEdgeColor.value.set( value );

				} ).name( 'hiddenEdgeColor' );

				//

				window.addEventListener( 'resize', onWindowResize );

				renderer.domElement.style.touchAction = 'none';
				renderer.domElement.addEventListener( 'pointermove', onPointerMove );

				function onPointerMove( event ) {

					if ( event.isPrimary === false ) return;

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					checkIntersection();

				}

				function addSelectedObject( object ) {

					selectedObjects = [];
					selectedObjects.push( object );

				}

				function checkIntersection() {

					raycaster.setFromCamera( mouse, camera );

					const intersects = raycaster.intersectObject( scene, true );

					if ( intersects.length > 0 ) {

						const selectedObject = intersects[ 0 ].object;
						addSelectedObject( selectedObject );
						outlinePass.selectedObjects = selectedObjects;

					} else {

						// outlinePass.selectedObjects = [];

					}

				}

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_pixel.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing pixel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

<body>

	<div id="info">
		<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

		<div class="title-wrapper">
			<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Pixelation</span>
		</div>

		<small>Node based pixelation pass with optional single pixel outlines by <a href="https://github.com/KodyJKing" target="_blank" rel="noopener">Kody King</a>.</small>
	</div>

	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
				"three/tsl": "../build/three.tsl.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>
	

	<script type="module">

		import * as THREE from 'three/webgpu';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { Inspector } from 'three/addons/inspector/Inspector.js';

		import { uniform } from 'three/tsl';
		import { pixelationPass } from 'three/addons/tsl/display/PixelationPassNode.js';

		let camera, scene, renderer, postProcessing, crystalMesh, clock;
		let effectController;

		init();

		function init() {

			const aspectRatio = window.innerWidth / window.innerHeight;

			camera = new THREE.OrthographicCamera( - aspectRatio, aspectRatio, 1, - 1, 0.1, 10 );
			camera.position.y = 2 * Math.tan( Math.PI / 6 );
			camera.position.z = 2;

			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0x151729 );

			clock = new THREE.Clock();

			// textures

			const loader = new THREE.TextureLoader();
			const texChecker = pixelTexture( loader.load( 'textures/checker.png' ) );
			const texChecker2 = pixelTexture( loader.load( 'textures/checker.png' ) );
			texChecker.repeat.set( 3, 3 );
			texChecker2.repeat.set( 1.5, 1.5 );

			// meshes

			const boxMaterial = new THREE.MeshPhongMaterial( { map: texChecker2 } );

			function addBox( boxSideLength, x, z, rotation ) {

				const mesh = new THREE.Mesh( new THREE.BoxGeometry( boxSideLength, boxSideLength, boxSideLength ), boxMaterial );
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				mesh.rotation.y = rotation;
				mesh.position.y = boxSideLength / 2;
				mesh.position.set( x, boxSideLength / 2 + .0001, z );
				scene.add( mesh );
				return mesh;

			}

			addBox( .4, 0, 0, Math.PI / 4 );
			addBox( .5, - .5, - .5, Math.PI / 4 );

			const planeSideLength = 2;
			const planeMesh = new THREE.Mesh(
				new THREE.PlaneGeometry( planeSideLength, planeSideLength ),
				new THREE.MeshPhongMaterial( { map: texChecker } )
			);
			planeMesh.receiveShadow = true;
			planeMesh.rotation.x = - Math.PI / 2;
			scene.add( planeMesh );

			const radius = .2;
			const geometry = new THREE.IcosahedronGeometry( radius );
			crystalMesh = new THREE.Mesh(
				geometry,
				new THREE.MeshPhongMaterial( {
					color: 0x68b7e9,
					emissive: 0x4f7e8b,
					shininess: 10,
					specular: 0xffffff
				} )
			);
			crystalMesh.receiveShadow = true;
			crystalMesh.castShadow = true;
			scene.add( crystalMesh );

			// lights

			scene.add( new THREE.AmbientLight( 0x757f8e, 3 ) );

			const directionalLight = new THREE.DirectionalLight( 0xfffecd, 1.5 );
			directionalLight.position.set( 100, 100, 100 );
			directionalLight.castShadow = true;
			directionalLight.shadow.mapSize.set( 2048, 2048 );
			directionalLight.shadow.bias = - 0.0001;
			scene.add( directionalLight );

			const spotLight = new THREE.SpotLight( 0xffc100, 10, 10, Math.PI / 16, .02, 2 );
			spotLight.position.set( 2, 2, 0 );
			const target = spotLight.target;
			scene.add( target );
			target.position.set( 0, 0, 0 );
			spotLight.castShadow = true;
			spotLight.shadow.bias = - 0.001;
			scene.add( spotLight );

			renderer = new THREE.WebGPURenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.inspector = new Inspector();
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.BasicShadowMap;
			document.body.appendChild( renderer.domElement );

			effectController = {
				pixelSize: uniform( 6 ),
				normalEdgeStrength: uniform( 0.3 ),
				depthEdgeStrength: uniform( 0.4 ),
				pixelAlignedPanning: true
			};

			postProcessing = new THREE.PostProcessing( renderer );
			const scenePass = pixelationPass( scene, camera, effectController.pixelSize, effectController.normalEdgeStrength, effectController.depthEdgeStrength );
			postProcessing.outputNode = scenePass;

			window.addEventListener( 'resize', onWindowResize );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.maxZoom = 2;

			// gui

			const gui = renderer.inspector.createParameters( 'Settings' );
			gui.add( effectController.pixelSize, 'value', 1, 16, 1 ).name( 'Pixel Size' );
			gui.add( effectController.normalEdgeStrength, 'value', 0, 2, 0.05 ).name( 'Normal Edge Strength' );
			gui.add( effectController.depthEdgeStrength, 'value', 0, 1, 0.05 ).name( 'Depth Edge Strength' );
			gui.add( effectController, 'pixelAlignedPanning' );

		}

		function onWindowResize() {

			const aspectRatio = window.innerWidth / window.innerHeight;
			camera.left = - aspectRatio;
			camera.right = aspectRatio;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			const t = clock.getElapsedTime();

			crystalMesh.material.emissiveIntensity = Math.sin( t * 3 ) * .5 + .5;
			crystalMesh.position.y = .7 + Math.sin( t * 2 ) * .05;
			crystalMesh.rotation.y = stopGoEased( t, 2, 4 ) * 2 * Math.PI;

			const rendererSize = renderer.getSize( new THREE.Vector2() );
			const aspectRatio = rendererSize.x / rendererSize.y;

			if ( effectController.pixelAlignedPanning ) {

				const pixelSize = effectController.pixelSize.value;

				pixelAlignFrustum( camera, aspectRatio, Math.floor( rendererSize.x / pixelSize ),
					Math.floor( rendererSize.y / pixelSize ) );

			} else if ( camera.left != - aspectRatio || camera.top != 1.0 ) {

				// Reset the Camera Frustum if it has been modified
				camera.left = - aspectRatio;
				camera.right = aspectRatio;
				camera.top = 1.0;
				camera.bottom = - 1.0;
				camera.updateProjectionMatrix();

			}

			postProcessing.render();

		}

		// Helper functions

		function pixelTexture( texture ) {

			texture.minFilter = THREE.NearestFilter;
			texture.magFilter = THREE.NearestFilter;
			texture.generateMipmaps = false;
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.colorSpace = THREE.SRGBColorSpace;
			return texture;

		}

		function easeInOutCubic( x ) {

			return x ** 2 * 3 - x ** 3 * 2;

		}

		function linearStep( x, edge0, edge1 ) {

			const w = edge1 - edge0;
			const m = 1 / w;
			const y0 = - m * edge0;
			return THREE.MathUtils.clamp( y0 + m * x, 0, 1 );

		}

		function stopGoEased( x, downtime, period ) {

			const cycle = ( x / period ) | 0;
			const tween = x - cycle * period;
			const linStep = easeInOutCubic( linearStep( tween, downtime, period ) );
			return cycle + linStep;

		}

		function pixelAlignFrustum( camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight ) {

			// 0. Get Pixel Grid Units
			const worldScreenWidth = ( ( camera.right - camera.left ) / camera.zoom );
			const worldScreenHeight = ( ( camera.top - camera.bottom ) / camera.zoom );
			const pixelWidth = worldScreenWidth / pixelsPerScreenWidth;
			const pixelHeight = worldScreenHeight / pixelsPerScreenHeight;

			// 1. Project the current camera position along its local rotation bases
			const camPos = new THREE.Vector3(); camera.getWorldPosition( camPos );
			const camRot = new THREE.Quaternion(); camera.getWorldQuaternion( camRot );
			const camRight = new THREE.Vector3( 1.0, 0.0, 0.0 ).applyQuaternion( camRot );
			const camUp = new THREE.Vector3( 0.0, 1.0, 0.0 ).applyQuaternion( camRot );
			const camPosRight = camPos.dot( camRight );
			const camPosUp = camPos.dot( camUp );

			// 2. Find how far along its position is along these bases in pixel units
			const camPosRightPx = camPosRight / pixelWidth;
			const camPosUpPx = camPosUp / pixelHeight;

			// 3. Find the fractional pixel units and convert to world units
			const fractX = camPosRightPx - Math.round( camPosRightPx );
			const fractY = camPosUpPx - Math.round( camPosUpPx );

			// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid
			camera.left = - aspectRatio - ( fractX * pixelWidth );
			camera.right = aspectRatio - ( fractX * pixelWidth );
			camera.top = 1.0 - ( fractY * pixelHeight );
			camera.bottom = - 1.0 - ( fractY * pixelHeight );
			camera.updateProjectionMatrix();

		}

	</script>
</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_smaa.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing smaa</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>SMAA</span>
			</div>

			<small>Subpixel Morphological Anti-Aliasing.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass } from 'three/tsl';
			import { smaa } from 'three/addons/tsl/display/SMAANode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, postProcessing;

			const params = {
				enabled: true,
				autoRotate: true

			};

			init();

			function init() {

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 300;

				scene = new THREE.Scene();

				const geometry = new THREE.BoxGeometry( 120, 120, 120 );
				const material1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );

				const mesh1 = new THREE.Mesh( geometry, material1 );
				mesh1.position.x = - 100;
				scene.add( mesh1 );

				const texture = new THREE.TextureLoader().load( 'textures/brick_diffuse.jpg' );
				texture.colorSpace = THREE.SRGBColorSpace;

				const material2 = new THREE.MeshBasicMaterial( { map: texture } );

				const mesh2 = new THREE.Mesh( geometry, material2 );
				mesh2.position.x = 100;
				scene.add( mesh2 );

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera ).toInspector( 'Color' );
				const smaaPass = smaa( scenePass );

				postProcessing.outputNode = smaaPass;

				//

				window.addEventListener( 'resize', onWindowResize );

				const gui = renderer.inspector.createParameters( 'Settings' );

				const smaaFolder = gui.addFolder( 'SMAA' );
				smaaFolder.add( params, 'enabled' ).onChange( ( value ) => {
			
					if ( value === true ) {

						postProcessing.outputNode = smaaPass;

					} else {

						postProcessing.outputNode = scenePass;

					}

					postProcessing.needsUpdate = true;

				} );

				const sceneFolder = gui.addFolder( 'Scene' );
				sceneFolder.add( params, 'autoRotate' );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				if ( params.autoRotate === true ) {

					for ( let i = 0; i < scene.children.length; i ++ ) {

						const child = scene.children[ i ];

						child.rotation.x += 0.005;
						child.rotation.y += 0.01;

					}

				}

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_sobel.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing sobel</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span> Sobel</span>
			</div>

			<small>Edge Detection with a Sobel operator.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, renderOutput } from 'three/tsl';
			import { sobel } from 'three/addons/tsl/display/SobelOperatorNode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, controls;
			let postProcessing;

			const params = {
				enabled: true
			};

			init();

			async function init() {

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 1, 3 );

				//

				const loader = new GLTFLoader();
				const gltf = await loader.loadAsync( 'models/gltf/DragonAttenuation.glb' );
				const model = gltf.scene.children[ 1 ];
				model.material = new THREE.MeshStandardNodeMaterial();

				scene.add( model );
			
				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				renderer.toneMapping = THREE.LinearToneMapping;
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene.environment = pmremGenerator.fromScene( environment ).texture;
				pmremGenerator.dispose();

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.enableZoom = false;
				controls.target.set( 0, 0.5, 0 );
				controls.update();


				// postprocessing

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputColorTransform = false;

				const scenePass = pass( scene, camera );

				postProcessing.outputNode = sobel( renderOutput( scenePass ) );

				//

				const gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( params, 'enabled' );

				//

				window.addEventListener( 'resize', onWindowResize );

			}


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				if ( params.enabled === true ) {

					postProcessing.render();

				} else {

					renderer.render( scene, camera );

				}

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_ssaa.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing ssaa</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>SSAA</span>
			</div>

			<small>Unbiased Manual Supersampling Anti-Aliasing (SSAA) pass by <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a>.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { ssaaPass } from 'three/addons/tsl/display/SSAAPassNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let scene, mesh, renderer, postProcessing;
			let camera, ssaaRenderPass;
			let timer;

			const params = {
				sampleLevel: 3,
				camera: 'perspective',
				clearColor: 'black',
				clearAlpha: 1.0,
				viewOffsetX: 0,
				autoRotate: true

			};

			init();

			function init() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				timer = new THREE.Timer();
				timer.connect( document );

				camera = new THREE.PerspectiveCamera( 65, width / height, 3, 10 );
				camera.position.z = 7;
				camera.setViewOffset( width, height, params.viewOffsetX, 0, width, height );

				scene = new THREE.Scene();

				const group = new THREE.Group();
				scene.add( group );

				const light = new THREE.PointLight( 0xefffef, 500 );
				light.position.z = 10;
				light.position.y = - 10;
				light.position.x = - 10;
				scene.add( light );

				const light2 = new THREE.PointLight( 0xffefef, 500 );
				light2.position.z = 10;
				light2.position.x = - 10;
				light2.position.y = 10;
				scene.add( light2 );

				const light3 = new THREE.PointLight( 0xefefff, 500 );
				light3.position.z = 10;
				light3.position.x = 10;
				light3.position.y = - 10;
				scene.add( light3 );

				const light4 = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( light4 );

				const geometry = new THREE.SphereGeometry( 3, 48, 24 );
				const material = new THREE.MeshStandardMaterial();

				mesh = new THREE.InstancedMesh( geometry, material, 120 );

				const dummy = new THREE.Mesh();
				const color = new THREE.Color();

				for ( let i = 0; i < mesh.count; i ++ ) {

					dummy.position.x = Math.random() * 4 - 2;
					dummy.position.y = Math.random() * 4 - 2;
					dummy.position.z = Math.random() * 4 - 2;
					dummy.rotation.x = Math.random();
					dummy.rotation.y = Math.random();
					dummy.rotation.z = Math.random();
					dummy.scale.setScalar( Math.random() * 0.2 + 0.05 );

					dummy.updateMatrix();

					color.setHSL( Math.random(), 1.0, 0.3 );

					mesh.setMatrixAt( i, dummy.matrix );
					mesh.setColorAt( i, color );

				}

				scene.add( mesh );

				// postprocessing

				postProcessing = new THREE.PostProcessing( renderer );

				ssaaRenderPass = ssaaPass( scene, camera );
				const scenePassColor = ssaaRenderPass.getTextureNode();

				postProcessing.outputNode = scenePassColor;

				window.addEventListener( 'resize', onWindowResize );

				// GUI

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( params, 'sampleLevel', {
					'Level 0: 1 Sample': 0,
					'Level 1: 2 Samples': 1,
					'Level 2: 4 Samples': 2,
					'Level 3: 8 Samples': 3,
					'Level 4: 16 Samples': 4,
					'Level 5: 32 Samples': 5
				} );
				gui.add( params, 'clearColor', [ 'black', 'white', 'blue', 'green', 'red' ] );
				gui.add( params, 'clearAlpha', 0, 1 );
				gui.add( params, 'viewOffsetX', - 100, 100 );
				gui.add( params, 'autoRotate' );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.setViewOffset( width, height, params.viewOffsetX, 0, width, height );
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				timer.update();

				if ( params.autoRotate ) {

					const delta = timer.getDelta();

					mesh.rotation.x += delta * 0.25;
					mesh.rotation.y += delta * 0.5;

				}

				let newColor = ssaaRenderPass.clearColor;

				switch ( params.clearColor ) {

					case 'blue': newColor = 0x0000ff; break;
					case 'red': newColor = 0xff0000; break;
					case 'green': newColor = 0x00ff00; break;
					case 'white': newColor = 0xffffff; break;
					case 'black': newColor = 0x000000; break;

				}

				ssaaRenderPass.clearColor.set( newColor );
				ssaaRenderPass.clearAlpha = params.clearAlpha;

				ssaaRenderPass.sampleLevel = params.sampleLevel;

				camera.view.offsetX = params.viewOffsetX;

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_ssgi.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - SSGI</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>SSGI</span>
			</div>

			<small>Real-time indirect illumination and ambient occlusion using screen-space information.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, mrt, output, normalView, diffuseColor, velocity, add, vec3, vec4, directionToColor, colorToDirection, sample } from 'three/tsl';
			import { ssgi } from 'three/addons/tsl/display/SSGINode.js';
			import { traa } from 'three/addons/tsl/display/TRAANode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, postProcessing, controls;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 10, 30 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xaaaaaa );

				renderer = new THREE.WebGPURenderer();
				//renderer.setPixelRatio( window.devicePixelRatio ); // probably too costly for most hardware
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 7, 0 );
				controls.enablePan = true;
				controls.minDistance = 1;
				controls.maxDistance = 100;
				controls.update();

				//

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output: output,
					diffuseColor: diffuseColor,
					normal: directionToColor( normalView ),
					velocity: velocity
				} ) );

				const scenePassColor = scenePass.getTextureNode( 'output' );
				const scenePassDiffuse = scenePass.getTextureNode( 'diffuseColor' ).toInspector( 'Diffuse Color' );
				const scenePassDepth = scenePass.getTextureNode( 'depth' ).toInspector( 'Depth', () => {

					return scenePass.getLinearDepthNode();

				} );

				const scenePassNormal = scenePass.getTextureNode( 'normal' ).toInspector( 'Normal' );
				const scenePassVelocity = scenePass.getTextureNode( 'velocity' ).toInspector( 'Velocity' );

				// bandwidth optimization

				const diffuseTexture = scenePass.getTexture( 'diffuseColor' );
				diffuseTexture.type = THREE.UnsignedByteType;

				const normalTexture = scenePass.getTexture( 'normal' );
				normalTexture.type = THREE.UnsignedByteType;

				const sceneNormal = sample( ( uv ) => {

					return colorToDirection( scenePassNormal.sample( uv ) );

				} );

				// gi

				const giPass = ssgi( scenePassColor, scenePassDepth, sceneNormal, camera );
				giPass.sliceCount.value = 2;
				giPass.stepCount.value = 8;

				// composite

				const gi = giPass.rgb.toInspector( 'SSGI' );
				const ao = giPass.a.toInspector( 'AO' );

				const compositePass = vec4( add( scenePassColor.rgb.mul( ao ), ( scenePassDiffuse.rgb.mul( gi ) ) ), scenePassColor.a );
				compositePass.name = 'Composite';

				// traa

				const traaPass = traa( compositePass, scenePassDepth, scenePassVelocity, camera );
				postProcessing.outputNode = traaPass;

				// Cornell Box inspired scene

				// Walls
				const wallGeometry = new THREE.PlaneGeometry( 1, 1 );

				// Left wall - red
				const redWallMaterial = new THREE.MeshPhysicalMaterial( { color: '#ff0000' } );
				const leftWall = new THREE.Mesh( wallGeometry, redWallMaterial );
				leftWall.scale.set( 20, 15, 1 );
				leftWall.rotation.y = Math.PI * 0.5;
				leftWall.position.set( - 10, 7.5, 0 );
				leftWall.receiveShadow = true;
				scene.add( leftWall );

				// Right wall - green
				const greenWallMaterial = new THREE.MeshPhysicalMaterial( { color: '#00ff00' } );
				const rightWall = new THREE.Mesh( wallGeometry, greenWallMaterial );
				rightWall.scale.set( 20, 15, 1 );
				rightWall.rotation.y = Math.PI * - 0.5;
				rightWall.position.set( 10, 7.5, 0 );
				rightWall.receiveShadow = true;
				scene.add( rightWall );

				// White walls and boxes
				const whiteMaterial = new THREE.MeshPhysicalMaterial( { color: '#fff' } );

				// Floor
				const floor = new THREE.Mesh( wallGeometry, whiteMaterial );
				floor.scale.set( 20, 20, 1 );
				floor.rotation.x = Math.PI * - .5;
				floor.receiveShadow = true;
				scene.add( floor );

				// Back wall
				const backWall = new THREE.Mesh( wallGeometry, whiteMaterial );
				backWall.scale.set( 15, 20, 1 );
				backWall.rotation.z = Math.PI * - 0.5;
				backWall.position.set( 0, 7.5, - 10 );
				backWall.receiveShadow = true;
				scene.add( backWall );

				// Ceiling
				const ceiling = new THREE.Mesh( wallGeometry, whiteMaterial );
				ceiling.scale.set( 20, 20, 1 );
				ceiling.rotation.x = Math.PI * 0.5;
				ceiling.position.set( 0, 15, 0 );
				ceiling.receiveShadow = true;
				scene.add( ceiling );

				// Boxes
				const tallBoxGeometry = new THREE.BoxGeometry( 5, 7, 5 );
				const tallBox = new THREE.Mesh( tallBoxGeometry, whiteMaterial );
				tallBox.rotation.y = Math.PI * 0.25;
				tallBox.position.set( - 3, 3.5, - 2 );
				tallBox.castShadow = true;
				tallBox.receiveShadow = true;
				scene.add( tallBox );

				const shortBoxGeometry = new THREE.BoxGeometry( 4, 4, 4 );
				const shortBox = new THREE.Mesh( shortBoxGeometry, whiteMaterial );
				shortBox.rotation.y = Math.PI * - 0.1;
				shortBox.position.set( 4, 2, 4 );
				shortBox.castShadow = true;
				shortBox.receiveShadow = true;
				scene.add( shortBox );

				// Light source geometry
				const lightSourceGeometry = new THREE.CylinderGeometry( 2.5, 2.5, 1, 64 );
				const lightSourceMaterial = new THREE.MeshBasicMaterial();
				const lightSource = new THREE.Mesh( lightSourceGeometry, lightSourceMaterial );
				lightSource.position.y = 15;
				scene.add( lightSource );

				// Point light
				const pointLight = new THREE.PointLight( '#ffffff', 100 );
				pointLight.position.set( 0, 13, 0 );
				pointLight.distance = 100;
				pointLight.castShadow = true;
				pointLight.shadow.mapSize.width = 1024;
				pointLight.shadow.mapSize.height = 1024;
				pointLight.shadow.bias = - 0.0025;
				scene.add( pointLight );

				// Ambient light
				const ambientLight = new THREE.AmbientLight( '#0c0c0c' );
				scene.add( ambientLight );

				window.addEventListener( 'resize', onWindowResize );

				//

				const params = {
					output: 0
				};

				const types = { Combined: 0, Direct: 3, AO: 1, GI: 2 };

				const gui = renderer.inspector.createParameters( 'SSGI settings' );
				gui.add( params, 'output', types ).onChange( updatePostprocessing );
				gui.add( giPass.sliceCount, 'value', 1, 4, 1 ).name( 'slice count' );
				gui.add( giPass.stepCount, 'value', 1, 32, 1 ).name( 'step count' );
				gui.add( giPass.radius, 'value', 1, 25 ).name( 'radius' );
				gui.add( giPass.expFactor, 'value', 1, 3 ).name( 'exp factor' );
				gui.add( giPass.thickness, 'value', 0.01, 10 ).name( 'thickness' );
				gui.add( giPass.backfaceLighting, 'value', 0, 1 ).name( 'backface lighting' );
				gui.add( giPass.aoIntensity, 'value', 0, 4 ).name( 'AO intensity' );
				gui.add( giPass.giIntensity, 'value', 0, 100 ).name( 'GI intensity' );
				gui.add( giPass.useLinearThickness, 'value' ).name( 'use linear thickness' );
				gui.add( giPass.useScreenSpaceSampling, 'value' ).name( 'screen-space sampling' );
				gui.add( giPass, 'useTemporalFiltering' ).name( 'temporal filtering' ).onChange( updatePostprocessing );

				function updatePostprocessing( value ) {

					if ( value === 1 ) {

						postProcessing.outputNode = vec4( vec3( ao ), 1 );

					} else if ( value === 2 ) {

						postProcessing.outputNode = vec4( gi, 1 );

					} else if ( value === 3 ) {

						postProcessing.outputNode = scenePassColor;

					} else {

						postProcessing.outputNode = giPass.useTemporalFiltering ? traaPass : compositePass;

					}

					postProcessing.needsUpdate = true;


				}


			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_ssr.html
================================================
<!DOCTYPE html>
<html lang="en">

<head>

	<head>
		<title>three.js webgpu - postprocessing - Screen Space Reflections (SSR)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>SSR</span>
			</div>

			<small>
				Screen Space Reflections.<br />
				<a href="https://skfb.ly/6tqYD" target="_blank" rel="noopener">Steampunk Camera</a> by
				<a href="https://sketchfab.com/lumoize" target="_blank" rel="noopener">dylanheyes</a> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">Creative Commons Attribution</a>.
			</small>
		</div>

	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.webgpu.js",
				"three/webgpu": "../build/three.webgpu.js",
				"three/tsl": "../build/three.tsl.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

	<script type="module">

		import * as THREE from 'three/webgpu';
		import { pass, mrt, output, normalView, metalness, roughness, blendColor, screenUV, color, sample, directionToColor, colorToDirection, vec2 } from 'three/tsl';
		import { ssr } from 'three/addons/tsl/display/SSRNode.js';
		import { smaa } from 'three/addons/tsl/display/SMAANode.js';

		import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
		import { Inspector } from 'three/addons/inspector/Inspector.js';

		const params = {
			quality: 0.5,
			blurQuality: 2,
			maxDistance: 0.5,
			opacity: 1,
			thickness: 0.015,
			roughness: 1,
			enabled: true
		};

		let camera, scene, model, renderer, postProcessing, ssrPass;
		let controls;

		init();

		async function init() {

			camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 50 );
			camera.position.set( 3, 2, 3 );

			scene = new THREE.Scene();
			scene.backgroundNode = screenUV.distance( .5 ).remap( 0, 0.5 ).mix( color( 0x888877 ), color( 0x776666 ) );

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath( 'jsm/libs/draco/' );
			dracoLoader.setDecoderConfig( { type: 'js' } );

			const loader = new GLTFLoader();
			loader.setDRACOLoader( dracoLoader );
			loader.load( 'models/gltf/steampunk_camera.glb', function ( gltf ) {

				model = gltf.scene;

				model.traverse( function ( object ) {

					if ( object.material ) {

						if ( object.material.name === 'Lense_Casing' ) {

							object.material.transparent = true;

						}

						// Avoid overdrawing
						object.material.side = THREE.FrontSide;

					}

				} );

				model.position.y = 0.1;
				scene.add( model );

			} );

			//

			renderer = new THREE.WebGPURenderer();
			// renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.inspector = new Inspector();
			document.body.appendChild( renderer.domElement );

			await renderer.init();

			const environment = new RoomEnvironment();
			const pmremGenerator = new THREE.PMREMGenerator( renderer );

			scene.environment = pmremGenerator.fromScene( environment ).texture;
			scene.environmentIntensity = 1.25;
			pmremGenerator.dispose();

			//

			postProcessing = new THREE.PostProcessing( renderer );

			const scenePass = pass( scene, camera );
			scenePass.setMRT( mrt( {
				output: output,
				normal: directionToColor( normalView ),
				metalrough: vec2( metalness, roughness ) // pack metalness and roughness into a single attachment
			} ) );

			const scenePassColor = scenePass.getTextureNode( 'output' ).toInspector( 'Color' );
			const scenePassNormal = scenePass.getTextureNode( 'normal' ).toInspector( 'Normal' );
			const scenePassDepth = scenePass.getTextureNode( 'depth' ).toInspector( 'Depth', () => {

				return scenePass.getLinearDepthNode();

			} );
			const scenePassMetalRough = scenePass.getTextureNode( 'metalrough' ).toInspector( 'Metalness-Roughness' );

			// optional: optimize bandwidth by reducing the texture precision for normals and metal/roughness

			const normalTexture = scenePass.getTexture( 'normal' );
			normalTexture.type = THREE.UnsignedByteType;

			const metalRoughTexture = scenePass.getTexture( 'metalrough' );
			metalRoughTexture.type = THREE.UnsignedByteType;

			const sceneNormal = sample( ( uv ) => {

				return colorToDirection( scenePassNormal.sample( uv ) );

			} );

			//

			ssrPass = ssr( scenePassColor, scenePassDepth, sceneNormal, scenePassMetalRough.r, scenePassMetalRough.g ).toInspector( 'SSR' );

			// blend SSR over beauty

			const outputNode = smaa( blendColor( scenePassColor, ssrPass ) );

			postProcessing.outputNode = outputNode;

			//

			controls = new OrbitControls( camera, renderer.domElement );
			controls.enableDamping = true;
			controls.update();

			window.addEventListener( 'resize', onWindowResize );

			// GUI

			const gui = renderer.inspector.createParameters( 'Settings' );
			const ssrFolder = gui.addFolder( 'SSR' );
			ssrFolder.add( params, 'quality', 0, 1 ).onChange( updateParameters );
			ssrFolder.add( params, 'blurQuality', 1, 3, 1 ).onChange( updateParameters );
			ssrFolder.add( params, 'maxDistance', 0, 1 ).onChange( updateParameters );
			ssrFolder.add( params, 'opacity', 0, 1 ).onChange( updateParameters );
			ssrFolder.add( params, 'thickness', 0, 0.05 ).onChange( updateParameters );
			ssrFolder.add( params, 'enabled' ).onChange( () => {

				if ( params.enabled === true ) {

					postProcessing.outputNode = outputNode;

				} else {

					postProcessing.outputNode = scenePass;

				}

				postProcessing.needsUpdate = true;

			} );
			const modelFolder = gui.addFolder( 'Model' );
			modelFolder.add( params, 'roughness', 0, 1 ).onChange( ( value ) => {

				model.traverse( function ( object ) {

					if ( object.material ) {

						object.material.roughness = value;

					}

				} );

			} );

			updateParameters();

		}

		function updateParameters() {

			ssrPass.quality.value = params.quality;
			ssrPass.blurQuality.value = params.blurQuality;
			ssrPass.maxDistance.value = params.maxDistance;
			ssrPass.opacity.value = params.opacity;
			ssrPass.thickness.value = params.thickness;

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			controls.update();

			postProcessing.render();
		
		}

	</script>
</body>

</html>


================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_sss.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - SSS</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>SSS</span>
			</div>

			<small>
				Screen-Space Shadows (SSS) combined with Shadow Maps.<br/>
				<a href="https://skfb.ly/pAQvU" target="_blank" rel="noopener">Nemetona_NatureBeauty</a> by
				<a href="https://sketchfab.com/JOJObrush" target="_blank" rel="noopener">JOJObrush</a> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">Creative Commons Attribution</a>.<br />
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, vec3, vec4, mrt, output, velocity } from 'three/tsl';
			import { sss } from 'three/addons/tsl/display/SSSNode.js';
			import { traa } from 'three/addons/tsl/display/TRAANode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, postProcessing, controls;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 1, 2.5, - 3.5 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0 );
				scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

				// lights

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 2 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.position.set( - 3, 10, - 10 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 4;
				dirLight.shadow.camera.bottom = - 4;
				dirLight.shadow.camera.left = - 4;
				dirLight.shadow.camera.right = 4;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 40;
				dirLight.shadow.bias = - 0.001;
				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;
				scene.add( dirLight );

				// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

				// ground

				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				//

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

				const loader = new GLTFLoader();
				loader.setDRACOLoader( dracoLoader );
				loader.load( 'models/gltf/nemetona.glb', function ( gltf ) {

					const model = gltf.scene;
					model.rotation.y = Math.PI;
					model.scale.setScalar( 10 );
					model.position.y = 0.45;
			
					scene.add( model );

					model.traverse( function ( object ) {

						if ( object.isMesh ) {
			
							object.castShadow = true;
							object.receiveShadow = true;
							object.material.aoMap = null; // remove AO to better see the effect of shadows

						}

					} );

				} );

				//

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output: output,
					velocity: velocity
				} ) );

				const scenePassColor = scenePass.getTextureNode( 'output' );
				const scenePassVelocity = scenePass.getTextureNode( 'velocity' );
				const scenePassDepth = scenePass.getTextureNode( 'depth' );

				// sss

				const sssPass = sss( scenePassDepth, camera, dirLight );
				sssPass.shadowIntensity.value = 0.3;
				sssPass.maxDistance.value = 0.2;
				sssPass.useTemporalFiltering = true;

				// composite

				const compositePass = vec4( scenePassColor.rgb.mul( sssPass.r ), scenePassColor.a );
				compositePass.name = 'Composite';
			
				// traa

				const traaPass = traa( compositePass, scenePassDepth, scenePassVelocity, camera );
				postProcessing.outputNode = traaPass;

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 20;
				controls.target.set( 0, 2, 0 );
				controls.enableDamping = true;
				controls.update();

				//

				const params = {
					output: 0
				};

				const types = { 'Scene with Shadow Maps + SSS': 0, 'Scene with Shadow Maps': 1, 'SSS': 2, };

				const gui = renderer.inspector.createParameters( 'SSS settings' );
				gui.add( params, 'output', types ).onChange( updatePostprocessing );
				gui.add( sssPass.shadowIntensity, 'value', 0, 1 ).name( 'shadow intensity' );
				gui.add( sssPass.maxDistance, 'value', 0.01, 1 ).name( 'max ray distance' );
				gui.add( sssPass.quality, 'value', 0, 1 ).name( 'quality' );
				gui.add( sssPass.thickness, 'value', 0.01, 0.1 ).name( 'thickness' );
				gui.add( sssPass, 'useTemporalFiltering' ).name( 'temporal filtering' ).onChange( updatePostprocessing );

				function updatePostprocessing() {

					if ( params.output === 1 ) {

						postProcessing.outputNode = scenePassColor;

					} else if ( params.output === 2 ) {

						postProcessing.outputNode = vec4( vec3( sssPass.r ), 1 );

					} else {

						postProcessing.outputNode = sssPass.useTemporalFiltering ? traaPass : compositePass;

					}

					postProcessing.needsUpdate = true;


				}

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>


================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_traa.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - postprocessing traa</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>TRAA</span>
			</div>

			<small>Temporal Reprojection Anti-Aliasing.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mrt, output, pass, velocity } from 'three/tsl';
			import { traa } from 'three/addons/tsl/display/TRAANode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, postProcessing;
			let index = 0;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.z = 2.5;

				scene = new THREE.Scene();

				const geometry = new THREE.BoxGeometry();
				const material1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );

				const mesh1 = new THREE.Mesh( geometry, material1 );
				mesh1.position.x = - 1;
				scene.add( mesh1 );

				const texture = new THREE.TextureLoader().load( 'textures/brick_diffuse.jpg' );
				texture.minFilter = THREE.NearestFilter;
				texture.magFilter = THREE.NearestFilter;
				texture.generateMipmaps = false;
				texture.colorSpace = THREE.SRGBColorSpace;

				const material2 = new THREE.MeshBasicMaterial( { map: texture } );

				const mesh2 = new THREE.Mesh( geometry, material2 );
				mesh2.position.x = 1;
				scene.add( mesh2 );

				// postprocessing

				postProcessing = new THREE.PostProcessing( renderer );
				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output: output,
					velocity: velocity
				} ) );

				const scenePassColor = scenePass.getTextureNode( 'output' ).toInspector( 'Color' );
				const scenePassDepth = scenePass.getTextureNode( 'depth' ).toInspector( 'Depth', () => {

					return scenePass.getLinearDepthNode();

				} );
				const scenePassVelocity = scenePass.getTextureNode( 'velocity' ).toInspector( 'Velocity' );

				const traaNode = traa( scenePassColor, scenePassDepth, scenePassVelocity, camera );
			
				postProcessing.outputNode = traaNode;

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function animate() {

				index ++;

				if ( Math.round( index / 200 ) % 2 === 0 ) {

					for ( let i = 0; i < scene.children.length; i ++ ) {

						const child = scene.children[ i ];

						child.rotation.x += 0.005;
						child.rotation.y += 0.01;

					}

				}

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_postprocessing_transition.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - scenes transition</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Scene Transitions</span>
			</div>

			<small>Original implementation by <a href="https://twitter.com/fernandojsg" target="_blank">fernandojsg</a> - <a href="https://github.com/kile/three.js-demos" target="_blank">github</a>.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import TWEEN from 'three/addons/libs/tween.module.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { uniform, pass } from 'three/tsl';
			import { transition } from 'three/addons/tsl/display/TransitionNode.js';

			let renderer, postProcessing, transitionController, transitionPass;

			const textures = [];
			const clock = new THREE.Clock();

			const effectController = {
				animateScene: true,
				animateTransition: true,
				transition: 0,
				_transition: uniform( 0 ),
				useTexture: true,
				_useTexture: uniform( 1 ),
				texture: 5,
				cycle: true,
				threshold: uniform( 0.1 ),
			};

			function generateInstancedMesh( geometry, material, count ) {

				const mesh = new THREE.InstancedMesh( geometry, material, count );

				const dummy = new THREE.Object3D();
				const color = new THREE.Color();

				for ( let i = 0; i < count; i ++ ) {

					dummy.position.x = Math.random() * 100 - 50;
					dummy.position.y = Math.random() * 60 - 30;
					dummy.position.z = Math.random() * 80 - 40;

					dummy.rotation.x = Math.random() * 2 * Math.PI;
					dummy.rotation.y = Math.random() * 2 * Math.PI;
					dummy.rotation.z = Math.random() * 2 * Math.PI;

					dummy.scale.x = Math.random() * 2 + 1;

					if ( geometry.type === 'BoxGeometry' ) {

						dummy.scale.y = Math.random() * 2 + 1;
						dummy.scale.z = Math.random() * 2 + 1;

					} else {

						dummy.scale.y = dummy.scale.x;
						dummy.scale.z = dummy.scale.x;

					}

					dummy.updateMatrix();

					mesh.setMatrixAt( i, dummy.matrix );
					mesh.setColorAt( i, color.setScalar( 0.1 + 0.9 * Math.random() ) );

				}

				return mesh;

			}

			function FXScene( geometry, rotationSpeed, backgroundColor ) {

				const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.z = 20;

				// Setup scene
				const scene = new THREE.Scene();
				scene.background = new THREE.Color( backgroundColor );
				scene.add( new THREE.AmbientLight( 0xaaaaaa, 3 ) );

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 0, 1, 4 );
				scene.add( light );

				this.rotationSpeed = rotationSpeed;

				const color = geometry.type === 'BoxGeometry' ? 0x0000ff : 0xff0000;
				const material = new THREE.MeshPhongNodeMaterial( { color: color, flatShading: true } );
				const mesh = generateInstancedMesh( geometry, material, 500 );
				scene.add( mesh );

				this.scene = scene;
				this.camera = camera;
				this.mesh = mesh;

				this.update = function ( delta ) {

					if ( effectController.animateScene ) {

						mesh.rotation.x += this.rotationSpeed.x * delta;
						mesh.rotation.y += this.rotationSpeed.y * delta;
						mesh.rotation.z += this.rotationSpeed.z * delta;

					}

				};

				this.resize = function () {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

				};

			}

			const fxSceneA = new FXScene( new THREE.BoxGeometry( 2, 2, 2 ), new THREE.Vector3( 0, - 0.4, 0 ), 0xffffff );
			const fxSceneB = new FXScene( new THREE.IcosahedronGeometry( 1, 1 ), new THREE.Vector3( 0, 0.2, 0.1 ), 0x000000 );

			function init() {

				// Initialize textures

				const loader = new THREE.TextureLoader();

				for ( let i = 0; i < 6; i ++ ) {

					textures[ i ] = loader.load( 'textures/transition/transition' + ( i + 1 ) + '.png' );

				}

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.inspector = new Inspector();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePassA = pass( fxSceneA.scene, fxSceneA.camera );
				const scenePassB = pass( fxSceneB.scene, fxSceneB.camera );

				transitionPass = transition( scenePassA, scenePassB, new THREE.TextureNode( textures[ effectController.texture ] ), effectController._transition, effectController.threshold, effectController._useTexture );

				postProcessing.outputNode = transitionPass;

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( effectController, 'animateScene' ).name( 'Animate Scene' );
				gui.add( effectController, 'animateTransition' ).name( 'Animate Transition' );
				transitionController = gui.add( effectController, 'transition', 0, 1, 0.01 ).name( 'transition' ).onChange( () => {

					effectController._transition.value = effectController.transition;

				} );
				gui.add( effectController, 'useTexture' ).onChange( () => {

					const value = effectController.useTexture ? 1 : 0;
					effectController._useTexture.value = value;

				} );
				gui.add( effectController, 'texture', { Perlin: 0, Squares: 1, Cells: 2, Distort: 3, Gradient: 4, Radial: 5 } );
				gui.add( effectController, 'cycle' );
				gui.add( effectController.threshold, 'value', 0, 1, 0.01 ).name( 'threshold' );

			}

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {

				fxSceneA.resize();
				fxSceneB.resize();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			new TWEEN.Tween( effectController )
				.to( { transition: 1 }, 1500 )
				.onUpdate( function ( ) {

					transitionController.setValue( effectController.transition );

					// Change the current alpha texture after each transition
					if ( effectController.cycle ) {

						if ( effectController.transition == 0 || effectController.transition == 1 ) {

							effectController.texture = ( effectController.texture + 1 ) % textures.length;

						}

					}

				} )
				.repeat( Infinity )
				.delay( 2000 )
				.yoyo( true )
				.start();

			function animate() {

				if ( effectController.animateTransition ) TWEEN.update();

				if ( textures[ effectController.texture ] ) {

					const mixTexture = textures[ effectController.texture ];
					transitionPass.mixTextureNode.value = mixTexture;

				}

				const delta = clock.getDelta();
				fxSceneA.update( delta );
				fxSceneB.update( delta );

				render();

			}

			function render() {

				// Prevent render both scenes when it's not necessary
				if ( effectController.transition === 0 ) {

					renderer.render( fxSceneB.scene, fxSceneB.camera );

				} else if ( effectController.transition === 1 ) {

					renderer.render( fxSceneA.scene, fxSceneA.camera );

				} else {

					postProcessing.render();

				}

			}

			init();

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_procedural_texture.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - procedural texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Procedural Texture</span>
			</div>

			<small>
				GPU procedural texture generation.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { checker, uv, uniform, convertToTexture } from 'three/tsl';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			init();

			function init() {

				const aspect = window.innerWidth / window.innerHeight;
				camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				scene = new THREE.Scene();

				// procedural to texture

				const uvScale = uniform( 4 );
				const blurAmount = uniform( .5 );

				const procedural = checker( uv().mul( uvScale ) );
				const proceduralToTexture = convertToTexture( procedural, 512, 512 ); // ( node, width, height )

				const colorNode = gaussianBlur( proceduralToTexture, blurAmount, 20 );

				// extra

				//proceduralToTexture.autoUpdate = false; // update just once
				//proceduralToTexture.textureNeedsUpdate = true; // manually update

				// scene

				const material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = colorNode;

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = renderer.inspector.createParameters( 'Procedural Texture' );
				gui.add( uvScale, 'value', 1, 10 ).name( 'uv scale ( before rtt )' );
				gui.add( blurAmount, 'value', 0, 2 ).name( 'blur amount ( after rtt )' );
				gui.add( proceduralToTexture, 'autoUpdate' ).name( 'auto update' );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				const aspect = window.innerWidth / window.innerHeight;

				const frustumHeight = camera.top - camera.bottom;

				camera.left = - frustumHeight * aspect / 2;
				camera.right = frustumHeight * aspect / 2;

				camera.updateProjectionMatrix();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_reflection.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - reflection</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Reflection + Recursive Tree Cubes</span>
			</div>

			<small>
				Based on <a href="https://oosmoxiecode.com/archive/js_webgl/recursive_tree_cubes/" target="_blank" rel="noopener">Recursive Tree Cubes</a>
				by <a href="https://github.com/oosmoxiecode" target="_blank" rel="noopener">oosmoxiecode</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { abs, blendOverlay, color, float, Fn, instancedBufferAttribute, max, normalWorldGeometry, pass, positionGeometry, positionLocal, pow2, reflector, screenUV, sin, sub, texture, time, uniform, uv, vec2, vec3 } from 'three/tsl';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import TWEEN from 'three/addons/libs/tween.module.js';

			let camera, scene, renderer;
			let postProcessing;
			let controls;

			// below uniforms will be animated via TWEEN.js

			const uniformEffector1 = uniform( - 0.2 );
			const uniformEffector2 = uniform( - 0.2 );

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );
				camera.position.set( 4, 2, 4 );

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x4195a4, 1, 20 );
				scene.backgroundNode = normalWorldGeometry.y.mix( color( 0x4195a4 ), color( 0x0066ff ) );
				camera.lookAt( 0, 1, 0 );

				const sunLight = new THREE.DirectionalLight( 0xFFE499, 2 );
				sunLight.position.set( 7, 5, 7 );
				sunLight.castShadow = true;
				sunLight.shadow.camera.zoom = 1.5;
				sunLight.shadow.mapSize.set( 1024, 1024 );
				sunLight.shadow.bias = - 0.0001;
				scene.add( sunLight );

				const backLight = new THREE.DirectionalLight( 0x0487e2, 0.5 );
				backLight.position.set( 7, - 5, 7 );
				scene.add( backLight );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const floorColor = await textureLoader.loadAsync( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );
				floorColor.wrapS = THREE.RepeatWrapping;
				floorColor.wrapT = THREE.RepeatWrapping;
				floorColor.colorSpace = THREE.SRGBColorSpace;
				floorColor.repeat.set( 15, 15 );

				const floorNormal = await textureLoader.loadAsync( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );
				floorNormal.wrapS = THREE.RepeatWrapping;
				floorNormal.wrapT = THREE.RepeatWrapping;
				floorNormal.repeat.set( 15, 15 );

				// tree

				const treeMesh = createTreeMesh();
				treeMesh.castShadow = true;
				treeMesh.receiveShadow = true;
				scene.add( treeMesh );

				// floor

				const floorUV = uv().mul( 15 );
				const floorNormalOffset = texture( floorNormal, floorUV ).xy.mul( 2 ).sub( 1 ).mul( .02 );

				const reflection = reflector( { resolutionScale: 0.2 } );
				reflection.target.rotateX( - Math.PI / 2 );
				reflection.uvNode = reflection.uvNode.add( floorNormalOffset );
				scene.add( reflection.target );

				const floorMaterial = new THREE.MeshPhongNodeMaterial();
				floorMaterial.colorNode = texture( floorColor, floorUV );
				floorMaterial.emissiveNode = reflection.mul( 0.25 );
				floorMaterial.normalMap = floorNormal;
				floorMaterial.normalScale.set( 0.2, - 0.2 );

				const floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );
				floor.receiveShadow = true;
				scene.add( floor );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI / 2;
				controls.enableDamping = true;
				controls.autoRotate = true;
				controls.autoRotateSpeed = 1;
				controls.target.set( 0, 1, 0 );
				controls.update();

				// post-processing

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode();
				const scenePassDepth = scenePass.getLinearDepthNode().remapClamp( .3, .7 );

				const scenePassColorBlurred = gaussianBlur( scenePassColor );
				scenePassColorBlurred.directionNode = scenePassDepth;

				const vignette = screenUV.distance( .5 ).mul( 1.25 ).clamp().oneMinus().sub( 0.2 );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = blendOverlay( scenePassColorBlurred, vignette );

				// tweens

				new TWEEN.Tween( uniformEffector1 )
					.to( { value: 1.2 }, 3000 )
					.delay( 800 )
					.repeat( Infinity )
					.easing( TWEEN.Easing.Sinusoidal.InOut )
					.start();

				new TWEEN.Tween( uniformEffector2 )
					.to( { value: 1.2 }, 3000 )
					.repeat( Infinity )
					.easing( TWEEN.Easing.Sinusoidal.InOut )
					.start();

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				TWEEN.update();

				postProcessing.render();

			}

			function random() {

				return ( Math.random() - 0.5 ) * 2.0;

			}

			function createTreeMesh() {

				const maxSteps = 5;
				const lengthMult = 0.8;

				const positions = [];
				const normals = [];
				const colors = [];
				const data = []; // will save seed, size and time

				let instanceCount = 0;

				const newPosition = new THREE.Vector3();
				const position = new THREE.Vector3();
				const normal = new THREE.Vector3();
				const color = new THREE.Color();

				function createTreePart( angle, x, y, z, length, count ) {

					if ( Math.random() > ( maxSteps / count ) * 0.25 ) return;

					if ( count < maxSteps ) {

						const newLength = length * lengthMult;
						const newX = x + Math.cos( angle ) * length;
						const newY = y + Math.sin( angle ) * length;
						const countSq = Math.min( 3.2, count * count );
						const newZ = z + ( Math.random() * countSq - countSq / 2 ) * length;

						let size = 30 - ( count * 8 );
						if ( size > 25 ) size = 25;
						if ( size < 10 ) size = 10;

						size = size / 100;

						const subSteps = 50;

						// below loop generates the instanced data for a tree part

						for ( let i = 0; i < subSteps; i ++ ) {

							instanceCount ++;

							const percent = i / subSteps;
							const extra = 1 / maxSteps;

							// position

							newPosition.set( x, y, z ).lerp( new THREE.Vector3( newX, newY, newZ ), percent );
							position.copy( newPosition );

							position.x += random() * size * 3;
							position.y += random() * size * 3;
							position.z += random() * size * 3;

							positions.push( position.x, position.y, position.z );

							const scale = Math.random() + 5;

							// normal

							normal.copy( position ).sub( newPosition ).normalize();
							normals.push( normal.x, normal.y, normal.z );

							// color

							color.setHSL( ( count / maxSteps ) * 0.5 + Math.random() * 0.05, 0.75, 0.6 + Math.random() * 0.1 );
							colors.push( color.r, color.g, color.b );

							// to save vertex buffers, we store the size, time and seed in a single attribute

							const instanceSize = size * scale;
							const instanceTime = ( count / maxSteps ) + percent * extra;
							const instanceSeed = Math.random();

							data.push( instanceSize, instanceTime, instanceSeed );

						}

						createTreePart( angle + random(), newX, newY, newZ, newLength + random(), count + 1 );
						createTreePart( angle + random(), newX, newY, newZ, newLength + random(), count + 1 );
						createTreePart( angle + random(), newX, newY, newZ, newLength + random(), count + 1 );
						createTreePart( angle + random(), newX, newY, newZ, newLength + random(), count + 1 );
						createTreePart( angle + random(), newX, newY, newZ, newLength + random(), count + 1 );
						createTreePart( angle + random(), newX, newY, newZ, newLength + random(), count + 1 );

					}

				}

				const angle = Math.PI * 0.5;

				// the tree is represented as a collection of instances boxes generated with below recursive function

				createTreePart( angle, 0, 0, 0, 16, 0 );

				const geometry = new THREE.BoxGeometry();
				const material = new THREE.MeshStandardNodeMaterial();
				const mesh = new THREE.Mesh( geometry, material );
				mesh.scale.setScalar( 0.05 );
				mesh.count = instanceCount;
				mesh.frustumCulled = false;

				// instanced data

				const attributePosition = new THREE.InstancedBufferAttribute( new Float32Array( positions ), 3 );
				const attributeNormal = new THREE.InstancedBufferAttribute( new Float32Array( normals ), 3 );
				const attributeColor = new THREE.InstancedBufferAttribute( new Float32Array( colors ), 3 );
				const attributeData = new THREE.InstancedBufferAttribute( new Float32Array( data ), 3 );

				// TSL

				const instancePosition = instancedBufferAttribute( attributePosition );
				const instanceNormal = instancedBufferAttribute( attributeNormal );
				const instanceColor = instancedBufferAttribute( attributeColor );
				const instanceData = instancedBufferAttribute( attributeData );

				material.positionNode = Fn( () => {

					const instanceSize = instanceData.x;
					const instanceTime = instanceData.y;
					const instanceSeed = instanceData.z;

					// effectors (these are responsible for the blob-like scale effects)

					const dif1 = abs( instanceTime.sub( uniformEffector1 ) ).toConst();
					let effect = dif1.lessThanEqual( 0.15 ).select( sub( 0.15, dif1 ).mul( sub( 1.7, instanceTime ).mul( 10 ) ), float( 0 ) );

					const dif2 = abs( instanceTime.sub( uniformEffector2 ) ).toConst();
					effect = dif2.lessThanEqual( 0.15 ).select( sub( 0.15, dif2 ).mul( sub( 1.7, instanceTime ).mul( 10 ) ), effect );

					// accumulate different vertex animations

					let animated = positionLocal.add( instancePosition ).toVar();
					const direction = positionGeometry.normalize().toConst();

					animated = animated.add( direction.mul( effect.add( instanceSize ) ) );
					animated = animated.sub( direction.mul( effect ) );
					animated = animated.add( instanceNormal.mul( effect.mul( 1 ) ) );
					animated = animated.add( instanceNormal.mul( abs( sin( time.add( instanceSeed.mul( 2 ) ) ).mul( 1.5 ) ) ) );

					return animated;

				} )();

				const squareEdge = Fn( () => {

					const pos = uv().sub( vec2( 0.5, 0.5 ) );
					const squareDistance = max( abs( pos.x ), abs( pos.y ) );
					return squareDistance.div( 0.5 ).clamp( 0.85, 1 ).sub( 0.5 ).mul( 2.0 );

				} )();

				material.colorNode = Fn( () => {

					return squareEdge.sub( instanceColor );

				} )();

				material.emissiveNode = Fn( () => {

					const instanceTime = instanceData.y;

					const dif1 = abs( instanceTime.sub( uniformEffector1 ) ).toConst();
					const effect1 = dif1.lessThanEqual( 0.15 ).select( sub( 0.15, dif1 ).mul( sub( 1.7, instanceTime ).mul( 10 ) ), float( 0 ) );

					const dif2 = abs( instanceTime.sub( uniformEffector2 ) ).toConst();
					const effect2 = dif2.lessThanEqual( 0.15 ).select( sub( 0.15, dif2 ).mul( sub( 1.7, instanceTime ).mul( 10 ) ), effect1 );

					return pow2( vec3( effect1, 0, effect2 ) ).mul( instanceColor );

				} )();

				return mesh;

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_reflection_blurred.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - blurred reflection</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Blurred Reflection</span>
			</div>

			<small>
				Reflection with a blurred effect using a hash blur algorithm.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, vec4, fract, sample, abs, uniform, pow, color, max, length, rangeFogFactor, sub, reflector, normalWorld, hue, time, mix, positionWorld } from 'three/tsl';

			import { hashBlur } from 'three/addons/tsl/display/hashBlur.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let model, mixer, clock;
			let controls;
			let gui;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );
				camera.position.set( - 2.5, 2, 2.5 );
				camera.lookAt( 0, .4, 0 );

				scene = new THREE.Scene();
				scene.backgroundNode = hue( normalWorld.y.mix( 0, color( 0x0066ff ) ).mul( .1 ), time );

				const waterAmbientLight = new THREE.HemisphereLight( 0xffffff, 0x0066ff, 10 );
				scene.add( waterAmbientLight );

				clock = new THREE.Clock();

				// animated model

				const gltfLoader = new GLTFLoader();
				gltfLoader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					model = gltf.scene;
					model.children[ 0 ].children[ 0 ].castShadow = true;

					mixer = new THREE.AnimationMixer( model );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					scene.add( model );

				} );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const uvMap = textureLoader.load( 'textures/uv_grid_directx.jpg' );
				uvMap.colorSpace = THREE.SRGBColorSpace;

				// uv map for debugging

				const uvMaterial = new THREE.MeshStandardNodeMaterial( {
					map: uvMap,
					side: THREE.DoubleSide
				} );

				const uvMesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), uvMaterial );
				uvMesh.position.set( 0, 1, - 3 );
				scene.add( uvMesh );

				// circle effect

				const drawCircle = Fn( ( [ pos, radius, width, power, color, timer = time.mul( .5 ) ] ) => {

					// https://www.shadertoy.com/view/3tdSRn

					const dist1 = length( pos );
					dist1.assign( fract( dist1.mul( 5.0 ).sub( fract( timer ) ) ) );
					const dist2 = dist1.sub( radius );
					const intensity = pow( radius.div( abs( dist2 ) ), width );
					const col = color.rgb.mul( intensity ).mul( power ).mul( max( sub( 0.8, abs( dist2 ) ), 0.0 ) );

					return col;

				} );

				const circleFadeY = positionWorld.y.mul( .7 ).oneMinus().max( 0 );
				const animatedColor = mix( color( 0x74ccf4 ), color( 0x7f00c5 ), positionWorld.xz.distance( 0 ).div( 10 ).clamp() );
				const animatedCircle = hue( drawCircle( positionWorld.xz.mul( .1 ), 0.5, 0.8, .01, animatedColor ).mul( circleFadeY ), time );

				const floorLight = new THREE.PointLight( 0xffffff );
				floorLight.colorNode = animatedCircle.mul( 50 );
				scene.add( floorLight );

				// reflection

				const roughness = uniform( .9 );
				const radius = uniform( 0.2 );

				const reflection = reflector( { resolutionScale: .5, depth: true, bounces: false } ); // 0.5 is half of the rendering view
				const reflectionDepth = reflection.getDepthNode();
				reflection.target.rotateX( - Math.PI / 2 );
				scene.add( reflection.target );

				const floorMaterial = new THREE.MeshStandardNodeMaterial();
				floorMaterial.transparent = true;
				floorMaterial.colorNode = Fn( () => {

					// ranges adjustment

					const radiusRange = mix( 0.01, 0.1, radius ); // range [ 0.01, 0.1 ]
					const roughnessRange = mix( 0.3, 0.03, roughness ); // range [ 0.03, 0.3 ]

					// mask the sample

					const maskReflection = sample( ( uv ) => {

						const sample = reflection.sample( uv );
						const mask = reflectionDepth.sample( uv );

						return vec4( sample.rgb, sample.a.mul( mask.r ) );

					}, reflection.uvNode );

					// blur the reflection

					const reflectionBlurred = hashBlur( maskReflection, radiusRange, {
						repeats: 40,
						premultipliedAlpha: true
					} );

					// reflection composite

					const reflectionMask = reflectionBlurred.a.mul( reflectionDepth ).remapClamp( 0, roughnessRange );
					const reflectionIntensity = .1;
					const reflectionMixFactor = reflectionMask.mul( roughness.mul( 2 ).min( 1 ) );
					const reflectionFinal = mix( reflection.rgb, reflectionBlurred.rgb, reflectionMixFactor ).mul( reflectionIntensity );

					// mix reflection with animated circle

					const output = animatedCircle.add( reflectionFinal );

					// falloff opacity by distance like an opacity-fog

					const opacity = rangeFogFactor( 7, 25 ).oneMinus();

					// final output

					return vec4( output, opacity );

				} )();

				const floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );
				floor.position.set( 0, 0, 0 );
				scene.add( floor );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1.3;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				gui = renderer.inspector.createParameters( 'Settings' );
				gui.add( roughness, 'value', 0, 1 ).name( 'roughness' );
				gui.add( radius, 'value', 0, 1 ).name( 'radius' );
				gui.add( reflection.reflector, 'resolutionScale', .25, 1 ).name( 'resolution scale' );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI / 2;
				//controls.autoRotate = true;
				controls.autoRotateSpeed = - .1;
				controls.target.set( 0, .5, 0 );
				controls.update();

				// events

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				const delta = clock.getDelta();

				if ( model ) {

					mixer.update( delta );

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_reflection_roughness.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - roughness reflection</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Roughness Reflection</span>
			</div>

			<small>
				Reflection with roughness.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, vec2, vec4, texture, uv, textureBicubic, rangeFogFactor, reflector, time } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			let controls;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.25, 30 );
				camera.position.set( - 4, 1, 4 );

				scene = new THREE.Scene();

				const loader = new UltraHDRLoader();
				loader.setDataType( THREE.HalfFloatType );
				loader.load( 'textures/equirectangular/spruit_sunrise_2k.hdr.jpg', function ( texture ) {

					texture.mapping = THREE.EquirectangularReflectionMapping;
					texture.needsUpdate = true;

					scene.background = texture;
					scene.environment = texture;

				} );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const uvMap = textureLoader.load( 'textures/uv_grid_directx.jpg' );
				uvMap.colorSpace = THREE.SRGBColorSpace;

				const perlinMap = textureLoader.load( './textures/noises/perlin/rgb-256x256.png' );
				perlinMap.wrapS = THREE.RepeatWrapping;
				perlinMap.wrapT = THREE.RepeatWrapping;
				perlinMap.colorSpace = THREE.SRGBColorSpace;

				// uv box for debugging
			
				const mesh = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.MeshStandardNodeMaterial( {
						map: uvMap,
						roughnessMap: uvMap,
						emissiveMap: uvMap,
						emissive: 0xffffff
					} )
				);
				mesh.position.set( 0, 1.25, 0 );
				mesh.scale.setScalar( 2 );
				scene.add( mesh );

				// reflection

				const reflection = reflector( { resolutionScale: .5, bounces: false, generateMipmaps: true } ); // 0.5 is half of the rendering view
				reflection.target.rotateX( - Math.PI / 2 );
				scene.add( reflection.target );

				const animatedUV = uv().mul( 10 ).add( vec2( time.mul( .1 ), 0 ) );
				const roughness = texture( perlinMap, animatedUV ).r.mul( 2 ).saturate();

				const floorMaterial = new THREE.MeshStandardNodeMaterial();
				floorMaterial.transparent = true;
				floorMaterial.metalness = 1;
				floorMaterial.roughnessNode = roughness.mul( .2 );
				floorMaterial.colorNode = Fn( () => {

					// blur reflection using textureBicubic()
					const dirtyReflection = textureBicubic( reflection, roughness.mul( .9 ) );

					// falloff opacity by distance like an opacity-fog
					const opacity = rangeFogFactor( 7, 25 ).oneMinus();

					return vec4( dirtyReflection.rgb, opacity );

				} )();

				const floor = new THREE.Mesh( new THREE.BoxGeometry( 50, .001, 50 ), floorMaterial );
				floor.position.set( 0, 0, 0 );
				scene.add( floor );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1.5;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI / 2;
				controls.autoRotate = true;
				controls.autoRotateSpeed = - .1;
				controls.target.set( 0, .75, 0 );
				controls.update();

				// events

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_refraction.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - refraction</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Refraction</span>
			</div>

			<small>
				Refraction using backdrop.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { viewportSafeUV, viewportSharedTexture, screenUV, texture, uv } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			let cameraControls;

			let smallSphere;

			init();

			function init() {

				// scene
				scene = new THREE.Scene();

				// camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
				camera.position.set( 0, 50, 160 );

				//

				const geometry = new THREE.IcosahedronGeometry( 5, 0 );
				const material = new THREE.MeshPhongMaterial( { color: 0xffffff, emissive: 0x7b7b7b, flatShading: true } );
				smallSphere = new THREE.Mesh( geometry, material );
				scene.add( smallSphere );

				// textures

				const loader = new THREE.TextureLoader();

				const floorNormal = loader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );
				floorNormal.wrapS = THREE.RepeatWrapping;
				floorNormal.wrapT = THREE.RepeatWrapping;

				// refractor

				const verticalNormalScale = 0.1;
				const verticalUVOffset = texture( floorNormal, uv().mul( 5 ) ).xy.mul( 2 ).sub( 1 ).mul( verticalNormalScale );

				const refractorUV = screenUV.add( verticalUVOffset );
				const verticalRefractor = viewportSharedTexture( viewportSafeUV( refractorUV ) ).toInspector( 'Viewport Texture' );

				const planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );

				const planeRefractor = new THREE.Mesh( planeGeo, new THREE.MeshBasicNodeMaterial( {
					backdropNode: verticalRefractor
				} ) );
				planeRefractor.material.transparent = true;
				planeRefractor.position.y = 50;
				scene.add( planeRefractor );

				// walls
			
				const planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
				planeTop.position.y = 100;
				planeTop.rotateX( Math.PI / 2 );
				scene.add( planeTop );

				const planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
				planeBottom.rotateX( - Math.PI / 2 );
				scene.add( planeBottom );

				const planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );
				planeBack.position.z = - 50;
				planeBack.position.y = 50;
				scene.add( planeBack );

				const planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );
				planeRight.position.x = 50;
				planeRight.position.y = 50;
				planeRight.rotateY( - Math.PI / 2 );
				scene.add( planeRight );

				const planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );
				planeLeft.position.x = - 50;
				planeLeft.position.y = 50;
				planeLeft.rotateY( Math.PI / 2 );
				scene.add( planeLeft );

				// lights

				const mainLight = new THREE.PointLight( 0xe7e7e7, 2.5, 250, 0 );
				mainLight.position.y = 60;
				scene.add( mainLight );

				const greenLight = new THREE.PointLight( 0x00ff00, 0.5, 1000, 0 );
				greenLight.position.set( 550, 50, 0 );
				scene.add( greenLight );

				const redLight = new THREE.PointLight( 0xff0000, 0.5, 1000, 0 );
				redLight.position.set( - 550, 50, 0 );
				scene.add( redLight );

				const blueLight = new THREE.PointLight( 0xbbbbfe, 0.5, 1000, 0 );
				blueLight.position.set( 0, 50, 550 );
				scene.add( blueLight );

				// renderer

				renderer = new THREE.WebGPURenderer( /*{ antialias: true }*/ );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				cameraControls = new OrbitControls( camera, renderer.domElement );
				cameraControls.target.set( 0, 50, 0 );
				cameraControls.maxDistance = 400;
				cameraControls.minDistance = 10;
				cameraControls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const timer = Date.now() * 0.01;

				smallSphere.position.set(
					Math.cos( timer * 0.1 ) * 30,
					Math.abs( Math.cos( timer * 0.2 ) ) * 20 + 5,
					Math.sin( timer * 0.1 ) * 30
				);
				smallSphere.rotation.y = ( Math.PI / 2 ) - timer * 0.1;
				smallSphere.rotation.z = timer * 0.8;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_rendertarget_2d-array_3d.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - RenderTargetArray and RenderTarget3D</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			.viewport-label {
				position: absolute;
				color: white;
				background-color: rgba(0, 0, 0, 0.7);
				padding: 5px 10px;
				border-radius: 4px;
				font-family: monospace;
				pointer-events: none;
				z-index: 1000;
				user-select: none;
			}
		</style>
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>RenderTarget Array/3D</span>
			</div>

			<small>
				RenderTargetArray and RenderTarget3D examples.
			</small>
		</div>

		<div class="viewport-label" style="bottom: 2%; left: 2%;">DataArrayTexture</div>
		<div class="viewport-label" style="bottom: 2%; left: 52%;">Data3DTexture</div>
		<div class="viewport-label" style="bottom: 52%; left: 52%;">RenderTarget3D</div>
		<div class="viewport-label" style="bottom: 52%; left: 2%;">RenderTargetArray</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { vec2, uniform, screenUV, color, texture, diffuseColor, attribute, vec3, vec4 } from 'three/tsl';

			import { TextureHelper } from 'three/addons/helpers/TextureHelperGPU.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { unzipSync } from 'three/addons/libs/fflate.module.js';

			let renderer;
			let views = [];

			class View {

				constructor( left, top, width, height ) {

					this.left = left;
					this.top = top;
					this.width = width;
					this.height = height;

					const aspect = ( window.innerWidth * width ) / ( window.innerHeight * height );

					// Set up perspective camera
					this.camera = new THREE.PerspectiveCamera( 50, aspect, 0.1, 100 );
					this.camera.position.set( - 7, 0, 10 );
					this.camera.lookAt( 0, 0, 0 );
					this.camera.updateProjectionMatrix();

					this.scene = new THREE.Scene();


					const normalizedUV = screenUV.mul( vec2( 1, - 1 ) ).add( vec2( 0, 1 ) ); // Flip Y and offset

					// Calculate viewport center in normalized coordinates
					const viewportCenter = vec2(
						this.left + this.width * 0.5,
						this.top + this.height * 0.5 // Invert Y coordinate for proper alignment
					);

					const distanceEffect = normalizedUV.distance( viewportCenter ).smoothstep( 0, 0.2 );

					const backgroundEffect = color( this.top > 0 ? 0x212121 : 0x616161 ).sub( distanceEffect.pow( 0.3 ).mul( 0.1 ) );

					this.scene.backgroundNode = backgroundEffect;

				}

				// Method to handle viewport resize
				updateSize( left, top, width, height ) {

					this.left = left;
					this.top = top;
					this.width = width;
					this.height = height;

					const aspect = ( window.innerWidth * width ) / ( window.innerHeight * height );
					this.camera.aspect = aspect;
					this.camera.updateProjectionMatrix();

				}

			}

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				await renderer.init();

				// Create views after renderer initialization
				views = [
					new View( 0.0, 0.0, 0.5, 0.5 ),
					new View( 0.5, 0.0, 0.5, 0.5 ),
					new View( 0.0, 0.5, 0.5, 0.5 ),
					new View( 0.5, 0.5, 0.5, 0.5 )
				];

				// Add OrbitControls after views and renderer are created
				views.forEach( view => {

					view.controls = new OrbitControls( view.camera, renderer.domElement );
					view.controls.minDistance = 1;
					view.controls.maxDistance = 20;
					view.controls.minAzimuthAngle = - Math.PI / 3;
					view.controls.maxAzimuthAngle = Math.PI / 3;
					view.controls.minPolarAngle = Math.PI / 4;
					view.controls.maxPolarAngle = Math.PI / 1.25;
					view.controls.enableDamping = true;

				} );

				const size = {
					width: 256,
					height: 256,
					depth: 109
				};

				new THREE.FileLoader()
					.setResponseType( 'arraybuffer' )
					.load( 'textures/3d/head256x256x109.zip', function ( data ) {

						const zip = unzipSync( new Uint8Array( data ) );
						const array = new Uint8Array( zip[ 'head256x256x109' ].buffer );

						const map3D = new THREE.Data3DTexture( array, size.width, size.height, size.depth );
						map3D.name = 'Data3DTexture';
						map3D.format = THREE.RedFormat;
						map3D.minFilter = THREE.LinearFilter;
						map3D.magFilter = THREE.LinearFilter;
						map3D.unpackAlignment = 1;
						map3D.needsUpdate = true;


						const depth = size.depth / 20;

						// 3D
						const helper3D = new TextureHelper( map3D, 10, 10, depth );
						helper3D.material.outputNode = vec4(
							vec3( diffuseColor.r.mul( attribute( 'uvw' ).z.mul( diffuseColor.r ) ) ),
							diffuseColor.r.mul( diffuseColor.a )
						);
						views[ 1 ].scene.add( helper3D );

						const fbo3D = new THREE.RenderTarget3D( size.width, size.height, size.depth, {
							depthBuffer: false,
						} );
						fbo3D.texture.name = 'RenderTarget3D';


						const fbo3DHelper = new TextureHelper( fbo3D.texture, 10, 10, depth );
						fbo3DHelper.material.outputNode = vec4(
							vec3( diffuseColor.r ),
							diffuseColor.r
						);
						views[ 3 ].scene.add( fbo3DHelper );




						// 2D Array

						const mapArray = new THREE.DataArrayTexture( array, size.width, size.height, size.depth );
						mapArray.name = 'DataArrayTexture';
						mapArray.format = THREE.RedFormat;
						mapArray.minFilter = THREE.LinearFilter;
						mapArray.magFilter = THREE.LinearFilter;
						mapArray.unpackAlignment = 1;
						mapArray.needsUpdate = true;

						const helperArray = new TextureHelper( mapArray, 10, 10, depth );
						helperArray.material.outputNode = vec4(
							vec3( diffuseColor.r.mul( attribute( 'uvw' ).z.div( size.depth ).mul( diffuseColor.r ) ) ),
							diffuseColor.r.mul( diffuseColor.a )
						);
						views[ 0 ].scene.add( helperArray );

						// Setup render targets
						const materialQuad = new THREE.NodeMaterial();
						const uZCoord = uniform( 0 );
						materialQuad.depthTest = false;
						materialQuad.outputNode = vec4( texture( mapArray ).depth( uZCoord ).rgb, 1 );

						const fboArray = new THREE.RenderTarget( size.width, size.height, {
							depthBuffer: false,
							depth: size.depth
						} );
						fboArray.texture.name = 'RenderTargetArray';

						const fboArrayHelper = new TextureHelper( fboArray.texture, 10, 10, depth );
						fboArrayHelper.material.outputNode = vec4(
							vec3( diffuseColor.r ),
							diffuseColor.r
						);
						views[ 2 ].scene.add( fboArrayHelper );


						const quadMesh = new THREE.QuadMesh( materialQuad );



						// In WebGPU we need to clear all the layers of the 3D render target before rendering to it (WebGPU limitation?)
						if ( renderer.backend.isWebGPUBackend ) {

							const materialClear = new THREE.NodeMaterial();
							materialClear.outputNode = vec4( 0 );
							const clearQuadMesh = new THREE.QuadMesh( materialClear );
							for ( let i = 0; i < size.depth; i ++ ) {
			
								renderer.setRenderTarget( fbo3D, i );
								clearQuadMesh.render( renderer );

							}

						}

						let j = 0;

						const loop = () => {

							if ( j === size.depth ) {

								clearInterval( interval );
								return;

							}

							// Disable viewport and scissor for FBO rendering
							renderer.setViewport( 0, 0, size.width, size.height );
							renderer.setScissor( 0, 0, size.width, size.height );
							renderer.setScissorTest( false );

							uZCoord.value = j;

							renderer.setRenderTarget( fboArray, j );
							renderer.clear();
							quadMesh.render( renderer );

							renderer.setRenderTarget( fbo3D, j );
							renderer.clear();
							quadMesh.render( renderer );

							renderer.setRenderTarget( null );

							j = ( j + 1 ) % size.depth;

						};

						const interval = setInterval( loop, 50 );

						loop();

					} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				renderer.setSize( width, height );

				views.forEach( view => {

					view.updateSize(
						view.left,
						view.top,
						view.width,
						view.height
					);

				} );

			}

			function animate() {

				views.forEach( view => {

					view.controls.update();

					const left = Math.floor( view.left * window.innerWidth );
					const bottom = Math.floor( ( 1 - view.top - view.height ) * window.innerHeight );
					const width = Math.floor( view.width * window.innerWidth );
					const height = Math.floor( view.height * window.innerHeight );

					renderer.setViewport( left, bottom, width, height );
					renderer.setScissor( left, bottom, width, height );
					renderer.setScissorTest( true );

					renderer.clear();
					renderer.render( view.scene, view.camera );

				} );

			}

			init();

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_rtt.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - rtt</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

	<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>WebGPU RTT</span>
			</div>

			<small>Basic Render-to-Texture demo.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, uniform, saturation, hue } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;
			const mouse = new THREE.Vector2();

			let quadMesh, renderTarget;

			let box;

			const dpr = window.devicePixelRatio;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.z = 3;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x0066FF );

				// textured mesh

				const loader = new THREE.TextureLoader();
				const uvTexture = loader.load( './textures/uv_grid_opengl.jpg' );

				const geometryBox = new THREE.BoxGeometry();
				const materialBox = new THREE.MeshBasicNodeMaterial();
				materialBox.colorNode = texture( uvTexture );

				//

				box = new THREE.Mesh( geometryBox, materialBox );
				scene.add( box );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( dpr );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				renderer.inspector = new Inspector();

				renderTarget = new THREE.RenderTarget( window.innerWidth * dpr, window.innerHeight * dpr );

				window.addEventListener( 'mousemove', onWindowMouseMove );
				window.addEventListener( 'resize', onWindowResize );

				// FX

				// modulate the final color based on the mouse position

				const screenFXNode = uniform( mouse );

				const materialFX = new THREE.MeshBasicNodeMaterial();

				const scenePassTexture = texture( renderTarget.texture ).toInspector( 'Scene Pass' );
				materialFX.colorNode = hue( saturation( scenePassTexture.rgb, screenFXNode.x.oneMinus() ), screenFXNode.y );

				quadMesh = new THREE.QuadMesh( materialFX );
				quadMesh.name = 'Post-Processing';

			}

			function onWindowMouseMove( e ) {

				mouse.x = e.offsetX / window.innerWidth;
				mouse.y = e.offsetY / window.innerHeight;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				renderTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );

			}

			function animate() {

				box.rotation.x += 0.01;
				box.rotation.y += 0.02;

				renderer.setRenderTarget( renderTarget );
				renderer.render( scene, camera );

				renderer.setRenderTarget( null );
				quadMesh.render( renderer );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_sandbox.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - sandbox</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>WebGPU sandbox</span>
			</div>

			<small>A sandbox for testing basic scene setups.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { time, vec2, uv, texture, mix, checker, normalLocal, positionLocal, color, oscSine, attribute } from 'three/tsl';

			import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer;

			let box;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.z = 4;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				// textures

				const textureLoader = new THREE.TextureLoader();
				const uvTexture = textureLoader.load( './textures/uv_grid_opengl.jpg' );
				uvTexture.wrapS = THREE.RepeatWrapping;
				uvTexture.wrapT = THREE.RepeatWrapping;
				uvTexture.name = 'uv_grid';

				const textureDisplace = textureLoader.load( './textures/transition/transition1.png' );
				textureDisplace.wrapS = THREE.RepeatWrapping;
				textureDisplace.wrapT = THREE.RepeatWrapping;

				const ktxLoader = await new KTX2Loader()
					.setTranscoderPath( 'jsm/libs/basis/' )
					.detectSupport( renderer );

				const ktxTexture = await ktxLoader.loadAsync( './textures/ktx2/2d_uastc.ktx2' );

				// box mesh

				const geometryBox = new THREE.BoxGeometry();
				const materialBox = new THREE.MeshBasicNodeMaterial();

				// birection speed

				const timerScaleNode = time.mul( vec2( - 0.5, 0.1 ) );
				const animateUV = uv().add( timerScaleNode );

				const textureNode = texture( uvTexture, animateUV );

				materialBox.colorNode = mix( textureNode, checker( animateUV ), 0.5 );

				// test uv 2
				//geometryBox.setAttribute( 'uv1', geometryBox.getAttribute( 'uv' ) );
				//materialBox.colorNode = texture( uvTexture, uv( 1 ) );

				box = new THREE.Mesh( geometryBox, materialBox );
				box.position.set( 0, 1, 0 );
				scene.add( box );

				// displace example

				const geometrySphere = new THREE.SphereGeometry( .5, 64, 64 );
				const materialSphere = new THREE.MeshBasicNodeMaterial();

				const displaceY = texture( textureDisplace ).x.mul( 0.25 );

				const displace = normalLocal.mul( displaceY );

				materialSphere.colorNode = displaceY;
				materialSphere.positionNode = positionLocal.add( displace );

				const sphere = new THREE.Mesh( geometrySphere, materialSphere );
				sphere.position.set( - 2, - 1, 0 );
				scene.add( sphere );

				// data texture

				const geometryPlane = new THREE.PlaneGeometry();
				const materialPlane = new THREE.MeshBasicNodeMaterial();
				materialPlane.colorNode = texture( createDataTexture() ).add( color( 0x0000FF ) );
				materialPlane.transparent = true;

				const plane = new THREE.Mesh( geometryPlane, materialPlane );
				plane.position.set( 0, - 1, 0 );
				scene.add( plane );

				// compressed texture

				const materialCompressed = new THREE.MeshBasicNodeMaterial();
				materialCompressed.colorNode = texture( ktxTexture );
				materialCompressed.emissiveNode = oscSine().mix( color( 0x663300 ), color( 0x0000FF ) );
				materialCompressed.alphaTestNode = oscSine();
				materialCompressed.transparent = true;

				const geo = flipY( new THREE.PlaneGeometry() );
				const planeCompressed = new THREE.Mesh( geo, materialCompressed );
				planeCompressed.position.set( - 2, 1, 0 );
				scene.add( planeCompressed );

				// points

				const points = [];

				for ( let i = 0; i < 1000; i ++ ) {

					const point = new THREE.Vector3().random().subScalar( 0.5 );
					points.push( point );

				}

				const geometryPoints = new THREE.BufferGeometry().setFromPoints( points );
				const materialPoints = new THREE.PointsNodeMaterial();

				materialPoints.colorNode = positionLocal.mul( 3 );

				const pointCloud = new THREE.Points( geometryPoints, materialPoints );
				pointCloud.position.set( 2, - 1, 0 );
				scene.add( pointCloud );

				// lines

				const geometryLine = new THREE.BufferGeometry().setFromPoints( [
					new THREE.Vector3( - 0.5, - 0.5, 0 ),
					new THREE.Vector3( 0.5, - 0.5, 0 ),
					new THREE.Vector3( 0.5, 0.5, 0 ),
					new THREE.Vector3( - 0.5, 0.5, 0 ),
					new THREE.Vector3( - 0.5, - 0.5, 0 )
				] );

				geometryLine.setAttribute( 'color', geometryLine.getAttribute( 'position' ) );

				const materialLine = new THREE.LineBasicNodeMaterial();
				materialLine.colorNode = attribute( 'color' );

				const line = new THREE.Line( geometryLine, materialLine );
				line.position.set( 2, 1, 0 );
				scene.add( line );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				if ( box ) {

					box.rotation.x += 0.01;
					box.rotation.y += 0.02;

				}

				renderer.render( scene, camera );

			}

			function createDataTexture() {

				const color = new THREE.Color( 0xff0000 );

				const width = 512;
				const height = 512;

				const size = width * height;
				const data = new Uint8Array( 4 * size );

				const r = Math.floor( color.r * 255 );
				const g = Math.floor( color.g * 255 );
				const b = Math.floor( color.b * 255 );

				for ( let i = 0; i < size; i ++ ) {

					const stride = i * 4;

					data[ stride ] = r;
					data[ stride + 1 ] = g;
					data[ stride + 2 ] = b;
					data[ stride + 3 ] = 255;

				}

				const texture = new THREE.DataTexture( data, width, height, THREE.RGBAFormat );
				texture.needsUpdate = true;
				return texture;

			}

			/*
			 * Correct UVs to be compatible with `flipY=false` textures.
			 */
			function flipY( geometry ) {

				const uv = geometry.attributes.uv;

				for ( let i = 0; i < uv.count; i ++ ) {

					uv.setY( i, 1 - uv.getY( i ) );

				}

				return geometry;

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_shadertoy.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - shadertoy</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Shadertoy</span>
			</div>

			<small>
				Shader created by <a href="https://www.shadertoy.com/view/Mt2SzR" target="_blank" rel="noopener">jackdavenport</a> and <a href="https://www.shadertoy.com/view/3tcBzH" target="_blank" rel="noopener">trinketMage</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="x-shader/x-fragment" id="example1">

			// https://www.shadertoy.com/view/Mt2SzR

			float random(float x) {
 
				return fract(sin(x) * 10000.);
					  
			}
			
			float noise(vec2 p) {
			
				return random(p.x + p.y * 10000.);
						
			}
			
			vec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }
			vec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }
			vec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }
			vec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }
			
			float smoothNoise(vec2 p) {
			
				vec2 interp = smoothstep(0., 1., fract(p));
				float s = mix(noise(sw(p)), noise(se(p)), interp.x);
				float n = mix(noise(nw(p)), noise(ne(p)), interp.x);
				return mix(s, n, interp.y);
					
			}
			
			float fractalNoise(vec2 p) {
			
				float x = 0.;
				x += smoothNoise(p      );
				x += smoothNoise(p * 2. ) / 2.;
				x += smoothNoise(p * 4. ) / 4.;
				x += smoothNoise(p * 8. ) / 8.;
				x += smoothNoise(p * 16.) / 16.;
				x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;
				return x;
						
			}
			
			float movingNoise(vec2 p) {
			 
				float x = fractalNoise(p + iTime);
				float y = fractalNoise(p - iTime);
				return fractalNoise(p + vec2(x, y));   
				
			}
			
			// call this for water noise function
			float nestedNoise(vec2 p) {
				
				float x = movingNoise(p);
				float y = movingNoise(p + 100.);
				return movingNoise(p + vec2(x, y));
				
			}

			void mainImage( out vec4 fragColor, in vec2 fragCoord )
			{
				vec2 uv = fragCoord.xy / iResolution.xy;
				float n = nestedNoise(uv * 6.);

				fragColor = vec4(mix(vec3(.4, .6, 1.), vec3(.1, .2, 1.), n), 1.);
			}

		</script>

		<script type="x-shader/x-fragment" id="example2">

			// https://www.shadertoy.com/view/3tcBzH

			float rand(vec2 co){
				return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
			}
			
			float hermite(float t)
			{
			  return t * t * (3.0 - 2.0 * t);
			}
			
			float noise(vec2 co, float frequency)
			{
			  vec2 v = vec2(co.x * frequency, co.y * frequency);
			
			  float ix1 = floor(v.x);
			  float iy1 = floor(v.y);
			  float ix2 = floor(v.x + 1.0);
			  float iy2 = floor(v.y + 1.0);
			
			  float fx = hermite(fract(v.x));
			  float fy = hermite(fract(v.y));
			
			  float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);
			  float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);
			
			  return mix(fade1, fade2, fy);
			}
			
			float pnoise(vec2 co, float freq, int steps, float persistence)
			{
			  float value = 0.0;
			  float ampl = 1.0;
			  float sum = 0.0;
			  for(int i=0 ; i<steps ; i++)
			  {
				sum += ampl;
				value += noise(co, freq) * ampl;
				freq *= 2.0;
				ampl *= persistence;
			  }
			  return value / sum;
			}
			
			void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
				vec2 uv = fragCoord.xy / iResolution.xy;
				float gradient = 1.0 - uv.y;
				float gradientStep = 0.2;
				
				vec2 pos = fragCoord.xy / iResolution.x;
				pos.y -= iTime * 0.3125;
				
				vec4 brighterColor = vec4(1.0, 0.65, 0.1, 0.25);
				vec4 darkerColor = vec4(1.0, 0.0, 0.15, 0.0625);
				vec4 middleColor = mix(brighterColor, darkerColor, 0.5);
			
				float noiseTexel = pnoise(pos, 10.0, 5, 0.5);
				
				float firstStep = smoothstep(0.0, noiseTexel, gradient);
				float darkerColorStep = smoothstep(0.0, noiseTexel, gradient - gradientStep);
				float darkerColorPath = firstStep - darkerColorStep;
				vec4 color = mix(brighterColor, darkerColor, darkerColorPath);
			
				float middleColorStep = smoothstep(0.0, noiseTexel, gradient - 0.2 * 2.0);
				
				color = mix(color, middleColor, darkerColorStep - middleColorStep);
				color = mix(vec4(0.0), color, firstStep);
				fragColor = color;
			}

		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import * as TSL from 'three/tsl';

			import Transpiler from 'three/addons/transpiler/Transpiler.js';
			import ShaderToyDecoder from 'three/addons/transpiler/ShaderToyDecoder.js';
			import TSLEncoder from 'three/addons/transpiler/TSLEncoder.js';

			class ShaderToyNode extends THREE.Node {

				constructor() {

					super( 'vec4' );

					this.mainImage = null;

				}

				transpile( glsl, iife = false ) {

					const decoder = new ShaderToyDecoder();

					const encoder = new TSLEncoder();
					encoder.iife = iife;

					const jsCode = new Transpiler( decoder, encoder ).parse( glsl );

					return jsCode;

				}

				parse( glsl ) {

					const jsCode = this.transpile( glsl, true );

					const { mainImage } = eval( jsCode )( TSL );

					this.mainImage = mainImage;

				}

				async parseAsync( glsl ) {

					const jsCode = this.transpile( glsl );

					const { mainImage } = await import( `data:text/javascript,${ encodeURIComponent( jsCode ) }` );

					this.mainImage = mainImage;

				}

				setup( builder ) {

					if ( this.mainImage === null ) {

						throw new Error( 'ShaderToyNode: .parse() must be called first.' );

					}

					return this.mainImage();

				}


			}

			let renderer, camera, scene;
			const dpr = window.devicePixelRatio;

			init();

			function init() {

				const example1Code = document.getElementById( 'example1' ).textContent;
				const example2Code = document.getElementById( 'example2' ).textContent;

				const shaderToy1Node = new ShaderToyNode();
				shaderToy1Node.parse( example1Code );

				const shaderToy2Node = new ShaderToyNode();
				shaderToy2Node.parse( example2Code );

				//

				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				scene = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 2 );

				const material = new THREE.MeshBasicNodeMaterial();
				material.colorNode = TSL.oscSine( TSL.time.mul( .3 ) ).mix( shaderToy1Node, shaderToy2Node );

				const quad = new THREE.Mesh( geometry, material );
				scene.add( quad );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( dpr );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_shadowmap.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - shadow map</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Shadow Map</span>
			</div>

			<small>
				Shadow map example.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mx_fractal_noise_vec3, positionWorld, vec4, Fn, color, vertexIndex, hash } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, clock;
			let dirLight, spotLight;
			let torusKnot, dirGroup;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 10, 20 );

				scene = new THREE.Scene();
				scene.backgroundNode = color( 0x222244 );
				scene.fog = new THREE.Fog( 0x222244, 50, 100 );

				// lights

				scene.add( new THREE.AmbientLight( 0x444444, 2 ) );

				spotLight = new THREE.SpotLight( 0xff8888, 400 );
				spotLight.angle = Math.PI / 5;
				spotLight.penumbra = 0.3;
				spotLight.position.set( 8, 10, 5 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 8;
				spotLight.shadow.camera.far = 200;
				spotLight.shadow.mapSize.width = 2048;
				spotLight.shadow.mapSize.height = 2048;
				spotLight.shadow.bias = - 0.002;
				spotLight.shadow.radius = 4;
				scene.add( spotLight );


				dirLight = new THREE.DirectionalLight( 0x8888ff, 3 );
				dirLight.position.set( 3, 12, 17 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 500;
				dirLight.shadow.camera.right = 17;
				dirLight.shadow.camera.left = - 17;
				dirLight.shadow.camera.top	= 17;
				dirLight.shadow.camera.bottom = - 17;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				dirLight.shadow.radius = 4;
				dirLight.shadow.bias = - 0.0005;

				dirGroup = new THREE.Group();
				dirGroup.add( dirLight );
				scene.add( dirGroup );

				// geometry

				const geometry = new THREE.TorusKnotGeometry( 25, 8, 75, 80 );
				const material = new THREE.MeshPhongNodeMaterial( {
					color: 0x999999,
					shininess: 0,
					specular: 0x222222
				} );

				const materialCustomShadow = material.clone();
				materialCustomShadow.transparent = true;

				const materialColor = vec4( 1, 0, 1, .5 );
			
				const discardNode = hash( vertexIndex ).greaterThan( 0.5 );

				materialCustomShadow.colorNode = Fn( () => {

					discardNode.discard();

					return materialColor;

				} )();


				materialCustomShadow.castShadowNode = Fn( () => {

					discardNode.discard();

					return materialColor;
			
				} )();

				torusKnot = new THREE.Mesh( geometry, materialCustomShadow );
				torusKnot.scale.multiplyScalar( 1 / 18 );
				torusKnot.position.y = 3;
				torusKnot.castShadow = true;
				torusKnot.receiveShadow = true;
				scene.add( torusKnot );

				const cylinderGeometry = new THREE.CylinderGeometry( 0.75, 0.75, 7, 32 );

				const pillar1 = new THREE.Mesh( cylinderGeometry, material );
				pillar1.position.set( 8, 3.5, 8 );
				pillar1.castShadow = true;

				const pillar2 = pillar1.clone();
				pillar2.position.set( 8, 3.5, - 8 );
				const pillar3 = pillar1.clone();
				pillar3.position.set( - 8, 3.5, 8 );
				const pillar4 = pillar1.clone();
				pillar4.position.set( - 8, 3.5, - 8 );

				scene.add( pillar1 );
				scene.add( pillar2 );
				scene.add( pillar3 );
				scene.add( pillar4 );

				const planeGeometry = new THREE.PlaneGeometry( 200, 200 );

				const planeMaterial = new THREE.MeshPhongNodeMaterial();
				planeMaterial.color.setHex( 0x999999 );
				planeMaterial.shininess = 0;
				planeMaterial.specular.setHex( 0x111111 );

				planeMaterial.receivedShadowPositionNode = Fn( () => {

					const pos = positionWorld.toVar();
					pos.xz.addAssign( mx_fractal_noise_vec3( positionWorld.mul( 2 ) ).saturate().xz );
					return pos;

				} )();

				planeMaterial.colorNode = Fn( () => {

					const pos = positionWorld.toVar();
					pos.xz.addAssign( mx_fractal_noise_vec3( positionWorld.mul( 2 ) ).saturate().xz );
					return mx_fractal_noise_vec3( positionWorld.mul( 2 ) ).saturate().zzz.mul( 0.2 ).add( .5 );

				} )();

				const ground = new THREE.Mesh( planeGeometry, planeMaterial );
				ground.rotation.x = - Math.PI / 2;
				ground.scale.multiplyScalar( 3 );
				ground.castShadow = true;
				ground.receiveShadow = true;
				scene.add( ground );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// Mouse control
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 2, 0 );
				controls.minDistance = 7;
				controls.maxDistance = 40;
				controls.update();

				clock = new THREE.Clock();

				window.addEventListener( 'resize', resize );

			}

			function resize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate( time ) {

				const delta = clock.getDelta();

				torusKnot.rotation.x += 0.25 * delta;
				torusKnot.rotation.y += 0.5 * delta;
				torusKnot.rotation.z += 1 * delta;

				dirGroup.rotation.y += 0.7 * delta;
				dirLight.position.z = 17 + Math.sin( time * 0.001 ) * 5;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_shadowmap_array.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - shadow map array tile demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Shadow Map Array</span>
			</div>

			<small>
				Tile shadow using shadow map array demonstration
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mx_fractal_noise_vec3, positionWorld, Fn, color } from 'three/tsl';

			import { TileShadowNode } from 'three/addons/tsl/shadows/TileShadowNode.js';
			import { TileShadowNodeHelper } from 'three/addons/tsl/shadows/TileShadowNodeHelper.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, clock;
			let dirLight;
			let torusKnot, dirGroup;
			let tsmHelper;

			init();

			async function init() {

				// Renderer setup
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );

				renderer.inspector = new Inspector();

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.BasicShadowMap;
				// renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.2;
				document.body.appendChild( renderer.domElement );
			
				await renderer.init();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 45, 60, 100 );

				scene = new THREE.Scene();
				scene.backgroundNode = color( 0xCCCCFF ); // Brighter blue sky
				scene.fog = new THREE.Fog( 0xCCCCFF, 700, 1000 );

				// Enhanced lighting for a brighter scene
				scene.add( new THREE.AmbientLight( 0xCCCCFF, 3 ) );

				// Main directional light (sun)
				dirLight = new THREE.DirectionalLight( 0xFFFFAA, 5 );
				dirLight.position.set( 0, 80, 30 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 200;
				dirLight.shadow.camera.right = 180;
				dirLight.shadow.camera.left = - 180;
				dirLight.shadow.camera.top	= 180;
				dirLight.shadow.camera.bottom = - 160;
				dirLight.shadow.mapSize.width = 1024 * 4;
				dirLight.shadow.mapSize.height = 1024 * 4;
				dirLight.shadow.radius = 1;
				dirLight.shadow.bias = - 0.005;

				// Set up the tile shadow mapping
				const tsm = new TileShadowNode( dirLight, {
					tilesX: 2,
					tilesY: 2
				} );


				dirLight.shadow.shadowNode = tsm;
				scene.add( dirLight );

				tsmHelper = new TileShadowNodeHelper( tsm );
				scene.add( tsmHelper );


				dirGroup = new THREE.Group();
				dirGroup.add( dirLight );
				scene.add( dirGroup );

				// Create the ground with enhanced texture
				const planeGeometry = new THREE.PlaneGeometry( 1500, 1500, 2, 2 );
				const planeMaterial = new THREE.MeshPhongMaterial( {
					color: 0x88AA44,
					shininess: 5,
					specular: 0x222222
				} );

				planeMaterial.colorNode = Fn( () => {

					const noise = mx_fractal_noise_vec3( positionWorld.mul( 0.05 ) ).saturate();
					// Mix of greens and browns for a more natural ground
					const green = color( 0.4, 0.7, 0.3 );
					const brown = color( 0.6, 0.5, 0.3 );
					return noise.x.mix( green, brown );
			
				} )();

				const ground = new THREE.Mesh( planeGeometry, planeMaterial );
				ground.rotation.x = - Math.PI / 2;
				ground.receiveShadow = true;
				scene.add( ground );

				// Spread various objects across the scene
				createScenery();

				// Camera controls
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 5, 0 );
				controls.minDistance = 0.01;
				controls.maxDistance = 400;
				controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent camera from going below ground
				controls.update();

				clock = new THREE.Clock();

				window.addEventListener( 'resize', resize );

			}

			function createScenery() {

				// 1. Columns using instanced mesh
				const columnGeometry = new THREE.CylinderGeometry( 0.8, 1, 1, 16 );
				const columnMaterial = new THREE.MeshPhongMaterial( {
					color: 0xDDDDDD,
					shininess: 20
				} );

				const columnPositions = [];
				const columnScales = [];

				for ( let x = - 100; x <= 100; x += 40 ) {

					for ( let z = - 100; z <= 100; z += 40 ) {

						if ( Math.random() > 0.3 ) {

							const height = 5 + Math.random() * 10;
							const posX = x + ( Math.random() * 10 - 5 );
							const posY = height / 2;
							const posZ = z + ( Math.random() * 10 - 5 );

							columnPositions.push( posX, posY, posZ );
							columnScales.push( 1, height, 1 ); // Only scale Y to match height

						}

					}

				}

				const columnCount = columnPositions.length / 3;
				const columnInstancedMesh = new THREE.InstancedMesh(
					columnGeometry,
					columnMaterial,
					columnCount
				);

				const matrix = new THREE.Matrix4();
				for ( let i = 0; i < columnCount; i ++ ) {

					const x = columnPositions[ i * 3 ];
					const y = columnPositions[ i * 3 + 1 ];
					const z = columnPositions[ i * 3 + 2 ];
					const scaleY = columnScales[ i * 3 + 1 ];

					matrix.makeScale( 1, scaleY, 1 );
					matrix.setPosition( x, y, z );
					columnInstancedMesh.setMatrixAt( i, matrix );

				}

				columnInstancedMesh.castShadow = true;
				columnInstancedMesh.receiveShadow = true;
				scene.add( columnInstancedMesh );

				// 2. Add a central feature - the torus knot (kept as regular mesh for animation)
				const torusKnotGeometry = new THREE.TorusKnotGeometry( 25, 8, 100, 30 );
				const torusKnotMaterial = new THREE.MeshPhongNodeMaterial( {
					color: 0xFF6347, // Tomato color
					shininess: 30,
				} );

				torusKnot = new THREE.Mesh( torusKnotGeometry, torusKnotMaterial );
				torusKnot.scale.multiplyScalar( 1 / 18 );
				torusKnot.position.x = 5;
				torusKnot.position.y = 5;
				torusKnot.castShadow = true;
				torusKnot.receiveShadow = true;
				scene.add( torusKnot );

				// 3. Cubes using instanced mesh
				const cubeGeometry = new THREE.BoxGeometry( 3, 3, 3 );
				const cubeMaterials = [
					new THREE.MeshPhongMaterial( { color: 0x6699CC, shininess: 20 } ),
					new THREE.MeshPhongMaterial( { color: 0xCC6666, shininess: 20 } ),
					new THREE.MeshPhongMaterial( { color: 0xCCCC66, shininess: 20 } )
				];

				const cubeCount = 10;
				const cubeInstances = cubeMaterials.map( material => {

					return new THREE.InstancedMesh( cubeGeometry, material, cubeCount );

				} );

				for ( let i = 0; i < 30; i ++ ) {

					const materialIndex = i % 3;
					const instanceIndex = Math.floor( i / 3 );

					const x = Math.random() * 300 - 150;
					const y = 1.5;
					const z = Math.random() * 300 - 150;
					const rotY = Math.random() * Math.PI * 2;

					matrix.makeRotationY( rotY );
					matrix.setPosition( x, y, z );

					cubeInstances[ materialIndex ].setMatrixAt( instanceIndex, matrix );

				}

				cubeInstances.forEach( instance => {

					instance.castShadow = true;
					instance.receiveShadow = true;
					scene.add( instance );

				} );

				// 4. Spheres using instanced mesh
				const sphereGeometry = new THREE.SphereGeometry( 2, 32, 32 );
				const sphereMaterial = new THREE.MeshPhongMaterial( {
					color: 0x88CCAA,
					shininess: 40
				} );

				const sphereCount = 25;
				const sphereInstancedMesh = new THREE.InstancedMesh(
					sphereGeometry,
					sphereMaterial,
					sphereCount
				);

				for ( let i = 0; i < sphereCount; i ++ ) {

					const x = Math.random() * 180 - 90;
					const y = 2;
					const z = Math.random() * 180 - 90;

					matrix.makeScale( 1, 1, 1 );
					matrix.setPosition( x, y, z );
					sphereInstancedMesh.setMatrixAt( i, matrix );

				}

				sphereInstancedMesh.castShadow = true;
				sphereInstancedMesh.receiveShadow = true;
				scene.add( sphereInstancedMesh );

				// 5. Trees using instanced mesh for trunks and tops separately
				const trunkGeometry = new THREE.CylinderGeometry( 0.5, 0.5, 2, 8 );
				const topGeometry = new THREE.ConeGeometry( 2, 8, 8 );
				const treeMaterial = new THREE.MeshPhongMaterial( {
					vertexColors: true,
					shininess: 5
				} );

				const treeCount = 40;
				const totalInstanceCount = treeCount * 2;

				const trunkVertexCount = trunkGeometry.attributes.position.count;
				const trunkIndexCount = trunkGeometry.index ? trunkGeometry.index.count : 0;
				const topVertexCount = topGeometry.attributes.position.count;
				const topIndexCount = topGeometry.index ? topGeometry.index.count : 0;


				const totalVertexCount = ( trunkVertexCount + topVertexCount ) * 2; // Multiple for safety
				const totalIndexCount = ( trunkIndexCount + topIndexCount ) * 2;
				const treeBatchedMesh = new THREE.BatchedMesh( totalInstanceCount, totalVertexCount, totalIndexCount, treeMaterial );
				treeBatchedMesh.castShadow = true;
				treeBatchedMesh.perObjectFrustumCulled = false;
				const trunkGeometryId = treeBatchedMesh.addGeometry( trunkGeometry );
				const topGeometryId = treeBatchedMesh.addGeometry( topGeometry );

				const trunkColor = new THREE.Color( 0x8B4513 );
				const topColor = new THREE.Color( 0x336633 );


				for ( let i = 0; i < treeCount; i ++ ) {

					const x = Math.random() * 300 - 150;
					const z = Math.random() * 300 - 150;

					const trunkId = treeBatchedMesh.addInstance( trunkGeometryId );
					matrix.makeScale( 1, 1, 1 );
					matrix.setPosition( x, 1, z );
					treeBatchedMesh.setMatrixAt( trunkId, matrix );
					treeBatchedMesh.setColorAt( trunkId, trunkColor );

					const topId = treeBatchedMesh.addInstance( topGeometryId );
					matrix.makeScale( 1, 1, 1 );
					matrix.setPosition( x, 6, z );
					treeBatchedMesh.setMatrixAt( topId, matrix );
					treeBatchedMesh.setColorAt( topId, topColor );

				}

				scene.add( treeBatchedMesh );


				// 6. Torus shapes using instanced mesh
				const torusGeometry = new THREE.TorusGeometry( 3, 1, 16, 50 );
				const torusMaterial = new THREE.MeshPhongMaterial( {
					color: 0xFF99CC,
					shininess: 30
				} );

				const torusCount = 15;
				const torusInstancedMesh = new THREE.InstancedMesh(
					torusGeometry,
					torusMaterial,
					torusCount
				);

				for ( let i = 0; i < torusCount; i ++ ) {

					const x = Math.random() * 320 - 160;
					const y = 2;
					const z = Math.random() * 320 - 160;
					const rotZ = Math.random() * Math.PI * 2;

					// Apply rotation (PI/2 on X-axis and random on Z-axis)
					matrix.makeRotationX( Math.PI / 2 );
					const rotMatrix = new THREE.Matrix4().makeRotationZ( rotZ );
					matrix.multiply( rotMatrix );
					matrix.setPosition( x, y, z );

					torusInstancedMesh.setMatrixAt( i, matrix );

				}

				torusInstancedMesh.castShadow = true;
				torusInstancedMesh.receiveShadow = true;
				scene.add( torusInstancedMesh );

			}

			function resize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate( time ) {

				const delta = clock.getDelta();

				// Rotate the central torus knot
				torusKnot.rotation.x += 0.25 * delta;
				torusKnot.rotation.y += 0.5 * delta;
				torusKnot.rotation.z += 1 * delta;

				dirLight.position.x = Math.sin( time * 0.0001 ) * 30;
				dirLight.position.z = Math.cos( time * 0.0001 ) * 30;

				renderer.render( scene, camera );

				tsmHelper.update();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_shadowmap_csm.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - cascaded shadow maps</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Cascaded Shadow Maps</span>
			</div>

			<small>
				By <a href="https://github.com/strandedkitty/" target="_blank" rel="noopener">StrandedKitty</a> (<a href="https://github.com/strandedkitty/three-csm" target="_blank" rel="noopener">original repository</a>).
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { CSMShadowNode } from 'three/addons/csm/CSMShadowNode.js';
			import { CSMHelper } from 'three/addons/csm/CSMHelper.js';

			let renderer, scene, camera, orthoCamera, controls, csm, csmHelper, csmDirectionalLight;

			const params = {
				orthographic: false,
				fade: false,
				shadows: true,
				maxFar: 1000,
				mode: 'practical',
				lightX: - 1,
				lightY: - 1,
				lightZ: - 1,
				margin: 100,
				shadowNear: 1,
				shadowFar: 2000,
				autoUpdateHelper: true,
				updateHelper: function () {

					csmHelper.update();

				}
			};

			init();

			function updateOrthoCamera() {

				const size = controls.target.distanceTo( camera.position );
				const aspect = camera.aspect;

				orthoCamera.left = size * aspect / - 2;
				orthoCamera.right = size * aspect / 2;

				orthoCamera.top = size / 2;
				orthoCamera.bottom = size / - 2;
				orthoCamera.position.copy( camera.position );
				orthoCamera.rotation.copy( camera.rotation );
				orthoCamera.updateProjectionMatrix();

			}

			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( '#454e61' );
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 5000 );
				orthoCamera = new THREE.OrthographicCamera();

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );

				renderer.shadowMap.enabled = params.shadows;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				renderer.inspector = new Inspector();

				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI / 2;
				camera.position.set( 60, 60, 0 );
				controls.target = new THREE.Vector3( - 100, 10, 0 );
				controls.update();

				const ambientLight = new THREE.AmbientLight( 0xffffff, 1.5 );
				scene.add( ambientLight );

				const additionalDirectionalLight = new THREE.DirectionalLight( 0x000020, 1.5 );
				additionalDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );
				scene.add( additionalDirectionalLight );

				csmDirectionalLight = new THREE.DirectionalLight( 0xffffff, 3.0 );

				csmDirectionalLight.castShadow = true;
				csmDirectionalLight.shadow.mapSize.width = 2048;
				csmDirectionalLight.shadow.mapSize.height = 2048;
				csmDirectionalLight.shadow.camera.near = params.shadowNear;
				csmDirectionalLight.shadow.camera.far = params.shadowFar;
				csmDirectionalLight.shadow.camera.top = 1000;
				csmDirectionalLight.shadow.camera.bottom = - 1000;
				csmDirectionalLight.shadow.camera.left = - 1000;
				csmDirectionalLight.shadow.camera.right = 1000;
				csmDirectionalLight.shadow.bias = - 0.001;

				csm = new CSMShadowNode( csmDirectionalLight, { cascades: 4, maxFar: params.maxFar, mode: params.mode } );

				csmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );

				csmDirectionalLight.shadow.shadowNode = csm;

				scene.add( csmDirectionalLight );

				csmHelper = new CSMHelper( csm );
				csmHelper.visible = false;
				scene.add( csmHelper );

				const floorMaterial = new THREE.MeshPhongMaterial( { color: '#252a34' } );

				const floor = new THREE.Mesh( new THREE.PlaneGeometry( 10000, 10000, 8, 8 ), floorMaterial );
				floor.rotation.x = - Math.PI / 2;
				floor.castShadow = true;
				floor.receiveShadow = true;
				scene.add( floor );

				const material1 = new THREE.MeshPhongMaterial( { color: '#08d9d6' } );

				const material2 = new THREE.MeshPhongMaterial( { color: '#ff2e63' } );

				const geometry = new THREE.BoxGeometry( 10, 10, 10 );

				for ( let i = 0; i < 40; i ++ ) {

					const cube1 = new THREE.Mesh( geometry, i % 2 === 0 ? material1 : material2 );
					cube1.castShadow = true;
					cube1.receiveShadow = true;
					scene.add( cube1 );
					cube1.position.set( - i * 25, 20, 30 );
					cube1.scale.y = Math.random() * 2 + 6;

					const cube2 = new THREE.Mesh( geometry, i % 2 === 0 ? material2 : material1 );
					cube2.castShadow = true;
					cube2.receiveShadow = true;
					scene.add( cube2 );
					cube2.position.set( - i * 25, 20, - 30 );
					cube2.scale.y = Math.random() * 2 + 6;

				}

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( params, 'orthographic' ).onChange( function ( value ) {

					csm.camera = value ? orthoCamera : camera;
					csm.updateFrustums();

				} );

				// gui.add( params, 'fade' ).onChange( function ( value ) {

				// csm.fade = value;
				// csm.updateFrustums();
				// TODO: Changing "fade" requires toggling shadows right now

				// } );

				gui.add( params, 'shadows' ).onChange( function ( value ) {

					csmDirectionalLight.castShadow = value;

				} );

				gui.add( params, 'maxFar', 1, 5000, 1 ).name( 'max shadow far' ).onChange( function ( value ) {

					csm.maxFar = value;
					csm.updateFrustums();

				} );

				gui.add( params, 'mode', [ 'uniform', 'logarithmic', 'practical' ] ).name( 'frustum split mode' ).onChange( function ( value ) {

					csm.mode = value;
					csm.updateFrustums();

				} );

				gui.add( params, 'lightX', - 1, 1 ).name( 'light direction x' ).onChange( function () {

					csmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );

				} );

				gui.add( params, 'lightY', - 1, 1 ).name( 'light direction y' ).onChange( function () {

					csmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );

				} );

				gui.add( params, 'lightZ', - 1, 1 ).name( 'light direction z' ).onChange( function () {

					csmDirectionalLight.position.set( params.lightX, params.lightY, params.lightZ ).normalize().multiplyScalar( - 200 );

				} );

				gui.add( params, 'margin', 0, 200 ).name( 'light margin' ).onChange( function ( value ) {

					csm.lightMargin = value;

				} );

				gui.add( params, 'shadowNear', 1, 10000 ).name( 'shadow near' ).onChange( function ( value ) {

					for ( let i = 0; i < csm.lights.length; i ++ ) {

						csm.lights[ i ].shadow.camera.near = value;
						csm.lights[ i ].shadow.camera.updateProjectionMatrix();

					}

				} );

				gui.add( params, 'shadowFar', 1, 10000 ).name( 'shadow far' ).onChange( function ( value ) {

					for ( let i = 0; i < csm.lights.length; i ++ ) {

						csm.lights[ i ].shadow.camera.far = value;
						csm.lights[ i ].shadow.camera.updateProjectionMatrix();

					}

				} );

				const helperFolder = gui.addFolder( 'helper' );

				helperFolder.add( csmHelper, 'visible' );

				helperFolder.add( csmHelper, 'displayFrustum' ).onChange( function () {

					csmHelper.updateVisibility();

				} );

				helperFolder.add( csmHelper, 'displayPlanes' ).onChange( function () {

					csmHelper.updateVisibility();

				} );

				helperFolder.add( csmHelper, 'displayShadowBounds' ).onChange( function () {

					csmHelper.updateVisibility();

				} );

				helperFolder.add( params, 'autoUpdateHelper' ).name( 'auto update' );

				helperFolder.add( params, 'updateHelper' ).name( 'update' );

				window.addEventListener( 'resize', function () {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					updateOrthoCamera();
					csm.updateFrustums();

					renderer.setSize( window.innerWidth, window.innerHeight );

				} );

			}

			function animate() {

				camera.updateMatrixWorld();
				controls.update();

				if ( params.orthographic ) {

					updateOrthoCamera();
					csm.updateFrustums();

					if ( params.autoUpdateHelper ) {

						csmHelper.update();

					}

					renderer.render( scene, orthoCamera );

				} else {

					if ( params.autoUpdateHelper ) {

						csmHelper.update();

					}

					renderer.render( scene, camera );

				}

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_shadowmap_opacity.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - shadowmap + opacity</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Opacity Shadow Map</span>
			</div>

			<small>Shadow Map with custom color and opacity by material.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, mix } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 40 );
				camera.position.set( - 4, 2, 6 );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.toneMapping = THREE.AgXToneMapping;
				renderer.toneMappingExposure = 1.5;
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				container.appendChild( renderer.domElement );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x9e9eff );

				// light + shadow

				const hemi = new THREE.AmbientLight( 0xffffff, .5 );
				scene.add( hemi );

				const dirLight = new THREE.DirectionalLight( 0x6666ff, 10 );
				dirLight.position.set( 3, 5, 17 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 50;
				dirLight.shadow.camera.right = 5;
				dirLight.shadow.camera.left = - 5;
				dirLight.shadow.camera.top	= 5;
				dirLight.shadow.camera.bottom = - 5;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				dirLight.shadow.radius = 4;
				dirLight.shadow.bias = - 0.0005;

				dirLight.shadow.autoUpdate = false;
				dirLight.shadow.needsUpdate = true;

				scene.add( dirLight );

				//

				const loader = new GLTFLoader();
				const gltf = await loader.loadAsync( 'models/gltf/DragonAttenuation.glb' );
				gltf.scene.position.set( 0, 0, - .5 );

				const floor = gltf.scene.children[ 0 ];
				floor.scale.x += 4;
				floor.scale.y += 4;

				const dragon = gltf.scene.children[ 1 ];
				dragon.position.set( - 1.5, - 0.8, 1 );

				const dragon2 = dragon.clone();
				dragon2.material = dragon.material.clone();
				dragon2.material.attenuationColor = new THREE.Color( 0xff0000 );
				dragon2.position.x += 4;
				gltf.scene.add( dragon2 );

				// shadow node

				const customShadow = Fn( ( [ color, opacity = 1 ] ) => {

					//return vec4( color, opacity ); // opacity by blending
					return mix( 1, color, opacity ); // opacity by color

				} );

				// apply shadow

				floor.receiveShadow = true;

				dragon.castShadow = dragon2.castShadow = true;
				dragon.receiveShadow = dragon2.receiveShadow = true;

				dragon.material.castShadowNode = customShadow( dragon.material.attenuationColor );
				dragon2.material.castShadowNode = customShadow( dragon2.material.attenuationColor );

				//

				scene.add( gltf.scene );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 0.1;
				controls.maxDistance = 10;
				controls.target.set( 0, 0, 0 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_shadowmap_progressive.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - progressive lightmap accumulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Progressive Lightmaps</span>
			</div>

			<small>
				By <a href="https://github.com/zalo" target="_blank" rel="noopener">zalo</a>. Inspired by <a href="http://madebyevan.com/shaders/lightmap/" target="_blank" rel="noopener">evanw's Lightmap Generation</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { TransformControls } from 'three/addons/controls/TransformControls.js';
			import { ProgressiveLightMap } from 'three/addons/misc/ProgressiveLightMapGPU.js';

			// ShadowMap + LightMap Res and Number of Directional Lights
			const shadowMapRes = 1024, lightMapRes = 1024, lightCount = 4;
			let camera, scene, renderer, controls, control, control2,
				object = new THREE.Mesh(), lightOrigin = null, progressiveSurfacemap;
			const dirLights = [], lightmapObjects = [];
			const params = { 'Enable': true, 'Blur Edges': true, 'Blend Window': 200,
							 'Light Radius': 50, 'Ambient Weight': 0.5, 'Debug Lightmap': false };
			init();
			createGUI();

			function init() {

				// renderer
				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// camera
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 100, 200 );
				camera.name = 'Camera';

				// scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x949494 );
				scene.fog = new THREE.Fog( 0x949494, 1000, 3000 );

				// progressive lightmap
				progressiveSurfacemap = new ProgressiveLightMap( renderer, lightMapRes );

				// directional lighting "origin"
				lightOrigin = new THREE.Group();
				lightOrigin.position.set( 60, 150, 100 );
				scene.add( lightOrigin );

				// transform gizmo
				control = new TransformControls( camera, renderer.domElement );
				control.addEventListener( 'dragging-changed', ( event ) => {

					controls.enabled = ! event.value;

				} );
				control.attach( lightOrigin );
				scene.add( control.getHelper() );

				// create 8 directional lights to speed up the convergence
				for ( let l = 0; l < lightCount; l ++ ) {

					const dirLight = new THREE.DirectionalLight( 0xffffff, Math.PI / lightCount );
					dirLight.name = 'Dir. Light ' + l;
					dirLight.position.set( 200, 200, 200 );
					dirLight.castShadow = true;
					dirLight.shadow.camera.near = 100;
					dirLight.shadow.camera.far = 5000;
					dirLight.shadow.camera.right = 150;
					dirLight.shadow.camera.left = - 150;
					dirLight.shadow.camera.top = 150;
					dirLight.shadow.camera.bottom = - 150;
					dirLight.shadow.mapSize.width = shadowMapRes;
					dirLight.shadow.mapSize.height = shadowMapRes;
					dirLight.shadow.bias = - 0.001;
					lightmapObjects.push( dirLight );
					dirLights.push( dirLight );

				}

				// ground
				const groundMesh = new THREE.Mesh(
					new THREE.PlaneGeometry( 600, 600 ),
					new THREE.MeshPhongMaterial( { color: 0xffffff, depthWrite: true } )
				);
				groundMesh.position.y = - 0.1;
				groundMesh.rotation.x = - Math.PI / 2;
				groundMesh.name = 'Ground Mesh';
				lightmapObjects.push( groundMesh );
				scene.add( groundMesh );

				// model
				function loadModel() {

					object.traverse( function ( child ) {

						if ( child.isMesh ) {

							child.name = 'Loaded Mesh';
							child.castShadow = true;
							child.receiveShadow = true;
							child.material = new THREE.MeshPhongMaterial();

							// This adds the model to the lightmap
							lightmapObjects.push( child );
							progressiveSurfacemap.addObjectsToLightMap( lightmapObjects );

						} else {

							child.layers.disableAll(); // Disable Rendering for this

						}

					} );
					scene.add( object );
					object.scale.set( 2, 2, 2 );
					object.position.set( 0, - 16, 0 );
					control2 = new TransformControls( camera, renderer.domElement );
					control2.addEventListener( 'dragging-changed', ( event ) => {

						controls.enabled = ! event.value;

					} );
					control2.attach( object );
					scene.add( control2.getHelper() );
					const lightTarget = new THREE.Group();
					lightTarget.position.set( 0, 20, 0 );
					for ( let l = 0; l < dirLights.length; l ++ ) {

						dirLights[ l ].target = lightTarget;

					}

					object.add( lightTarget );

				}

				const manager = new THREE.LoadingManager( loadModel );
				const loader = new GLTFLoader( manager );
				loader.load( 'models/gltf/ShadowmappableMesh.glb', function ( obj ) {

					object = obj.scene.children[ 0 ];

				} );

				// controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;
				controls.screenSpacePanning = true;
				controls.minDistance = 100;
				controls.maxDistance = 500;
				controls.maxPolarAngle = Math.PI / 1.5;
				controls.target.set( 0, 100, 0 );
			
				window.addEventListener( 'resize', onWindowResize );

			}

			function createGUI() {

				const gui = renderer.inspector.createParameters( 'Accumulation Settings' );
				gui.add( params, 'Enable' );
				gui.add( params, 'Blur Edges' );
				gui.add( params, 'Blend Window', 1, 500, 1 );
				gui.add( params, 'Light Radius', 0, 200, 10 );
				gui.add( params, 'Ambient Weight', 0, 1, 0.1 );
				gui.add( params, 'Debug Lightmap' ).onChange( ( value ) => progressiveSurfacemap.showDebugLightmap( value ) );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				// Update the inertia on the orbit controls
				controls.update();

				// Accumulate Surface Maps
				if ( params[ 'Enable' ] ) {

					progressiveSurfacemap.update( camera, params[ 'Blend Window' ], params[ 'Blur Edges' ] );

				}

				// Manually Update the Directional Lights
				for ( let l = 0; l < dirLights.length; l ++ ) {

					// Sometimes they will be sampled from the target direction
					// Sometimes they will be uniformly sampled from the upper hemisphere
					if ( Math.random() > params[ 'Ambient Weight' ] ) {

						dirLights[ l ].position.set(
							lightOrigin.position.x + ( Math.random() * params[ 'Light Radius' ] ),
							lightOrigin.position.y + ( Math.random() * params[ 'Light Radius' ] ),
							lightOrigin.position.z + ( Math.random() * params[ 'Light Radius' ] ) );

					} else {

						// Uniform Hemispherical Surface Distribution for Ambient Occlusion
						const lambda = Math.acos( 2 * Math.random() - 1 ) - ( 3.14159 / 2.0 );
						const phi = 2 * 3.14159 * Math.random();
						dirLights[ l ].position.set(
							        ( ( Math.cos( lambda ) * Math.cos( phi ) ) * 300 ) + object.position.x,
							Math.abs( ( Math.cos( lambda ) * Math.sin( phi ) ) * 300 ) + object.position.y + 20,
							          ( Math.sin( lambda ) * 300 ) + object.position.z
						);

					}

				}

				// Render Scene
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_shadowmap_vsm.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - vsm shadows example</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>VSM Shadows</span>
			</div>

			<small>
				VSM Shadows example by <a href="https://github.com/supereggbert">Paul Brunt</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, clock;
			let dirLight, spotLight;
			let torusKnot, dirGroup;

			const config = {
				spotlightRadius: 4,
				spotlightSamples: 8,
				dirlightRadius: 4,
				dirlightSamples: 8,
				animate: true
			};

			init();

			function init() {

				initScene();
				initMisc();

				// Init gui
				const gui = renderer.inspector.createParameters( 'Settings' );

				const spotlightFolder = gui.addFolder( 'Spotlight' );
				spotlightFolder.add( config, 'spotlightRadius', 0, 25 ).name( 'radius' ).onChange( function ( value ) {

					spotLight.shadow.radius = value;

				} );

				spotlightFolder.add( config, 'spotlightSamples', 1, 25, 1 ).name( 'samples' ).onChange( function ( value ) {

					spotLight.shadow.blurSamples = value;

				} );

				const dirlightFolder = gui.addFolder( 'Directional Light' );
				dirlightFolder.add( config, 'dirlightRadius', 0, 25 ).name( 'radius' ).onChange( function ( value ) {

					dirLight.shadow.radius = value;

				} );

				dirlightFolder.add( config, 'dirlightSamples', 1, 25, 1 ).name( 'samples' ).onChange( function ( value ) {

					dirLight.shadow.blurSamples = value;

				} );

				gui.add( config, 'animate' );

				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

			}

			function initScene() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 10, 30 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222244 );
				scene.fog = new THREE.Fog( 0x222244, 50, 100 );

				// Lights

				scene.add( new THREE.AmbientLight( 0x444444 ) );

				spotLight = new THREE.SpotLight( 0xff8888, 400 );
				spotLight.angle = Math.PI / 5;
				spotLight.penumbra = 0.3;
				spotLight.position.set( 8, 10, 5 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 8;
				spotLight.shadow.camera.far = 200;
				spotLight.shadow.mapSize.width = 256;
				spotLight.shadow.mapSize.height = 256;
				spotLight.shadow.bias = - 0.002;
				spotLight.shadow.radius = 4;
				scene.add( spotLight );


				dirLight = new THREE.DirectionalLight( 0x8888ff, 3 );
				dirLight.position.set( 3, 12, 17 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 500;
				dirLight.shadow.camera.right = 17;
				dirLight.shadow.camera.left = - 17;
				dirLight.shadow.camera.top	= 17;
				dirLight.shadow.camera.bottom = - 17;
				dirLight.shadow.mapSize.width = 512;
				dirLight.shadow.mapSize.height = 512;
				dirLight.shadow.radius = 4;
				dirLight.shadow.bias = - 0.0005;

				dirGroup = new THREE.Group();
				dirGroup.add( dirLight );
				scene.add( dirGroup );

				// Geometry

				const geometry = new THREE.TorusKnotGeometry( 25, 8, 75, 20 );
				const material = new THREE.MeshPhongMaterial( {
					color: 0x999999,
					shininess: 0,
					specular: 0x222222
				} );

				torusKnot = new THREE.Mesh( geometry, material );
				torusKnot.scale.multiplyScalar( 1 / 18 );
				torusKnot.position.y = 3;
				torusKnot.castShadow = true;
				torusKnot.receiveShadow = true;
				scene.add( torusKnot );

				const cylinderGeometry = new THREE.CylinderGeometry( 0.75, 0.75, 7, 32 );

				const pillar1 = new THREE.Mesh( cylinderGeometry, material );
				pillar1.position.set( 8, 3.5, 8 );
				pillar1.castShadow = true;
				pillar1.receiveShadow = true;

				const pillar2 = pillar1.clone();
				pillar2.position.set( 8, 3.5, - 8 );
				const pillar3 = pillar1.clone();
				pillar3.position.set( - 8, 3.5, 8 );
				const pillar4 = pillar1.clone();
				pillar4.position.set( - 8, 3.5, - 8 );

				scene.add( pillar1 );
				scene.add( pillar2 );
				scene.add( pillar3 );
				scene.add( pillar4 );

				const planeGeometry = new THREE.PlaneGeometry( 200, 200 );
				const planeMaterial = new THREE.MeshPhongMaterial( {
					color: 0x999999,
					shininess: 0,
					specular: 0x111111
				} );

				const ground = new THREE.Mesh( planeGeometry, planeMaterial );
				ground.rotation.x = - Math.PI / 2;
				ground.scale.multiplyScalar( 3 );
				ground.castShadow = true;
				ground.receiveShadow = true;
				scene.add( ground );

			}

			function initMisc() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.VSMShadowMap;

				// Mouse control
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 2, 0 );
				controls.update();

				clock = new THREE.Clock();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate( time ) {

				const delta = clock.getDelta();

				if ( config.animate === true ) {

					torusKnot.rotation.x += 0.25 * delta;
					torusKnot.rotation.y += 0.5 * delta;
					torusKnot.rotation.z += 1 * delta;

					dirGroup.rotation.y += 0.7 * delta;
					dirLight.position.z = 17 + Math.sin( time * 0.001 ) * 5;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_skinning.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - skinning</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Skinning</span>
			</div>

			<small>
				Basic skinning example using a model from Mixamo.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, screenUV } from 'three/tsl';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;

			let mixer, clock;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.set( 1, 2, 3 );

				scene = new THREE.Scene();
				scene.backgroundNode = screenUV.y.mix( color( 0x66bbff ), color( 0x4466ff ) );
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				//lights

				const light = new THREE.PointLight( 0xffffff, 1, 100 );
				light.power = 2500;
				camera.add( light );
				scene.add( camera );

				const ambient = new THREE.AmbientLight( 0x4466ff, 1 );
				scene.add( ambient );

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					const object = gltf.scene;
					mixer = new THREE.AnimationMixer( object );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					scene.add( object );

				} );

				//renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.LinearToneMapping;
				renderer.toneMappingExposure = 0.4;
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				if ( mixer ) mixer.update( delta );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_skinning_instancing.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - skinning instancing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Skinning Instancing</span>
			</div>

			<small>
				Skinning with multiple instances of the same model.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, mix, range, color, oscSine, time } from 'three/tsl';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;
			let postProcessing;

			let mixer, clock;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 40 );
				camera.position.set( 1, 2, 3 );

				scene = new THREE.Scene();
				camera.lookAt( 0, 1, 0 );

				clock = new THREE.Clock();

				// lights

				const centerLight = new THREE.PointLight( 0xff9900, 1, 100 );
				centerLight.position.y = 4.5;
				centerLight.position.z = - 2;
				centerLight.power = 400;
				scene.add( centerLight );

				const cameraLight = new THREE.PointLight( 0x0099ff, 1, 100 );
				cameraLight.power = 400;
				camera.add( cameraLight );
				scene.add( camera );

				const geometry = new THREE.PlaneGeometry( 1000, 1000 );
				geometry.rotateX( - Math.PI / 2 );

				const plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0x000000, visible: true } ) );
				scene.add( plane );

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					const object = gltf.scene;

					mixer = new THREE.AnimationMixer( object );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					const instanceCount = 30;
					const dummy = new THREE.Object3D();

					object.traverse( ( child ) => {

						if ( child.isMesh ) {

							const oscNode = oscSine( time.mul( .1 ) );

							// random colors between instances from 0x000000 to 0xFFFFFF
							const randomColors = range( new THREE.Color( 0x000000 ), new THREE.Color( 0xFFFFFF ) );

							// random [ 0, 1 ] values between instances
							const randomMetalness = range( 0, 1 );

							child.material = new THREE.MeshStandardNodeMaterial();
							child.material.roughness = .1;
							child.material.metalnessNode = mix( 0.0, randomMetalness, oscNode );
							child.material.colorNode = mix( color( 0xFFFFFF ), randomColors, oscNode );

							child.isInstancedMesh = true;
							child.instanceMatrix = new THREE.InstancedBufferAttribute( new Float32Array( instanceCount * 16 ), 16 );
							child.count = instanceCount;

							for ( let i = 0; i < instanceCount; i ++ ) {

								dummy.position.x = - 200 + ( ( i % 5 ) * 70 );
								dummy.position.y = Math.floor( i / 5 ) * - 200;

								dummy.updateMatrix();

								dummy.matrix.toArray( child.instanceMatrix.array, i * 16 );

							}

						}

					} );

					scene.add( object );

				} );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				// post processing

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode();
				const scenePassDepth = scenePass.getLinearDepthNode().remapClamp( .15, .3 );

				const scenePassColorBlurred = gaussianBlur( scenePassColor );
				scenePassColorBlurred.directionNode = scenePassDepth;

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = scenePassColorBlurred;


				// events

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				if ( mixer ) mixer.update( delta );

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_skinning_points.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - skinning points</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Skinning Points</span>
			</div>

			<small>
				Colors and scale of the points are based on the speed of the animation.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, computeSkinning, objectWorldMatrix, instancedArray, instanceIndex, Fn, shapeCircle } from 'three/tsl';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;
			let mixer, clock;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 300, - 85 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x111111 );
				camera.lookAt( 0, 0, - 85 );

				scene.add( new THREE.AmbientLight( 0xffffff, 10 ) );

				clock = new THREE.Clock();

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Michelle.glb', function ( gltf ) {

					const object = gltf.scene;
					mixer = new THREE.AnimationMixer( object );

					const action = mixer.clipAction( gltf.animations[ 0 ] );
					action.play();

					object.traverse( function ( child ) {

						if ( child.isMesh ) {

							child.visible = false;

							const countOfPoints = child.geometry.getAttribute( 'position' ).count;

							const pointPositionArray = instancedArray( countOfPoints, 'vec3' ).setPBO( true );
							const pointSpeedArray = instancedArray( countOfPoints, 'vec3' ).setPBO( true );

							const pointSpeedAttribute = pointSpeedArray.toAttribute();
							const skinningPosition = computeSkinning( child );

							const materialPoints = new THREE.PointsNodeMaterial();
							materialPoints.colorNode = pointSpeedAttribute.mul( .6 ).mix( color( 0x0066ff ), color( 0xff9000 ) );
							materialPoints.opacityNode = shapeCircle();
							materialPoints.sizeNode = pointSpeedAttribute.length().exp().min( 5 ).mul( 5 ).add( 1 );
							materialPoints.sizeAttenuation = false;

							const updateSkinningPoints = Fn( () => {

								const pointPosition = pointPositionArray.element( instanceIndex );
								const pointSpeed = pointSpeedArray.element( instanceIndex );

								const skinningWorldPosition = objectWorldMatrix( child ).mul( skinningPosition );

								const skinningSpeed = skinningWorldPosition.sub( pointPosition );

								pointSpeed.assign( skinningSpeed );
								pointPosition.assign( skinningWorldPosition );

							}, 'void' );

							materialPoints.positionNode = Fn( () => {

								updateSkinningPoints();

								return pointPositionArray.toAttribute();

							} )().compute( countOfPoints ).onInit( () => {

								// initialize point positions and speeds

								renderer.compute( updateSkinningPoints().compute( countOfPoints ) );

							} );

							const pointCloud = new THREE.Sprite( materialPoints );
							pointCloud.count = countOfPoints;
							scene.add( pointCloud );

						}

					} );

					object.scale.set( 100, 100, 100 );
					object.rotation.x = - Math.PI / 2;

					scene.add( object );

				} );

				//renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				if ( mixer ) mixer.update( delta );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_sky.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - sky</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Sky</span>
			</div>

			<small>
				Sky + Sun shader.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { SkyMesh } from 'three/addons/objects/SkyMesh.js';

			let camera, scene, renderer;

			let sky, sun;

			init();

			function initSky() {

				// Add Sky
				sky = new SkyMesh();
				sky.scale.setScalar( 450000 );
				scene.add( sky );

				sun = new THREE.Vector3();

				/// GUI

				const effectController = {
					turbidity: 10,
					rayleigh: 3,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.7,
					elevation: 2,
					azimuth: 180,
					exposure: renderer.toneMappingExposure
				};

				function guiChanged() {

					sky.turbidity.value = effectController.turbidity;
					sky.rayleigh.value = effectController.rayleigh;
					sky.mieCoefficient.value = effectController.mieCoefficient;
					sky.mieDirectionalG.value = effectController.mieDirectionalG;

					const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
					const theta = THREE.MathUtils.degToRad( effectController.azimuth );

					sun.setFromSphericalCoords( 1, phi, theta );

					sky.sunPosition.value.copy( sun );

					renderer.toneMappingExposure = effectController.exposure;

				}

				const gui = renderer.inspector.createParameters( 'Settings' );

				gui.add( effectController, 'turbidity', 0.0, 20.0, 0.1 ).onChange( guiChanged );
				gui.add( effectController, 'rayleigh', 0.0, 4, 0.001 ).onChange( guiChanged );
				gui.add( effectController, 'mieCoefficient', 0.0, 0.1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, 'mieDirectionalG', 0.0, 1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, 'elevation', 0, 90, 0.1 ).onChange( guiChanged );
				gui.add( effectController, 'azimuth', - 180, 180, 0.1 ).onChange( guiChanged );
				gui.add( effectController, 'exposure', 0, 1, 0.0001 ).onChange( guiChanged );

				guiChanged();

			}

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 100, 2000000 );
				camera.position.set( 0, 100, 2000 );

				scene = new THREE.Scene();

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				//controls.maxPolarAngle = Math.PI / 2;
				controls.enableZoom = false;
				controls.enablePan = false;

				initSky();

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_sprites.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - sprites</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Sprites</span>
			</div>

			<small>
				Example of using a custom SpriteMaterial with nodes.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, uv, userData, fog, rangeFogFactor, color } from 'three/tsl';

			let camera, scene, renderer;

			let map;

			let group;

			let imageWidth = 1, imageHeight = 1;

			init();

			function init() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera = new THREE.PerspectiveCamera( 60, width / height, 1, 2100 );
				camera.position.z = 1500;

				scene = new THREE.Scene();
				scene.fogNode = fog( color( 0x0000ff ), rangeFogFactor( 1500, 2100 ) );

				// create sprites

				const amount = 200;
				const radius = 500;

				const textureLoader = new THREE.TextureLoader();

				map = textureLoader.load( 'textures/sprite1.png', ( map ) => {

					imageWidth = map.image.width;
					imageHeight = map.image.height;

				} );

				group = new THREE.Group();

				const textureNode = texture( map );

				const material = new THREE.SpriteNodeMaterial();
				material.colorNode = textureNode.mul( uv() ).mul( 2 ).saturate();
				material.opacityNode = textureNode.a;
				material.rotationNode = userData( 'rotation', 'float' ); // get value of: sprite.userData.rotation

				for ( let a = 0; a < amount; a ++ ) {

					const x = Math.random() - 0.5;
					const y = Math.random() - 0.5;
					const z = Math.random() - 0.5;

					const sprite = new THREE.Sprite( material );

					sprite.position.set( x, y, z );
					sprite.position.normalize();
					sprite.position.multiplyScalar( radius );

					// individual rotation per sprite
					sprite.userData.rotation = 0;

					group.add( sprite );

				}

				scene.add( group );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				const time = Date.now() / 1000;

				for ( let i = 0, l = group.children.length; i < l; i ++ ) {

					const sprite = group.children[ i ];
					const scale = Math.sin( time + sprite.position.x * 0.01 ) * 0.3 + 1.0;

					sprite.userData.rotation += 0.1 * ( i / l );
					sprite.scale.set( scale * imageWidth, scale * imageHeight, 1.0 );

				}

				group.rotation.x = time * 0.5;
				group.rotation.y = time * 0.75;
				group.rotation.z = time * 1.0;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_storage_buffer.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - storage pbo external element</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br />This example demonstrates fetching an external element from a StorageBuffer.
			<br />The left canvas uses the WebGPU Backend, while the right uses the WebGL Backend.
			<div id="timestamps" style="
				position: absolute;
				top: 60px;
				left: 0;
				padding: 10px;
				background: rgba( 0, 0, 0, 0.5 );
				color: #fff;
				font-family: monospace;
				font-size: 12px;
				line-height: 1.5;
				pointer-events: none;
				text-align: left;
			"></div>
			<div id="timestamps_webgl" style="
			position: absolute;
			top: 60px;
			right: 0;
			padding: 10px;
			background: rgba( 0, 0, 0, 0.5 );
			color: #fff;
			font-family: monospace;
			font-size: 12px;
			line-height: 1.5;
			pointer-events: none;
			text-align: left;
		"></div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { storage, If, vec3, uv, uint, float, Fn, instanceIndex, workgroupBarrier } from 'three/tsl';

			const timestamps = {
				webgpu: document.getElementById( 'timestamps' ),
				webgl: document.getElementById( 'timestamps_webgl' )
			};

			// WebGPU Backend
			init();

			// WebGL Backend
			init( true );

			async function init( forceWebGL = false ) {

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				// texture

				const size = 32; // non power of two buffer size is not well supported in WebGPU
				const barCount = 32;

				const type = [ 'float', 'vec2', 'vec3', 'vec4' ];

				const arrayBufferNodes = [];

				for ( let i = 0; i < type.length; i ++ ) {

					const typeSize = i + 1;
					const array = new Array( size * typeSize ).fill( 0 );

					const arrayBuffer = new THREE.StorageInstancedBufferAttribute( new Float32Array( array ), typeSize );

					arrayBufferNodes.push( storage( arrayBuffer, type[ i ], size ).setPBO( true ) );

				}

				const computeInitOrder = Fn( () => {

					for ( let i = 0; i < type.length; i ++ ) {

						arrayBufferNodes[ i ].element( instanceIndex ).assign( instanceIndex );

					}

				} );

				const computeInvertOrder = Fn( () => {

					for ( let i = 0; i < type.length; i ++ ) {

						const invertIndex = arrayBufferNodes[ i ].element( uint( size - 1 ).sub( instanceIndex ) ).toVar();
						workgroupBarrier();
						arrayBufferNodes[ i ].element( instanceIndex ).assign( invertIndex );

					}

				} );

				// compute

				const computeInit = computeInitOrder().compute( size );

				const compute = computeInvertOrder().compute( size );

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				material.colorNode = Fn( () => {

					const index = uint( uv().x.mul( size ).floor() ).toVar();

					If( index.greaterThanEqual( size ), () => {

						index.assign( uint( size ).sub( 1 ) );

					} );

					const color = vec3( 0, 0, 0 ).toVar();

					If( uv().y.greaterThan( 0.0 ), () => {

						const indexValue = arrayBufferNodes[ 0 ].element( index ).toVar();
						const value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );
			
						color.assign( vec3( value, 0, 0 ) );

					} );

					If( uv().y.greaterThan( 0.25 ), () => {

						const indexValue = arrayBufferNodes[ 1 ].element( index ).toVar();
						const value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );
			
						color.assign( vec3( 0, value, 0 ) );

					} );

					If( uv().y.greaterThan( 0.5 ), () => {

						const indexValue = arrayBufferNodes[ 2 ].element( index ).toVar();
						const value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );
			
						color.assign( vec3( 0, 0, value ) );

					} );

					If( uv().y.greaterThan( 0.75 ), () => {

						const indexValue = arrayBufferNodes[ 3 ].element( index ).toVar();
						const value = float( indexValue ).div( float( size ) ).mul( barCount ).floor().div( barCount );
			
						color.assign( vec3( value, value, value ) );

					} );

					return color;

				} )();
			
				//

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				const renderer = new THREE.WebGPURenderer( { antialias: false, forceWebGL: forceWebGL, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				await renderer.init();

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( forceWebGL ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );
			
				} else {

					scene.background = new THREE.Color( 0x313131 );

				}


				renderer.compute( computeInit );

				//

				renderer.info.autoReset = false;

				 const stepAnimation = async function () {

					renderer.info.reset();

					renderer.compute( compute );
					renderer.render( scene, camera );

					renderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );
					renderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );

					timestamps[ forceWebGL ? 'webgl' : 'webgpu' ].innerHTML = `

							Compute ${renderer.info.compute.frameCalls} pass in ${renderer.info.compute.timestamp.toFixed( 6 )}ms<br>
							Draw ${renderer.info.render.drawCalls} pass in ${renderer.info.render.timestamp.toFixed( 6 )}ms`;

					setTimeout( stepAnimation, 1000 );
			
				};

				stepAnimation();

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_struct_drawindirect.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - struct drawIndirect</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Draw Indirect</span>
			</div>

			<small>
				Struct drawIndirect example.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { struct, storage, wgslFn, instanceIndex, time, varyingProperty, attribute } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}


			const renderer = new THREE.WebGPURenderer( { antialias: true } );
			renderer.outputColorSpace = THREE.SRGBColorSpace;
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0x000000 );
			renderer.setClearAlpha( 0 );
			document.body.appendChild( renderer.domElement );

			const aspect = window.innerWidth / window.innerHeight;

			const camera = new THREE.PerspectiveCamera( 50.0, aspect, 0.1, 10000 );
			const scene = new THREE.Scene();

			scene.background = new THREE.Color( 0x00001f );
			camera.position.set( 1, 1, 1 );
			const controls = new OrbitControls( camera, renderer.domElement );

			let computeDrawBuffer, computeInitDrawBuffer;

			init();

			async function init() {

				await renderer.init();

				// geometry

				const vector = new THREE.Vector4();

				const instances = 100000;

				const positions = [];
				const offsets = [];
				const colors = [];
				const orientationsStart = [];
				const orientationsEnd = [];

				positions.push( 0.025, - 0.025, 0 );
				positions.push( - 0.025, 0.025, 0 );
				positions.push( 0, 0, 0.025 );

				// instanced attributes

				for ( let i = 0; i < instances; i ++ ) {

					// offsets

					offsets.push( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 );

					// colors

					colors.push( Math.random(), Math.random(), Math.random(), Math.random() );

					// orientation start

					vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
					vector.normalize();

					orientationsStart.push( vector.x, vector.y, vector.z, vector.w );

					// orientation end

					vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
					vector.normalize();

					orientationsEnd.push( vector.x, vector.y, vector.z, vector.w );

				}

				const geometry = new THREE.InstancedBufferGeometry();
				geometry.instanceCount = instances;

				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );
				geometry.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );
				geometry.setAttribute( 'orientationStart', new THREE.InstancedBufferAttribute( new Float32Array( orientationsStart ), 4 ) );
				geometry.setAttribute( 'orientationEnd', new THREE.InstancedBufferAttribute( new Float32Array( orientationsEnd ), 4 ) );

				const drawBuffer = new THREE.IndirectStorageBufferAttribute( new Uint32Array( 5 ), 5 );
				geometry.setIndirect( drawBuffer );

				const drawBufferStruct = struct( {
					vertexCount: 'uint',
					instanceCount: { type: 'uint', atomic: true },
					firstVertex: 'uint',
					firstInstance: 'uint',
					offset: 'uint'
				}, 'DrawBuffer' );

				const writeDrawBuffer = wgslFn( `
					fn compute(
						index: u32,
						drawBuffer: ptr<storage, DrawBuffer, read_write>,
						instances: f32,
						time: f32,
					) -> void {

						let instanceCount = max( instances * pow( sin( time * 0.5 ) + 1, 4.0 ), 100 );

						atomicStore( &drawBuffer.instanceCount, u32( instanceCount ) );
					}
				` );

				computeDrawBuffer = writeDrawBuffer( {
					drawBuffer: storage( drawBuffer, drawBufferStruct, drawBuffer.count ),
					instances: instances,
					index: instanceIndex,
					time: time
				} ).compute( instances ); // not necessary in this case but normally one wants to run through all instances

				const initDrawBuffer = wgslFn( `
					fn compute(
						drawBuffer: ptr< storage, DrawBuffer, read_write >,
					) -> void {

						drawBuffer.vertexCount = 3u;
						atomicStore(&drawBuffer.instanceCount, 0u);
						drawBuffer.firstVertex = 0u;
						drawBuffer.firstInstance = 0u;
						drawBuffer.offset = 0u;
					}
				` );

				computeInitDrawBuffer = initDrawBuffer( {
					drawBuffer: storage( drawBuffer, drawBufferStruct, drawBuffer.count ),
  				} ).compute( 1 );

  				const vPosition = varyingProperty( 'vec3', 'vPosition' );
  				const vColor = varyingProperty( 'vec4', 'vColor' );

  				const positionShaderParams = {
					position: attribute( 'position' ),
					offset: attribute( 'offset' ),
					color: attribute( 'color' ),
					orientationStart: attribute( 'orientationStart' ),
					orientationEnd: attribute( 'orientationEnd' ),
					time: time
				};

				const positionShader = wgslFn( `
					fn main_vertex(
						position: vec3<f32>,
						offset: vec3<f32>,
						color: vec4<f32>,
						orientationStart: vec4<f32>,
						orientationEnd: vec4<f32>,
						time: f32
					) -> vec4<f32> {

						var vPosition = offset * max( abs( sin( time * 0.5 ) * 2.0 + 1.0 ), 0.5 ) + position;
						var orientation = normalize( mix( orientationStart, orientationEnd, sin( time * 0.5 ) ) );
						var vcV = cross( orientation.xyz, vPosition );
						vPosition = vcV * ( 2.0 * orientation.w ) + ( cross( orientation.xyz, vcV ) * 2.0 + vPosition );

						var vColor = color;

						var outPosition = vec4f(vPosition, 1);

						varyings.vPosition = vPosition;
						varyings.vColor = vColor;

						return outPosition;
					}
				`, [ vPosition, vColor ] );

				const fragmentShaderParams = {
					time: time,
					vPosition: vPosition,
					vColor: vColor
				};

				const fragmentShader = wgslFn( `
					fn main_fragment(
						time: f32,
						vPosition: vec3<f32>,
						vColor: vec4<f32>
					) -> vec4<f32> {

						var color = vec4f( vColor );
						color.r += sin( vPosition.x * 10.0 + time ) * 0.5;

						return color;
					}
				` );

				const material = new THREE.MeshBasicNodeMaterial( {
					side: THREE.DoubleSide,
					forceSinglePass: true,
					transparent: true
				} );

				material.positionNode = positionShader( positionShaderParams );
				material.fragmentNode = fragmentShader( fragmentShaderParams );

				const mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer.setAnimationLoop( render );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function render() {

				controls.update();

				renderer.render( scene, camera );

				renderer.compute( computeInitDrawBuffer );
				renderer.compute( computeDrawBuffer );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_texturegrad.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - texture gradient</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Texture Gradient</span>
			</div>

			<small>
				This example demonstrate texture gradient
				<br /> Left canvas is using WebGPU Backend, right canvas is WebGL Backend.
				<br /> The bottom half of the texture benefits from the gradient to achieve better blur quality.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { If, vec4, float, time, cos, pow, vec2, uv, texture, Fn } from 'three/tsl';

			// WebGPU Backend
			init();

			// WebGL Backend
			init( true );

			async function init( forceWebGL = false ) {

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect );
				camera.position.z = 2;

				const scene = new THREE.Scene();

				// texture

				const material = new THREE.MeshBasicNodeMaterial( { color: 0xffffff } );

				// load async brick_diffuse
				const map = await new THREE.TextureLoader().loadAsync( 'textures/uv_grid_opengl.jpg' );

				material.colorNode = Fn( () => {

					const color = vec4( 1. ).toVar();

					const vuv = uv().toVar();
					const blur = pow( float( 0.0625 ).sub( cos( vuv.x.mul( 20.0 ).add( time ) ) ).mul( 0.0625 ), 2.0 );

					const grad = vec2( blur ).toVar();

					If( vuv.y.greaterThan( 0.5 ), () => {

						grad.assign( 0 );
			
					} );

					color.assign(
						texture( map, vuv.add( vec2( blur, blur ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 )
							.add( texture( map, vuv.add( vec2( blur, blur.negate() ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 ) )
							.add( texture( map, vuv.add( vec2( blur.negate(), blur ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 ) )
							.add( texture( map, vuv.add( vec2( blur.negate(), blur.negate() ).mul( 0.5 ) ) ).grad( grad, grad ).mul( 0.25 ) )
					);


					If( vuv.y.greaterThan( 0.497 ).and( vuv.y.lessThan( 0.503 ) ), () => {

						color.assign( 1 );

					} );
			

					return color;

				} )();
			
				//

				const box = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( box );

				const renderer = new THREE.WebGPURenderer( { antialias: false, forceWebGL: forceWebGL } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );
				renderer.setAnimationLoop( animate );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( forceWebGL ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );
			
				} else {

					scene.background = new THREE.Color( 0x313131 );

				}

				//

				function animate() {

					renderer.render( scene, camera );
			
				}

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_textures_2d-array.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - 2d texture array</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>2D Texture Array</span>
			</div>

			<small>
				Scanned head data by
				<a href="https://www.codeproject.com/Articles/352270/Getting-started-with-Volume-Rendering" target="_blank" rel="noopener">Divine Augustine</a> licensed under <a href="https://www.codeproject.com/info/cpol10.aspx" target="_blank" rel="noopener">CPOL</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { texture, uv, time, oscTriangle } from 'three/tsl';

			import { unzipSync } from 'three/addons/libs/fflate.module.js';

			//

			let camera, scene, mesh, renderer;

			const planeWidth = 50;
			const planeHeight = 50;

			init();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );
				camera.position.z = 70;

				scene = new THREE.Scene();

				// width 256, height 256, depth 109, 8-bit, zip archived raw data

				new THREE.FileLoader()
					.setResponseType( 'arraybuffer' )
					.load( 'textures/3d/head256x256x109.zip', function ( data ) {

						const zip = unzipSync( new Uint8Array( data ) );
						const array = new Uint8Array( zip[ 'head256x256x109' ].buffer );

						const map = new THREE.DataArrayTexture( array, 256, 256, 109 );
						map.format = THREE.RedFormat;
						map.needsUpdate = true;

						let coord = uv();
						coord = coord.setY( coord.y.oneMinus() ); // flip y

						let oscLayers = oscTriangle( time.mul( .5 ) ); // [ /\/ ] triangle osc animation
						oscLayers = oscLayers.add( 1 ).mul( .5 ); // convert osc range of [ -1, 1 ] to [ 0, 1 ]
						oscLayers = oscLayers.mul( map.image.depth ); // scale osc range to texture depth

						const material = new THREE.MeshBasicNodeMaterial();
						material.colorNode = texture( map, coord ).depth( oscLayers ).r.remap( 0, 1, - .1, 1.8 ); // remap to make it more visible

						const geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );

						mesh = new THREE.Mesh( geometry, material );

						scene.add( mesh );

					} );

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_textures_2d-array_compressed.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - 2D compressed texture array</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Texture Gradient</span>
			</div>

			<small>
				Loop from the movie Spirited away
				by the <a href="https://www.ghibli.jp/" target="_blank" rel="noopener">Studio Ghibli</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { texture, uniform, uv } from 'three/tsl';

			import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';

			//

			let camera, scene, mesh, renderer, clock;

			const depth = uniform( 0 );

			const planeWidth = 50;
			const planeHeight = 25;

			let depthStep = 1;

			init();

			async function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );
				camera.position.z = 70;

				scene = new THREE.Scene();

				//
				clock = new THREE.Clock();

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				await renderer.init();

				//

				const ktx2Loader = new KTX2Loader();
				ktx2Loader.setTranscoderPath( 'jsm/libs/basis/' );
				ktx2Loader.detectSupport( renderer );

				ktx2Loader.load( 'textures/spiritedaway.ktx2', function ( texturearray ) {

					const material = new THREE.NodeMaterial();

					material.colorNode = texture( texturearray, uv().flipY() ).depth( depth );
					const geometry = new THREE.PlaneGeometry( planeWidth, planeHeight );

					mesh = new THREE.Mesh( geometry, material );

					scene.add( mesh );

				} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				if ( mesh ) {

					const delta = clock.getDelta() * 10;

					depthStep += delta;

					const value = depthStep % 5;

					depth.value = value;

				}

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_textures_anisotropy.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - anisotropic texture filtering</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			body {
				color: #444;
				background-color: #f1f1f1;
			}
			a {
				color: #08f;
			}

			.lbl {
				color: #fff;
				font-size: 16px;
				font-weight: bold;
				position: absolute;
				bottom: 0px;
				z-index: 100;
				text-shadow: #000 1px 1px 1px;
				background-color: rgba(0,0,0,0.85);
				padding: 1em;
			}

			#lbl_left {
				text-align:left;
				left:0px;
			}

			#lbl_right {
				text-align:left;
				right:0px
			}

			.g { color:#aaa }
			.c { color:#fa0 }
		</style>
	</head>

	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Anisotropic Texture Filtering</span>
			</div>

			<small>
				Anisotropic texture filtering example.
			</small>
		</div>

		<div id="lbl_left" class="lbl">
		anisotropy: <span class="c" id="val_left"></span><br/>
		</div>

		<div id="lbl_right" class="lbl">
		anisotropy: <span class="c" id="val_right"></span><br/>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			let container;

			let camera, scene1, scene2, renderer;

			let mouseX = 0, mouseY = 0;

			init();

			function init() {

				const SCREEN_WIDTH = window.innerWidth;
				const SCREEN_HEIGHT = window.innerHeight;

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );

				// RENDERER

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.setAnimationLoop( render );
				renderer.autoClear = false;

				renderer.domElement.style.position = 'relative';
				container.appendChild( renderer.domElement );

				//

				camera = new THREE.PerspectiveCamera( 35, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 25000 );
				camera.position.z = 1500;

				scene1 = new THREE.Scene();
				scene1.fog = new THREE.Fog( 0xf2f7ff, 1, 25000 );

				scene2 = new THREE.Scene();
				scene2.fog = new THREE.Fog( 0xf2f7ff, 1, 25000 );

				scene1.add( new THREE.AmbientLight( 0xeef0ff, 3 ) );
				scene2.add( new THREE.AmbientLight( 0xeef0ff, 3 ) );

				const light1 = new THREE.DirectionalLight( 0xffffff, 6 );
				light1.position.set( 1, 1, 1 );
				scene1.add( light1 );

				const light2 = new THREE.DirectionalLight( 0xffffff, 6 );
				light2.position.set( 1, 1, 1 );
				scene2.add( light2 );

				// GROUND

				const textureLoader = new THREE.TextureLoader();

				const maxAnisotropy = renderer.getMaxAnisotropy();

				const texture1 = textureLoader.load( 'textures/crate.gif' );
				const material1 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture1 } );

				texture1.colorSpace = THREE.SRGBColorSpace;
				texture1.anisotropy = renderer.getMaxAnisotropy();
				texture1.wrapS = texture1.wrapT = THREE.RepeatWrapping;
				texture1.repeat.set( 512, 512 );

				const texture2 = textureLoader.load( 'textures/crate.gif' );
				const material2 = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture2 } );

				texture2.colorSpace = THREE.SRGBColorSpace;
				texture2.anisotropy = 1;
				texture2.wrapS = texture2.wrapT = THREE.RepeatWrapping;
				texture2.repeat.set( 512, 512 );

				if ( maxAnisotropy > 0 ) {

					document.getElementById( 'val_left' ).innerHTML = texture1.anisotropy;
					document.getElementById( 'val_right' ).innerHTML = texture2.anisotropy;

				} else {

					document.getElementById( 'val_left' ).innerHTML = 'not supported';
					document.getElementById( 'val_right' ).innerHTML = 'not supported';

				}

				//

				const geometry = new THREE.PlaneGeometry( 100, 100 );

				const mesh1 = new THREE.Mesh( geometry, material1 );
				mesh1.rotation.x = - Math.PI / 2;
				mesh1.scale.set( 1000, 1000, 1000 );

				const mesh2 = new THREE.Mesh( geometry, material2 );
				mesh2.rotation.x = - Math.PI / 2;
				mesh2.scale.set( 1000, 1000, 1000 );

				scene1.add( mesh1 );
				scene2.add( mesh2 );

				//

				document.addEventListener( 'mousemove', onDocumentMouseMove );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				const windowHalfX = window.innerWidth / 2;
				const windowHalfY = window.innerHeight / 2;

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );

			}

			function render() {

				const SCREEN_WIDTH = window.innerWidth;
				const SCREEN_HEIGHT = window.innerHeight;

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y = THREE.MathUtils.clamp( camera.position.y + ( - ( mouseY - 200 ) - camera.position.y ) * .05, 50, 1000 );

				camera.lookAt( scene1.position );
				renderer.clear();

				renderer.setScissorTest( true );

				renderer.setScissor( 0, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );
				renderer.render( scene1, camera );

				renderer.setScissorTest( true );

				renderer.setScissor( SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2 - 2, SCREEN_HEIGHT );
				renderer.render( scene2, camera );

				renderer.setScissorTest( false );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_textures_partialupdate.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - webgpu partial texture update</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Partial Texture Update</span>
			</div>

			<small>
				Replace parts of an existing texture with all data of another texture.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			let camera, scene, renderer, clock, dataTexture, diffuseMap;

			let last = 0;
			const position = new THREE.Vector2();
			const color = new THREE.Color();

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.z = 2;

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				const loader = new THREE.TextureLoader();
				diffuseMap = loader.load( 'textures/carbon/Carbon.png' );
				diffuseMap.colorSpace = THREE.SRGBColorSpace;
				diffuseMap.minFilter = THREE.LinearFilter;
				diffuseMap.generateMipmaps = false;

				const geometry = new THREE.PlaneGeometry( 2, 2 );
				const material = new THREE.MeshBasicMaterial( { map: diffuseMap } );

				const mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				//

				const width = 32;
				const height = 32;

				const data = new Uint8Array( width * height * 4 );
				dataTexture = new THREE.DataTexture( data, width, height );

				//

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const elapsedTime = clock.getElapsedTime();


				renderer.render( scene, camera );


				if ( elapsedTime - last > 0.1 ) {

					last = elapsedTime;

					position.x = ( 32 * THREE.MathUtils.randInt( 1, 16 ) ) - 32;
					position.y = ( 32 * THREE.MathUtils.randInt( 1, 16 ) ) - 32;

					// generate new color data
					updateDataTexture( dataTexture );

					// perform copy from src to dest texture to a random position

					renderer.copyTextureToTexture( dataTexture, diffuseMap, null, position );

				}

			}

			function updateDataTexture( texture ) {

				const size = texture.image.width * texture.image.height;
				const data = texture.image.data;

				// generate a random color and update texture data

				color.setHex( Math.random() * 0xffffff );

				const r = Math.floor( color.r * 255 );
				const g = Math.floor( color.g * 255 );
				const b = Math.floor( color.b * 255 );

				for ( let i = 0; i < size; i ++ ) {

					const stride = i * 4;

					data[ stride ] = r;
					data[ stride + 1 ] = g;
					data[ stride + 2 ] = b;
					data[ stride + 3 ] = 1;

				}

				texture.needsUpdate = true;

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tonemapping.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - tone mapping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Shadow Map</span>
			</div>

			<small>
				Venice Mask by
				<a href="https://sketchfab.com/D.art" target="_blank" rel="noopener">DailyArt</a> is licensed under <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC Attribution-NonCommercial</a><br />
				<a href="https://hdrihaven.com/hdri/?h=venice_sunset" target="_blank" rel="noopener">Venice Sunset</a> from <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			let renderer, scene, camera, controls;
			let gui;

			const params = {
				exposure: 1.0,
				toneMapping: 'Neutral',
				blurriness: 0.3,
				intensity: 1.0,
			};

			const toneMappingOptions = {
				None: THREE.NoToneMapping,
				Linear: THREE.LinearToneMapping,
				Reinhard: THREE.ReinhardToneMapping,
				Cineon: THREE.CineonToneMapping,
				ACESFilmic: THREE.ACESFilmicToneMapping,
				AgX: THREE.AgXToneMapping,
				Neutral: THREE.NeutralToneMapping
			};

			init().catch( function ( err ) {

				console.error( err );

			} );

			async function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				renderer.toneMapping = toneMappingOptions[ params.toneMapping ];
				renderer.toneMappingExposure = params.exposure;

				scene = new THREE.Scene();
				scene.backgroundBlurriness = params.blurriness;

				const light = new THREE.DirectionalLight( 0xfff3ee, 3 ); // simulate sun
				light.position.set( 1, 0.05, 0.7 );
				scene.add( light );

				// scene.add( new THREE.DirectionalLightHelper( light, 1, 0x000000 ) );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( - 0.02, 0.03, 0.05 );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enablePan = false;
				controls.enableDamping = true;
				controls.minDistance = 0.03;
				controls.maxDistance = 0.2;
				controls.target.set( 0, 0.03, 0 );
				controls.update();

				const hdrLoader = new HDRLoader()
					.setPath( 'textures/equirectangular/' );

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

				const gltfLoader = new GLTFLoader();
				gltfLoader.setDRACOLoader( dracoLoader );
				gltfLoader.setPath( 'models/gltf/' );

				const [ texture, gltf ] = await Promise.all( [
					hdrLoader.loadAsync( 'venice_sunset_1k.hdr' ),
					gltfLoader.loadAsync( 'venice_mask.glb' ),
				] );

				// environment

				texture.mapping = THREE.EquirectangularReflectionMapping;

				scene.background = texture;
				scene.environment = texture;

				// model

				scene.add( gltf.scene );

				window.addEventListener( 'resize', onWindowResize );

				//

				gui = renderer.inspector.createParameters( 'Settings' );
				const toneMappingFolder = gui.addFolder( 'Tone Mapping' );

				toneMappingFolder.add( params, 'toneMapping', Object.keys( toneMappingOptions ) )

					.name( 'type' )
					.onChange( function () {

						renderer.toneMapping = toneMappingOptions[ params.toneMapping ];

					} );

				toneMappingFolder.add( params, 'exposure', 0, 2 )

					.onChange( function ( value ) {

						renderer.toneMappingExposure = value;

					} );

				const backgroundFolder = gui.addFolder( 'Background' );

				backgroundFolder.add( params, 'blurriness', 0, 1 )

					.onChange( function ( value ) {

						scene.backgroundBlurriness = value;

					} );

				backgroundFolder.add( params, 'intensity', 0, 1 )

					.onChange( function ( value ) {

						scene.backgroundIntensity = value;

					} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_angular_slicing.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - angular slicing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Angular Slicing</span>
			</div>

			<small>
				Based on <a href="https://threejs-journey.com/lessons/sliced-model-shader" target="_blank" rel="noopener">Three.js Journey</a> lesson.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { If, TWO_PI, atan, color, frontFacing, output, positionLocal, Fn, uniform, vec4 } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( - 5, 5, 12 );

				scene = new THREE.Scene();

				// environment

				const hdrLoader = new HDRLoader();
				hdrLoader.load( './textures/equirectangular/royal_esplanade_1k.hdr', ( environmentMap ) => {

					environmentMap.mapping = THREE.EquirectangularReflectionMapping;

					scene.background = environmentMap;
					scene.environment = environmentMap;

				} );

				// lights

				const directionalLight = new THREE.DirectionalLight( '#ffffff', 4 );
				directionalLight.position.set( 6.25, 3, 4 );
				directionalLight.castShadow = true;
				directionalLight.shadow.mapSize.set( 2048, 2048 );
				directionalLight.shadow.camera.near = 0.1;
				directionalLight.shadow.camera.far = 30;
				directionalLight.shadow.camera.top = 8;
				directionalLight.shadow.camera.right = 8;
				directionalLight.shadow.camera.bottom = - 8;
				directionalLight.shadow.camera.left = - 8;
				directionalLight.shadow.normalBias = 0.05;
				scene.add( directionalLight );

				// TSL functions
			
				const inAngle = Fn( ( [ position, angleStart, angleArc ] ) => {

					const angle = atan( position.y, position.x ).sub( angleStart ).mod( TWO_PI ).toVar();
					return angle.greaterThan( 0 ).and( angle.lessThan( angleArc ) );

				} );

				// materials

				const defaultMaterial = new THREE.MeshPhysicalNodeMaterial( {
					metalness: 0.5,
					roughness: 0.25,
					envMapIntensity: 0.5,
					color: '#858080'
				} );

				const slicedMaterial = new THREE.MeshPhysicalNodeMaterial( {
					metalness: 0.5,
					roughness: 0.25,
					envMapIntensity: 0.5,
					color: '#858080',
					side: THREE.DoubleSide
				} );

				// uniforms

				const sliceStart = uniform( 1.75 );
				const sliceArc = uniform( 1.25 );
				const sliceColor = uniform( color( '#b62f58' ) );

				// output

				slicedMaterial.outputNode = Fn( () => {

					// discard

					inAngle( positionLocal.xy, sliceStart, sliceArc ).discard();

					// backface color

					const finalOutput = output;
					If( frontFacing.not(), () => {

						finalOutput.assign( vec4( sliceColor, 1 ) );
			
					} );
			
					return finalOutput;
			
				} )();

				// shadow

				slicedMaterial.castShadowNode = Fn( () => {

					// discard

					inAngle( positionLocal.xy, sliceStart, sliceArc ).discard();

					return vec4( 0, 0, 0, 1 );
			
				} )();

				// model

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/' );

				const gltfLoader = new GLTFLoader();
				gltfLoader.setDRACOLoader( dracoLoader );

				gltfLoader.load( './models/gltf/gears.glb', ( gltf ) => {

					const model = gltf.scene;

					model.traverse( ( child ) => {

						if ( child.isMesh ) {

							if ( child.name === 'outerHull' )
								child.material = slicedMaterial;
							else
								child.material = defaultMaterial;

							child.castShadow = true;
							child.receiveShadow = true;
			
						}

					} );

					scene.add( model );
			
				} );

				// plane

				const plane = new THREE.Mesh(
					new THREE.PlaneGeometry( 10, 10, 10 ),
					new THREE.MeshStandardMaterial( { color: '#aaaaaa' } )
				);
				plane.receiveShadow = true;
				plane.position.set( - 4, - 3, - 4 );
				plane.lookAt( new THREE.Vector3( 0, 0, 0 ) );
				scene.add( plane );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				// events

				window.addEventListener( 'resize', onWindowResize );

				// debug

				const gui = renderer.inspector.createParameters( 'Parameters' );
				gui.add( sliceStart, 'value', - Math.PI, Math.PI, 0.001 ).name( 'sliceStart' );
				gui.add( sliceArc, 'value', 0, Math.PI * 2, 0.001 ).name( 'sliceArc' );
				gui.addColor( { color: sliceColor.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).onChange( value => sliceColor.value.set( value ) );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {
			
				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_compute_attractors_particles.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - attractors particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Attractors Particles</span>
			</div>

			<small>
				Compute Attractors Particles.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { float, If, PI, color, cos, instanceIndex, Loop, mix, mod, sin, instancedArray, Fn, uint, uniform, uniformArray, hash, vec3, vec4 } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { TransformControls } from 'three/addons/controls/TransformControls.js';

			let camera, scene, renderer, controls, updateCompute;

			init();

			async function init() {

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 3, 5, 8 );

				scene = new THREE.Scene();

				// ambient light

				const ambientLight = new THREE.AmbientLight( '#ffffff', 0.5 );
				scene.add( ambientLight );

				// directional light

				const directionalLight = new THREE.DirectionalLight( '#ffffff', 1.5 );
				directionalLight.position.set( 4, 2, 0 );
				scene.add( directionalLight );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.setClearColor( '#000000' );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				window.addEventListener( 'resize', onWindowResize );

				// attractors

				const attractorsPositions = uniformArray( [
					new THREE.Vector3( - 1, 0, 0 ),
					new THREE.Vector3( 1, 0, - 0.5 ),
					new THREE.Vector3( 0, 0.5, 1 )
				] );
				const attractorsRotationAxes = uniformArray( [
					new THREE.Vector3( 0, 1, 0 ),
					new THREE.Vector3( 0, 1, 0 ),
					new THREE.Vector3( 1, 0, - 0.5 ).normalize()
				] );
				const attractorsLength = uniform( attractorsPositions.array.length, 'uint' );
				const attractors = [];
				const helpersRingGeometry = new THREE.RingGeometry( 1, 1.02, 32, 1, 0, Math.PI * 1.5 );
				const helpersArrowGeometry = new THREE.ConeGeometry( 0.1, 0.4, 12, 1, false );
				const helpersMaterial = new THREE.MeshBasicMaterial( { side: THREE.DoubleSide } );

				for ( let i = 0; i < attractorsPositions.array.length; i ++ ) {

					const attractor = {};

					attractor.position = attractorsPositions.array[ i ];
					attractor.orientation = attractorsRotationAxes.array[ i ];
					attractor.reference = new THREE.Object3D();
					attractor.reference.position.copy( attractor.position );
					attractor.reference.quaternion.setFromUnitVectors( new THREE.Vector3( 0, 1, 0 ), attractor.orientation );
					scene.add( attractor.reference );

					attractor.helper = new THREE.Group();
					attractor.helper.scale.setScalar( 0.325 );
					attractor.reference.add( attractor.helper );

					attractor.ring = new THREE.Mesh( helpersRingGeometry, helpersMaterial );
					attractor.ring.rotation.x = - Math.PI * 0.5;
					attractor.helper.add( attractor.ring );

					attractor.arrow = new THREE.Mesh( helpersArrowGeometry, helpersMaterial );
					attractor.arrow.position.x = 1;
					attractor.arrow.position.z = 0.2;
					attractor.arrow.rotation.x = Math.PI * 0.5;
					attractor.helper.add( attractor.arrow );

					attractor.controls = new TransformControls( camera, renderer.domElement );
					attractor.controls.mode = 'rotate';
					attractor.controls.size = 0.5;
					attractor.controls.attach( attractor.reference );
					attractor.controls.visible = true;
					attractor.controls.enabled = attractor.controls.visible;
					scene.add( attractor.controls.getHelper() );

					attractor.controls.addEventListener( 'dragging-changed', ( event ) => {

						controls.enabled = ! event.value;

					} );

					attractor.controls.addEventListener( 'change', () => {

						attractor.position.copy( attractor.reference.position );
						attractor.orientation.copy( new THREE.Vector3( 0, 1, 0 ).applyQuaternion( attractor.reference.quaternion ) );

					} );

					attractors.push( attractor );

				}

				// particles

				const count = Math.pow( 2, 18 );
				const material = new THREE.SpriteNodeMaterial( { blending: THREE.AdditiveBlending, depthWrite: false } );

				const attractorMass = uniform( Number( `1e${7}` ) );
				const particleGlobalMass = uniform( Number( `1e${4}` ) );
				const timeScale = uniform( 1 );
				const spinningStrength = uniform( 2.75 );
				const maxSpeed = uniform( 8 );
				const gravityConstant = 6.67e-11;
				const velocityDamping = uniform( 0.1 );
				const scale = uniform( 0.008 );
				const boundHalfExtent = uniform( 8 );
				const colorA = uniform( color( '#5900ff' ) );
				const colorB = uniform( color( '#ffa575' ) );

				const positionBuffer = instancedArray( count, 'vec3' );
				const velocityBuffer = instancedArray( count, 'vec3' );

				const sphericalToVec3 = Fn( ( [ phi, theta ] ) => {

					const sinPhiRadius = sin( phi );

					return vec3(
						sinPhiRadius.mul( sin( theta ) ),
						cos( phi ),
						sinPhiRadius.mul( cos( theta ) )
					);

				} );

				// init compute

				const init = Fn( () => {

					const position = positionBuffer.element( instanceIndex );
					const velocity = velocityBuffer.element( instanceIndex );

					const basePosition = vec3(
						hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ),
						hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ),
						hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) )
					).sub( 0.5 ).mul( vec3( 5, 0.2, 5 ) );
					position.assign( basePosition );

					const phi = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).mul( PI ).mul( 2 );
					const theta = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).mul( PI );
					const baseVelocity = sphericalToVec3( phi, theta ).mul( 0.05 );
					velocity.assign( baseVelocity );

				} );

				const initCompute = init().compute( count );

				const reset = () => {

					renderer.compute( initCompute );

				};

				reset();

				// update compute

				const particleMassMultiplier = hash( instanceIndex.add( uint( Math.random() * 0xffffff ) ) ).remap( 0.25, 1 ).toVar();
				const particleMass = particleMassMultiplier.mul( particleGlobalMass ).toVar();

				const update = Fn( () => {

					// const delta = timerDelta().mul( timeScale ).min( 1 / 30 ).toVar();
					const delta = float( 1 / 60 ).mul( timeScale ).toVar(); // uses fixed delta to consistent result
					const position = positionBuffer.element( instanceIndex );
					const velocity = velocityBuffer.element( instanceIndex );

					// force

					const force = vec3( 0 ).toVar();

					Loop( attractorsLength, ( { i } ) => {

						const attractorPosition = attractorsPositions.element( i );
						const attractorRotationAxis = attractorsRotationAxes.element( i );
						const toAttractor = attractorPosition.sub( position );
						const distance = toAttractor.length();
						const direction = toAttractor.normalize();

						// gravity
						const gravityStrength = attractorMass.mul( particleMass ).mul( gravityConstant ).div( distance.pow( 2 ) ).toVar();
						const gravityForce = direction.mul( gravityStrength );
						force.addAssign( gravityForce );

						// spinning
						const spinningForce = attractorRotationAxis.mul( gravityStrength ).mul( spinningStrength );
						const spinningVelocity = spinningForce.cross( toAttractor );
						force.addAssign( spinningVelocity );

					} );

					// velocity

					velocity.addAssign( force.mul( delta ) );
					const speed = velocity.length();
					If( speed.greaterThan( maxSpeed ), () => {

						velocity.assign( velocity.normalize().mul( maxSpeed ) );

					} );
					velocity.mulAssign( velocityDamping.oneMinus() );

					// position

					position.addAssign( velocity.mul( delta ) );

					// box loop

					const halfHalfExtent = boundHalfExtent.div( 2 ).toVar();
					position.assign( mod( position.add( halfHalfExtent ), boundHalfExtent ).sub( halfHalfExtent ) );

				} );
				updateCompute = update().compute( count ).setName( 'Update Particles' );

				// nodes

				material.positionNode = positionBuffer.toAttribute();

				material.colorNode = Fn( () => {

					const velocity = velocityBuffer.toAttribute();
					const speed = velocity.length();
					const colorMix = speed.div( maxSpeed ).smoothstep( 0, 0.5 );
					const finalColor = mix( colorA, colorB, colorMix );

					return vec4( finalColor, 1 );

				} )();

				material.scaleNode = particleMassMultiplier.mul( scale );

				// mesh

				const geometry = new THREE.PlaneGeometry( 1, 1 );
				const mesh = new THREE.InstancedMesh( geometry, material, count );
				scene.add( mesh );

				// debug

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.add( { attractorMassExponent: attractorMass.value.toString().length - 1 }, 'attractorMassExponent', 1, 10, 1 ).onChange( value => attractorMass.value = Number( `1e${value}` ) );
				gui.add( { particleGlobalMassExponent: particleGlobalMass.value.toString().length - 1 }, 'particleGlobalMassExponent', 1, 10, 1 ).onChange( value => particleGlobalMass.value = Number( `1e${value}` ) );
				gui.add( maxSpeed, 'value', 0, 10, 0.01 ).name( 'maxSpeed' );
				gui.add( velocityDamping, 'value', 0, 0.1, 0.001 ).name( 'velocityDamping' );
				gui.add( spinningStrength, 'value', 0, 10, 0.01 ).name( 'spinningStrength' );
				gui.add( scale, 'value', 0, 0.1, 0.001 ).name( 'scale' );
				gui.add( boundHalfExtent, 'value', 0, 20, 0.01 ).name( 'boundHalfExtent' );
				gui.addColor( { color: colorA.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorA' ).onChange( value => colorA.value.set( value ) );
				gui.addColor( { color: colorB.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).name( 'colorB' ).onChange( value => colorB.value.set( value ) );
				gui.add( { controlsMode: attractors[ 0 ].controls.mode }, 'controlsMode', [ 'translate', 'rotate', 'none' ] ).onChange( value => {

					for ( const attractor of attractors ) {

						if ( value === 'none' ) {

							attractor.controls.visible = false;
							attractor.controls.enabled = false;

						} else {

							attractor.controls.visible = true;
							attractor.controls.enabled = true;
							attractor.controls.mode = value;

						}

					}

				} );

				gui.add( { helperVisible: attractors[ 0 ].helper.visible }, 'helperVisible' ).onChange( value => {

					for ( const attractor of attractors ) {

						attractor.helper.visible = value;

					}

				} );

				gui.add( { reset }, 'reset' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				controls.update();

    			renderer.compute( updateCompute );
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_earth.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - earth</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Earth</span>
			</div>

			<small>
				Based on <a href="https://threejs-journey.com/lessons/earth-shaders" target="_blank" rel="noopener">Three.js Journey</a> lesson
				<br>
				Earth textures from <a href="https://www.solarsystemscope.com/textures/" target="_blank" rel="noopener">Solar System Scope</a> (resized and merged)
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { step, normalWorldGeometry, output, texture, vec3, vec4, normalize, positionWorld, bumpMap, cameraPosition, color, uniform, mix, uv, max } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, controls, globe, clock;

			init();

			function init() {

				clock = new THREE.Clock();

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 4.5, 2, 3 );

				scene = new THREE.Scene();

				// sun

				const sun = new THREE.DirectionalLight( '#ffffff', 2 );
				sun.position.set( 0, 0, 3 );
				scene.add( sun );

				// uniforms

				const atmosphereDayColor = uniform( color( '#4db2ff' ) );
				const atmosphereTwilightColor = uniform( color( '#bc490b' ) );
				const roughnessLow = uniform( 0.25 );
				const roughnessHigh = uniform( 0.35 );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const dayTexture = textureLoader.load( './textures/planets/earth_day_4096.jpg' );
				dayTexture.colorSpace = THREE.SRGBColorSpace;
				dayTexture.anisotropy = 8;

				const nightTexture = textureLoader.load( './textures/planets/earth_night_4096.jpg' );
				nightTexture.colorSpace = THREE.SRGBColorSpace;
				nightTexture.anisotropy = 8;

				const bumpRoughnessCloudsTexture = textureLoader.load( './textures/planets/earth_bump_roughness_clouds_4096.jpg' );
				bumpRoughnessCloudsTexture.anisotropy = 8;

				// fresnel

				const viewDirection = positionWorld.sub( cameraPosition ).normalize();
				const fresnel = viewDirection.dot( normalWorldGeometry ).abs().oneMinus().toVar();

				// sun orientation

				const sunOrientation = normalWorldGeometry.dot( normalize( sun.position ) ).toVar();

				// atmosphere color

				const atmosphereColor = mix( atmosphereTwilightColor, atmosphereDayColor, sunOrientation.smoothstep( - 0.25, 0.75 ) );

				// globe

				const globeMaterial = new THREE.MeshStandardNodeMaterial();

				const cloudsStrength = texture( bumpRoughnessCloudsTexture, uv() ).b.smoothstep( 0.2, 1 );

				globeMaterial.colorNode = mix( texture( dayTexture ), vec3( 1 ), cloudsStrength.mul( 2 ) );

				const roughness = max(
					texture( bumpRoughnessCloudsTexture ).g,
					step( 0.01, cloudsStrength )
				);
				globeMaterial.roughnessNode = roughness.remap( 0, 1, roughnessLow, roughnessHigh );

				const night = texture( nightTexture );
				const dayStrength = sunOrientation.smoothstep( - 0.25, 0.5 );

				const atmosphereDayStrength = sunOrientation.smoothstep( - 0.5, 1 );
				const atmosphereMix = atmosphereDayStrength.mul( fresnel.pow( 2 ) ).clamp( 0, 1 );

				let finalOutput = mix( night.rgb, output.rgb, dayStrength );
				finalOutput = mix( finalOutput, atmosphereColor, atmosphereMix );

				globeMaterial.outputNode = vec4( finalOutput, output.a );

				const bumpElevation = max(
					texture( bumpRoughnessCloudsTexture ).r,
					cloudsStrength
				);
				globeMaterial.normalNode = bumpMap( bumpElevation );

				const sphereGeometry = new THREE.SphereGeometry( 1, 64, 64 );
				globe = new THREE.Mesh( sphereGeometry, globeMaterial );
				scene.add( globe );

				// atmosphere

				const atmosphereMaterial = new THREE.MeshBasicNodeMaterial( { side: THREE.BackSide, transparent: true } );
				let alpha = fresnel.remap( 0.73, 1, 1, 0 ).pow( 3 );
				alpha = alpha.mul( sunOrientation.smoothstep( - 0.5, 1 ) );
				atmosphereMaterial.outputNode = vec4( atmosphereColor, alpha );

				const atmosphere = new THREE.Mesh( sphereGeometry, atmosphereMaterial );
				atmosphere.scale.setScalar( 1.04 );
				scene.add( atmosphere );

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				// events

				window.addEventListener( 'resize', onWindowResize );

				// debug

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui
					.addColor( { color: atmosphereDayColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' )
					.onChange( ( value ) => {

						atmosphereDayColor.value.set( value );

					} )
					.name( 'atmosphereDayColor' );

				gui
					.addColor( { color: atmosphereTwilightColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' )
					.onChange( ( value ) => {

						atmosphereTwilightColor.value.set( value );

					} )
					.name( 'atmosphereTwilightColor' );

				gui.add( roughnessLow, 'value', 0, 1, 0.001 ).name( 'roughnessLow' );
				gui.add( roughnessHigh, 'value', 0, 1, 0.001 ).name( 'roughnessHigh' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				const delta = clock.getDelta();
				globe.rotation.y += delta * 0.025;
			
				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_editor.html
================================================
<html lang="en">
	<head>
		<title>three.js webgpu - tsl editor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<style>
			#source {
				position: absolute;
				top: 0;
				left: 0;
				width: 50%;
				height: 100%;
			}
			#result {
				position: absolute;
				top: 0;
				right: 0;
				width: 50%;
				height: 100%;
			}
			#renderer {
				position: absolute;
				bottom: 15px;
				right: calc( 50% + 15px );
				width: 200px;
				height: 200px;
				z-index: 100;
				pointer-events: none;
			}
		</style>

		<div id="source"></div>
		<div id="result"></div>
		<div id="renderer"></div>
		<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { vec4 } from 'three/tsl';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			init();

			function init() {

				// add the dependencies

				const width = 200;
				const height = 200;

				const camera = new THREE.PerspectiveCamera( 70, width / height, 0.1, 10 );
				camera.position.z = .72;
				camera.lookAt( 0, 0, 0 );

				const scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );

				const rendererDOM = document.getElementById( 'renderer' );

				const renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( 200, 200 );
				rendererDOM.appendChild( renderer.domElement );

				const material = new THREE.NodeMaterial();
				material.fragmentNode = vec4( 0, 0, 0, 1 );

				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( mesh );

				//

				let compiling = false;

				renderer.setAnimationLoop( () => {

					if ( compiling ) return;

					renderer.render( scene, camera );

				} );

				// editor

				window.require.config( { paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } } );

				require( [ 'vs/editor/editor.main' ], () => {

					const options = {
						shader: 'fragment',
						outputColorSpace: THREE.SRGBColorSpace,
						output: 'WGSL',
						preview: true
					};

					let timeout = null;
					let rawShader = null;

					const editorDOM = document.getElementById( 'source' );
					const resultDOM = document.getElementById( 'result' );

					const tslCode = `// Simple uv.x animation

const { texture, uniform, vec2, vec4, uv, oscSine, time, grayscale } = await import( 'three/tsl' );

const samplerTexture = new THREE.TextureLoader().load( './textures/uv_grid_opengl.jpg' );
samplerTexture.wrapS = THREE.RepeatWrapping;
samplerTexture.colorSpace = THREE.SRGBColorSpace;

const scaledTime = time.mul( .5 ); // .5 is speed
const uv0 = uv();
const animateUv = vec2( uv0.x.add( oscSine( scaledTime ) ), uv0.y );

// .setName() is optional
const myMap = texture( samplerTexture, animateUv ).rgb.setName( 'myTexture' );
const myColor = uniform( new THREE.Color( 0x0066ff ) ).setName( 'myColor' );
const opacity = .7;

const desaturatedMap = grayscale( myMap.rgb );

const finalColor = desaturatedMap.add( myColor );

output = vec4( finalColor, opacity );
`;

					const editor = window.monaco.editor.create( editorDOM, {
						value: tslCode,
						language: 'javascript',
						theme: 'vs-dark',
						automaticLayout: true,
						minimap: { enabled: false }
					} );

					const result = window.monaco.editor.create( resultDOM, {
						value: '',
						language: 'wgsl',
						theme: 'vs-dark',
						automaticLayout: true,
						readOnly: true,
						minimap: { enabled: false }
					} );

					const showCode = () => {

						result.setValue( rawShader[ options.shader + 'Shader' ] );
						result.revealLine( 1 );

					};

					const webGLRenderer = new THREE.WebGPURenderer( { forceWebGL: true } );

					const build = async () => {

						try {

							const AsyncFunction = async function () {}.constructor;

							const tslCode = `let output = null;\n${ editor.getValue() }\nreturn { output };`;
							const nodes = await ( new AsyncFunction( 'THREE', tslCode )( THREE ) );

							mesh.material.fragmentNode = nodes.output;
							mesh.material.needsUpdate = true;

							compiling = true;

							if ( options.output === 'WGSL' ) {

								rawShader = await renderer.debug.getShaderAsync( scene, camera, mesh );


							} else if ( options.output === 'GLSL ES 3.0' ) {

								rawShader = await webGLRenderer.debug.getShaderAsync( scene, camera, mesh );

							}

							compiling = false;

							showCode();

							// extra debug info

							/*const style = 'background-color: #333; color: white; font-style: italic; border: 2px solid #777; font-size: 22px;';

							console.log( '%c  [ WGSL ] Vertex Shader      ', style );
							console.log( rawShader.vertexShader );
							console.log( '%c  [ WGSL ] Fragment Shader    ', style );
							console.log( rawShader.fragmentShader );/**/

						} catch ( e ) {

							result.setValue( 'Error: ' + e.message );

						}

					};

					build();

					editor.getModel().onDidChangeContent( () => {

						if ( timeout ) clearTimeout( timeout );

						timeout = setTimeout( build, 1000 );

					} );

					// gui

					const gui = new GUI();

					gui.add( options, 'output', [ 'WGSL', 'GLSL ES 3.0' ] ).onChange( build );
					gui.add( options, 'shader', [ 'vertex', 'fragment' ] ).onChange( showCode );

					gui.add( options, 'outputColorSpace', [ THREE.LinearSRGBColorSpace, THREE.SRGBColorSpace ] ).onChange( ( value ) => {

						renderer.outputColorSpace = value;

						build();

					} );

					gui.add( options, 'preview' ).onChange( ( value ) => {

						rendererDOM.style.display = value ? '' : 'none';

					} );

				} );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_galaxy.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - galaxy</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Galaxy</span>
			</div>

			<small>
				Based on <a href="https://threejs-journey.com/lessons/animated-galaxy" target="_blank" rel="noopener">Three.js Journey</a> lessons.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, cos, float, mix, range, sin, time, uniform, uv, vec3, vec4, TWO_PI } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 4, 2, 5 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x201919 );

				// galaxy

				const material = new THREE.SpriteNodeMaterial( {
					depthWrite: false,
					blending: THREE.AdditiveBlending
				} );

				const size = uniform( 0.08 );
				material.scaleNode = range( 0, 1 ).mul( size );

				const radiusRatio = range( 0, 1 );
				const radius = radiusRatio.pow( 1.5 ).mul( 5 ).toVar();

				const branches = 3;
				const branchAngle = range( 0, branches ).floor().mul( TWO_PI.div( branches ) );
				const angle = branchAngle.add( time.mul( radiusRatio.oneMinus() ) );

				const position = vec3(
					cos( angle ),
					0,
					sin( angle )
				).mul( radius );

				const randomOffset = range( vec3( - 1 ), vec3( 1 ) ).pow3().mul( radiusRatio ).add( 0.2 );

				material.positionNode = position.add( randomOffset );

				const colorInside = uniform( color( '#ffa575' ) );
				const colorOutside = uniform( color( '#311599' ) );
				const colorFinal = mix( colorInside, colorOutside, radiusRatio.oneMinus().pow( 2 ).oneMinus() );
				const alpha = float( 0.1 ).div( uv().sub( 0.5 ).length() ).sub( 0.2 );
				material.colorNode = vec4( colorFinal, alpha );

				const mesh = new THREE.InstancedMesh( new THREE.PlaneGeometry( 1, 1 ), material, 20000 );
				scene.add( mesh );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				// events

				window.addEventListener( 'resize', onWindowResize );

				// debug

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.add( size, 'value', 0, 1, 0.001 ).name( 'size' );

				gui.addColor( { color: colorInside.value.getHex( THREE.SRGBColorSpace ) }, 'color' )
					.name( 'colorInside' )
					.onChange( function ( value ) {

						colorInside.value.set( value );

					} );

				gui.addColor( { color: colorOutside.value.getHex( THREE.SRGBColorSpace ) }, 'color' )
					.name( 'colorOutside' )
					.onChange( function ( value ) {

						colorOutside.value.set( value );

					} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_halftone.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - halftone</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Halftone</span>
			</div>

			<small>
				Halftone effect.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { color, mix, normalWorld, output, Fn, uniform, vec4, rotate, screenCoordinate, screenSize } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer, controls, clock, halftoneSettings;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 6, 3, 10 );

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.setClearColor( '#000000' );
				document.body.appendChild( renderer.domElement );

				// inspector/gui

				renderer.inspector = new Inspector();

				const gui = renderer.inspector.createParameters( 'Parameters' );

				// lights

				const ambientLight = new THREE.AmbientLight( '#ffffff', 3 );
				scene.add( ambientLight );

				const directionalLight = new THREE.DirectionalLight( '#ffffff', 8 );
				directionalLight.position.set( 4, 3, 1 );
				scene.add( directionalLight );

				const lightsFolder = gui.addFolder( '💡 lights' );
				lightsFolder.add( ambientLight, 'intensity', 0, 10, 0.001 ).name( 'ambient intensity' );
				lightsFolder.add( directionalLight, 'intensity', 0, 20, 0.001 ).name( 'directional intensity' );

				// halftone settings

				halftoneSettings = [

					// purple shade

					{
						count: 140,
						color: '#fb00ff',
						direction: new THREE.Vector3( - 0.4, - 1, 0.5 ),
						start: 1,
						end: 0,
						mixLow: 0,
						mixHigh: 0.5,
						radius: 0.8
					},

					// cyan highlight

					{
						count: 180,
						color: '#94ffd1',
						direction: new THREE.Vector3( 0.5, 0.5, - 0.2 ),
						start: 0.55,
						end: 0.2,
						mixLow: 0.5,
						mixHigh: 1,
						radius: 0.8
					}
				];

				for ( const index in halftoneSettings ) {

					const settings = halftoneSettings[ index ];

					// uniforms

					const uniforms = {};

					uniforms.count = uniform( settings.count );
					uniforms.color = uniform( color( settings.color ) );
					uniforms.direction = uniform( settings.direction );
					uniforms.start = uniform( settings.start );
					uniforms.end = uniform( settings.end );
					uniforms.mixLow = uniform( settings.mixLow );
					uniforms.mixHigh = uniform( settings.mixHigh );
					uniforms.radius = uniform( settings.radius );

					settings.uniforms = uniforms;

					// debug

					const folder = gui.addFolder( `⚪️ halftone ${index}` );

					folder.addColor( { color: uniforms.color.value }, 'color' );
					folder.add( uniforms.count, 'value', 1, 200, 1 ).name( 'count' );
					folder.add( uniforms.direction.value, 'x', - 1, 1, 0.01 ).listen();
					folder.add( uniforms.direction.value, 'y', - 1, 1, 0.01 ).listen();
					folder.add( uniforms.direction.value, 'z', - 1, 1, 0.01 ).listen();
					folder.add( uniforms.start, 'value', - 1, 1, 0.01 ).name( 'start' );
					folder.add( uniforms.end, 'value', - 1, 1, 0.01 ).name( 'end' );
					folder.add( uniforms.mixLow, 'value', 0, 1, 0.01 ).name( 'mix low' );
					folder.add( uniforms.mixHigh, 'value', 0, 1, 0.01 ).name( 'mix high' );
					folder.add( uniforms.radius, 'value', 0, 1, 0.01 ).name( 'radius' );

				}

				// halftone functions

				const halftone = Fn( ( [ count, color, direction, start, end, radius, mixLow, mixHigh ] ) => {

					// grid pattern

					let gridUv = screenCoordinate.xy.div( screenSize.yy ).mul( count );
					gridUv = rotate( gridUv, Math.PI * 0.25 ).mod( 1 );

					// orientation strength

					const orientationStrength = normalWorld
						.dot( direction.normalize() )
						.remapClamp( end, start, 0, 1 );

					// mask

					const mask = orientationStrength.mul( radius ).mul( 0.5 )
						.step( gridUv.sub( 0.5 ).length() )
						.mul( mix( mixLow, mixHigh, orientationStrength ) );

					return vec4( color, mask );

				} );

				const halftones = Fn( ( [ input ] ) => {

					const halftonesOutput = input;

					for ( const settings of halftoneSettings ) {

						const halfToneOutput = halftone( settings.uniforms.count, settings.uniforms.color, settings.uniforms.direction, settings.uniforms.start, settings.uniforms.end, settings.uniforms.radius, settings.uniforms.mixLow, settings.uniforms.mixHigh );
						halftonesOutput.rgb.assign( mix( halftonesOutput.rgb, halfToneOutput.rgb, halfToneOutput.a ) );

					}

					return halftonesOutput;

				} );

				// default material

				const defaultMaterial = new THREE.MeshStandardNodeMaterial( { color: '#ff622e' } );
				defaultMaterial.outputNode = halftones( output );

				const folder = gui.addFolder( '🎨 default material' );
				folder.addColor( { color: defaultMaterial.color }, 'color' );

				// objects

				const torusKnot = new THREE.Mesh(
					new THREE.TorusKnotGeometry( 0.6, 0.25, 128, 32 ),
					defaultMaterial
				);
				torusKnot.position.x = 3;
				scene.add( torusKnot );

				const sphere = new THREE.Mesh(
					new THREE.SphereGeometry( 1, 64, 64 ),
					defaultMaterial
				);
				sphere.position.x = - 3;
				scene.add( sphere );

				const gltfLoader = new GLTFLoader();
				gltfLoader.load(
					'./models/gltf/Michelle.glb',
					( gltf ) => {

						const model = gltf.scene;
						model.position.y = - 2;
						model.scale.setScalar( 2.5 );
						model.traverse( ( child ) => {

							if ( child.isMesh )
								child.material.outputNode = halftones( output );

						} );

						scene.add( model );

					}
				);

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				controls.update();

				const time = clock.getElapsedTime();
				halftoneSettings[ 1 ].uniforms.direction.value.x = Math.cos( time );
				halftoneSettings[ 1 ].uniforms.direction.value.y = Math.sin( time );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_interoperability.html
================================================
<html lang="en">
	<head>
		<title>three.js - wgsl/tsl interoperability</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>WGSL/TSL Interoperability</span>
			</div>

			<small>
				CRT Shader adapted from <a href="https://mini.gmshaders.com/p/gm-shaders-mini-crt" target="_blank" rel="noopener"> Xor</a>.
			</small>
		</div>

		<div id="container">
			<canvas id="c"></canvas>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Fn, attribute, varyingProperty, time, uniform, wgslFn, texture, sampler, uv, clamp, float, vec2, vec3, fract, floor, positionGeometry, sin } from 'three/tsl';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let renderer, camera, scene;
			const dpr = window.devicePixelRatio;

			const crtWidthUniform = uniform( 1608 );
			const crtHeightUniform = uniform( 1608 );

			const canvas = document.getElementById( 'c' );

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				const vUv = varyingProperty( 'vec2', 'vUv' );

				// In WGSL, access varying properties from the varying struct
				const wgslVertexShader = wgslFn( `
					fn crtVertex(
	 					position: vec3f,
						uv: vec2f
					) -> vec3<f32> {
						varyings.vUv = uv;
						return position;
					}
				`, [
					vUv
				] );

				// Only wgsl vertex shaders take varyings arguments when defined.
				// For a wgsl fragment shader, pass the varyingProperty node to the
				// fragment shader's constructor to access the varying value computed
				// by the vertex shader.
				const wgslFragmentShader = wgslFn( `
					fn crtFragment(
						vUv: vec2f,
						tex: texture_2d<f32>,
						texSampler: sampler,
						crtWidth: f32,
						crtHeight: f32,
						cellOffset: f32,
						cellSize: f32,
						borderMask: f32,
						time: f32,
						speed: f32,
						pulseIntensity: f32,
						pulseWidth: f32,
						pulseRate: f32
					) -> vec3<f32> {
						// Convert uv into map of pixels
						var pixel = ( vUv * 0.5 + 0.5 ) * vec2<f32>(
							crtWidth,
							crtHeight
						);
						// Coordinate for each cell in the pixel map
						let coord = pixel / cellSize;
						// Three color values for each cell (r, g, b)
						let subcoord = coord * vec2f( 3.0, 1.0 );
						let offset = vec2<f32>( 0, fract( floor( coord.x ) * cellOffset ) );

						let maskCoord = floor( coord + offset ) * cellSize;

						var samplePoint = maskCoord / vec2<f32>(crtWidth, crtHeight);
						samplePoint.x += fract( time * speed / 20 );

						var color = textureSample(
							tex,
							texSampler,
							samplePoint
						).xyz;

						// Current implementation does not give an even amount of space to each r, g, b unit of a cell
						// Fix/hack this by multiplying subCoord.x by cellSize at cellSizes below 6
						let ind = floor( subcoord.x ) % 3;

						var maskColor = vec3<f32>(
							f32( ind == 0.0 ),
							f32( ind == 1.0 ),
							f32( ind == 2.0 )
						) * 3.0;

						let cellUV = fract( subcoord + offset ) * 2.0 - 1.0;
						var border: vec2<f32> = 1.0 - cellUV * cellUV * borderMask;

						maskColor *= vec3f( clamp( border.x, 0.0, 1.0 ) * clamp( border.y, 0.0, 1.0) );

						color *= maskColor;

						color.r *= 1.0 + pulseIntensity * sin( pixel.y / pulseWidth + time * pulseRate );
						color.b *= 1.0 + pulseIntensity * sin( pixel.y / pulseWidth + time * pulseRate );
						color.g *= 1.0 + pulseIntensity * sin( pixel.y / pulseWidth + time * pulseRate );

						return color;
					}
				` );

				const textureLoader = new THREE.TextureLoader();
				const planetTexture = textureLoader.load( 'textures/planets/earth_lights_2048.png' );
				planetTexture.wrapS = THREE.RepeatWrapping;
				planetTexture.wrapT = THREE.RepeatWrapping;

				// Node Uniforms:
				// Passed to WGSL Functions.
				// Manipulated directly in TSL Functions.
				const cellOffsetUniform = uniform( 0.5 );
				const cellSizeUniform = uniform( 6 );
				const borderMaskUniform = uniform( 1 );
				const pulseIntensityUniform = uniform( 0.06 );
				const pulseWidthUniform = uniform( 60 );
				const pulseRateUniform = uniform( 20 );
				const wgslShaderSpeedUniform = uniform( 1.0 );
				const tslShaderSpeedUniform = uniform( 1.0 );

				//

				const wgslShaderMaterial = new THREE.MeshBasicNodeMaterial();

				// Accessed attributes correspond to a Mesh or BufferGeometry's setAttribute() calls.
				wgslShaderMaterial.positionNode = wgslVertexShader( {
					position: attribute( 'position' ),
					uv: attribute( 'uv' )
				} );

				wgslShaderMaterial.fragmentNode = wgslFragmentShader( {
					vUv: vUv,
					tex: texture( planetTexture ),
					texSampler: sampler( planetTexture ),
					crtWidth: crtWidthUniform,
					crtHeight: crtHeightUniform,
					cellOffset: cellOffsetUniform,
					cellSize: cellSizeUniform,
					borderMask: borderMaskUniform,
					time: time,
					speed: wgslShaderSpeedUniform,
					pulseIntensity: pulseIntensityUniform,
					pulseWidth: pulseWidthUniform,
					pulseRate: pulseRateUniform
				} );

				//

				const tslVertexShader = Fn( () => {

					vUv.assign( uv() );
					return positionGeometry;

				} );

				const tslFragmentShader = Fn( () => {

					const dimensions = vec2( crtWidthUniform, crtHeightUniform );
					const translatedUV = vUv.mul( 0.5 ).add( 0.5 );
					const pixel = translatedUV.mul( dimensions );

					const coord = pixel.div( cellSizeUniform );
					const subCoord = coord.mul( vec2( 3.0, 1.0 ) );

					const cellOffset = vec2(
						0.0,
						fract( floor( coord.x ).mul( cellOffsetUniform ) )
					);

					const maskCoord = floor( coord.add( cellOffset ) ).mul( cellSizeUniform );
					const samplePoint = maskCoord.div( dimensions );
					const scaledTime = time.mul( tslShaderSpeedUniform );
					samplePoint.x = samplePoint.x.add( fract( scaledTime.div( 20 ) ) );
					samplePoint.y = samplePoint.y.sub( 1.5 );

					let color = texture( planetTexture, samplePoint );

					const ind = floor( subCoord.x ).mod( 3 );

					let maskColor = vec3(
						ind.equal( 0.0 ),
						ind.equal( 1.0 ),
						ind.equal( 2.0 )
					).mul( 3.0 );

					const subCoordOffset = fract( subCoord.add( cellOffset ) );
					let cellUV = subCoordOffset.mul( 2.0 );
					cellUV = cellUV.sub( 1.0 );

					const border = float( 1.0 ).sub(
						cellUV.mul( cellUV ).mul( borderMaskUniform )
					);

					const clampX = clamp( border.x, 0.0, 1.0 );
					const clampY = clamp( border.y, 0.0, 1.0 );
					const borderClamp = clampX.mul( clampY );
					maskColor = maskColor.mul( borderClamp );

					color = color.mul( maskColor );

					const pixelDampen = pixel.y.div( pulseWidthUniform );
					let pulse = sin( pixelDampen.add( time.mul( pulseRateUniform ) ) );
					pulse = pulse.mul( pulseIntensityUniform );
					color = color.mul( float( 1.0 ).add( pulse ) );

					return color;

				} );

				const tslShaderMaterial = new THREE.MeshBasicNodeMaterial();
				tslShaderMaterial.positionNode = tslVertexShader();
				tslShaderMaterial.colorNode = tslFragmentShader();

				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				scene = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 1 );

				const wgslQuad = new THREE.Mesh( geometry, wgslShaderMaterial );
				wgslQuad.position.y += 0.5;
				scene.add( wgslQuad );

				const tslQuad = new THREE.Mesh( geometry, tslShaderMaterial );
				tslQuad.position.y -= 0.5;
				scene.add( tslQuad );

				renderer = new THREE.WebGPURenderer( { antialias: true, canvas: canvas } );
				renderer.setPixelRatio( dpr );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.add( cellSizeUniform, 'value', 6, 50, 1 ).name( 'Cell Size' );
				gui.add( cellOffsetUniform, 'value', 0, 1, 0.1 ).name( 'Cell Offset' );
				gui.add( borderMaskUniform, 'value', 0, 5, 0.1 ).name( 'Border Mask' );
				gui.add( pulseIntensityUniform, 'value', 0, 0.5, 0.01 ).name( 'Pulse Intensity' );
				gui.add( pulseWidthUniform, 'value', 10, 100, 5 ).name( 'Pulse Width' );
				gui.add( wgslShaderSpeedUniform, 'value', 1, 10 ).name( 'WGSL Shader Speed' );
				gui.add( tslShaderSpeedUniform, 'value', 1, 10 ).name( 'TSL Shader Speed' );

			}

			init();

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_procedural_terrain.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - procedural terrain</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Procedural Terrain</span>
			</div>

			<small>
				Based on <a href="https://threejs-journey.com/lessons/procedural-terrain-shader" target="_blank" rel="noopener">Three.js Journey</a> lessons.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { mx_noise_float, color, cross, dot, float, transformNormalToView, positionLocal, sign, step, Fn, uniform, varying, vec2, vec3, Loop } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';

			let camera, scene, renderer, controls, drag;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( - 10, 8, - 2.2 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x201919 );

				// environment

				const hdrLoader = new HDRLoader();
				hdrLoader.load( './textures/equirectangular/pedestrian_overpass_1k.hdr', ( environmentMap ) => {

					environmentMap.mapping = THREE.EquirectangularReflectionMapping;

					scene.background = environmentMap;
					scene.backgroundBlurriness = 0.5;
					scene.environment = environmentMap;
			
				} );

				// lights
			
				const directionalLight = new THREE.DirectionalLight( '#ffffff', 2 );
				directionalLight.position.set( 6.25, 3, 4 );
				directionalLight.castShadow = true;
				directionalLight.shadow.mapSize.set( 1024, 1024 );
				directionalLight.shadow.camera.near = 0.1;
				directionalLight.shadow.camera.far = 30;
				directionalLight.shadow.camera.top = 8;
				directionalLight.shadow.camera.right = 8;
				directionalLight.shadow.camera.bottom = - 8;
				directionalLight.shadow.camera.left = - 8;
				directionalLight.shadow.normalBias = 0.05;
				directionalLight.shadow.bias = 0;
				scene.add( directionalLight );

				// terrain

				const material = new THREE.MeshStandardNodeMaterial( {
					metalness: 0,
					roughness: 0.5,
					color: '#85d534'
				} );

				const noiseIterations = uniform( 3 );
				const positionFrequency = uniform( 0.175 );
				const warpFrequency = uniform( 6 );
				const warpStrength = uniform( 1 );
				const strength = uniform( 10 );
				const offset = uniform( vec2( 0, 0 ) );
				const normalLookUpShift = uniform( 0.01 );
				const colorSand = uniform( color( '#ffe894' ) );
				const colorGrass = uniform( color( '#85d534' ) );
				const colorSnow = uniform( color( '#ffffff' ) );
				const colorRock = uniform( color( '#bfbd8d' ) );

				const vNormal = varying( vec3() );
				const vPosition = varying( vec3() );

				const terrainElevation = Fn( ( [ position ] ) => {

					const warpedPosition = position.add( offset ).toVar();
					warpedPosition.addAssign( mx_noise_float( warpedPosition.mul( positionFrequency ).mul( warpFrequency ), 1, 0 ).mul( warpStrength ) );
			
					const elevation = float( 0 ).toVar();
					Loop( { type: 'float', start: float( 1 ), end: noiseIterations.toFloat(), condition: '<=' }, ( { i } ) => {

						const noiseInput = warpedPosition.mul( positionFrequency ).mul( i.mul( 2 ) ).add( i.mul( 987 ) );
						const noise = mx_noise_float( noiseInput, 1, 0 ).div( i.add( 1 ).mul( 2 ) );
						elevation.addAssign( noise );
			
					} );

					const elevationSign = sign( elevation );
					elevation.assign( elevation.abs().pow( 2 ).mul( elevationSign ).mul( strength ) );

					return elevation;
			
				} );

				material.positionNode = Fn( () => {

					// neighbours positions

					const neighbourA = positionLocal.xyz.add( vec3( normalLookUpShift, 0.0, 0.0 ) ).toVar();
					const neighbourB = positionLocal.xyz.add( vec3( 0.0, 0.0, normalLookUpShift.negate() ) ).toVar();

					// elevations

					const position = positionLocal.xyz.toVar();
					const elevation = terrainElevation( positionLocal.xz );
					position.y.addAssign( elevation );
			
					neighbourA.y.addAssign( terrainElevation( neighbourA.xz ) );
					neighbourB.y.addAssign( terrainElevation( neighbourB.xz ) );

					// compute normal

					const toA = neighbourA.sub( position ).normalize();
					const toB = neighbourB.sub( position ).normalize();
					vNormal.assign( cross( toA, toB ) );

					// varyings

					vPosition.assign( position.add( vec3( offset.x, 0, offset.y ) ) );

					return position;
			
				} )();

				material.normalNode = transformNormalToView( vNormal );

				material.colorNode = Fn( () => {

					const finalColor = colorSand.toVar();

					// grass

					const grassMix = step( - 0.06, vPosition.y );
					finalColor.assign( grassMix.mix( finalColor, colorGrass ) );

					// rock

					const rockMix = step( 0.5, dot( vNormal, vec3( 0, 1, 0 ) ) ).oneMinus().mul( step( - 0.06, vPosition.y ) );
					finalColor.assign( rockMix.mix( finalColor, colorRock ) );

					// snow

					const snowThreshold = mx_noise_float( vPosition.xz.mul( 25 ), 1, 0 ).mul( 0.1 ).add( 0.45 );
					const snowMix = step( snowThreshold, vPosition.y );
					finalColor.assign( snowMix.mix( finalColor, colorSnow ) );

					return finalColor;
			
				} )();

				const geometry = new THREE.PlaneGeometry( 10, 10, 500, 500 );
				geometry.deleteAttribute( 'uv' );
				geometry.deleteAttribute( 'normal' );
				geometry.rotateX( - Math.PI * 0.5 );

				const terrain = new THREE.Mesh( geometry, material );
				terrain.receiveShadow = true;
				terrain.castShadow = true;
				scene.add( terrain );

				// water
			
				const water = new THREE.Mesh(
					new THREE.PlaneGeometry( 10, 10, 1, 1 ),
					new THREE.MeshPhysicalMaterial( {
						transmission: 1,
						roughness: 0.5,
						ior: 1.333,
						color: '#4db2ff'
					} )
				);
				water.rotation.x = - Math.PI * 0.5;
				water.position.y = - 0.1;
				scene.add( water );

				// drag

				drag = {};
				drag.screenCoords = new THREE.Vector2();
				drag.prevWorldCoords = new THREE.Vector3();
				drag.worldCoords = new THREE.Vector3();
				drag.raycaster = new THREE.Raycaster();
				drag.down = false;
				drag.hover = false;

				drag.object = new THREE.Mesh( new THREE.PlaneGeometry( 10, 10, 1, 1 ), new THREE.MeshBasicMaterial() );
				drag.object.rotation.x = - Math.PI * 0.5;
				drag.object.visible = false;
				scene.add( drag.object );

				drag.getIntersect = () => {

					drag.raycaster.setFromCamera( drag.screenCoords, camera );
					const intersects = drag.raycaster.intersectObject( drag.object );
					if ( intersects.length )
						return intersects[ 0 ];

					return null;

				};

				drag.update = () => {

					const intersect = drag.getIntersect();

					if ( intersect ) {

						drag.hover = true;

						if ( ! drag.down )
							renderer.domElement.style.cursor = 'grab';

					} else {

						drag.hover = false;
						renderer.domElement.style.cursor = 'default';

					}

					if ( drag.hover && drag.down ) {

						drag.worldCoords.copy( intersect.point );
						const delta = drag.prevWorldCoords.sub( drag.worldCoords );

						offset.value.x += delta.x;
						offset.value.y += delta.z;

					}

					drag.prevWorldCoords.copy( drag.worldCoords );

				};

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				// inspector

				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.inspector.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.45;
				controls.target.y = - 0.5;
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				// debug

				const gui = renderer.inspector.createParameters( 'Parameters' );

				const terrainGui = gui.addFolder( '🏔️ terrain' );

				terrainGui.add( noiseIterations, 'value', 0, 10, 1 ).name( 'noiseIterations' );
				terrainGui.add( positionFrequency, 'value', 0, 1, 0.001 ).name( 'positionFrequency' );
				terrainGui.add( strength, 'value', 0, 20, 0.001 ).name( 'strength' );
				terrainGui.add( warpFrequency, 'value', 0, 20, 0.001 ).name( 'warpFrequency' );
				terrainGui.add( warpStrength, 'value', 0, 2, 0.001 ).name( 'warpStrength' );

				terrainGui.addColor( { color: colorSand.value }, 'color' ).name( 'colorSand' );
				terrainGui.addColor( { color: colorGrass.value }, 'color' ).name( 'colorGrass' );
				terrainGui.addColor( { color: colorSnow.value }, 'color' ).name( 'colorSnow' );
				terrainGui.addColor( { color: colorRock.value }, 'color' ).name( 'colorRock' );

				const waterGui = gui.addFolder( '💧 water' );

				waterGui.add( water.material, 'roughness', 0, 1, 0.01 );
				waterGui.add( water.material, 'ior', 1, 2, 0.001 );
				waterGui.addColor( { color: water.material.color }, 'color' ).name( 'color' );

				// events

				window.addEventListener( 'pointermove', ( event ) => {

					drag.screenCoords.x = ( event.clientX / window.innerWidth - 0.5 ) * 2;
					drag.screenCoords.y = - ( event.clientY / window.innerHeight - 0.5 ) * 2;

				} );

				renderer.domElement.addEventListener( 'pointerdown', () => {

					if ( drag.hover ) {

						renderer.domElement.style.cursor = 'grabbing';
						controls.enabled = false;
						drag.down = true;
						drag.object.scale.setScalar( 10 );

						const intersect = drag.getIntersect();
						drag.prevWorldCoords.copy( intersect.point );
						drag.worldCoords.copy( intersect.point );
			
					}

				} );

				window.addEventListener( 'pointerup', () => {

					drag.down = false;
					controls.enabled = true;
					drag.object.scale.setScalar( 1 );
			
				} );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				controls.update();

				drag.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_raging_sea.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - raging sea</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Raging Sea</span>
			</div>

			<small>
				Based on <a href="https://threejs-journey.com/lessons/raging-sea" target="_blank" rel="noopener">Three.js Journey</a> lesson.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { float, mx_noise_float, Loop, color, positionLocal, sin, vec2, vec3, mul, time, uniform, Fn, transformNormalToView } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.set( 1.25, 1.25, 1.25 );

				scene = new THREE.Scene();

				// lights
			
				const directionalLight = new THREE.DirectionalLight( '#ffffff', 3 );
				directionalLight.position.set( - 4, 2, 0 );
				scene.add( directionalLight );

				// material

				const material = new THREE.MeshStandardNodeMaterial( { color: '#271442', roughness: 0.15 } );

				const emissiveColor = uniform( color( '#ff0a81' ) );
				const emissiveLow = uniform( - 0.25 );
				const emissiveHigh = uniform( 0.2 );
				const emissivePower = uniform( 7 );
				const largeWavesFrequency = uniform( vec2( 3, 1 ) );
				const largeWavesSpeed = uniform( 1.25 );
				const largeWavesMultiplier = uniform( 0.15 );
				const smallWavesIterations = uniform( 3 );
				const smallWavesFrequency = uniform( 2 );
				const smallWavesSpeed = uniform( 0.3 );
				const smallWavesMultiplier = uniform( 0.18 );
				const normalComputeShift = uniform( 0.01 );

				// TSL functions

				const wavesElevation = Fn( ( [ position ] ) => {

					// large waves

					const elevation = mul(
						sin( position.x.mul( largeWavesFrequency.x ).add( time.mul( largeWavesSpeed ) ) ),
						sin( position.z.mul( largeWavesFrequency.y ).add( time.mul( largeWavesSpeed ) ) ),
						largeWavesMultiplier
					).toVar();

					Loop( { start: float( 1 ), end: smallWavesIterations.add( 1 ) }, ( { i } ) => {

						const noiseInput = vec3(
							position.xz
								.add( 2 ) // avoids a-hole pattern
								.mul( smallWavesFrequency )
								.mul( i ),
							time.mul( smallWavesSpeed )
						);

						const wave = mx_noise_float( noiseInput, 1, 0 )
							.mul( smallWavesMultiplier )
							.div( i )
							.abs();

						elevation.subAssign( wave );

					} );

					return elevation;

				} );

				// position

				const elevation = wavesElevation( positionLocal );
				const position = positionLocal.add( vec3( 0, elevation, 0 ) );

				material.positionNode = position;

				// normals

				let positionA = positionLocal.add( vec3( normalComputeShift, 0, 0 ) );
				let positionB = positionLocal.add( vec3( 0, 0, normalComputeShift.negate() ) );

				positionA = positionA.add( vec3( 0, wavesElevation( positionA ), 0 ) );
				positionB = positionB.add( vec3( 0, wavesElevation( positionB ), 0 ) );

				const toA = positionA.sub( position ).normalize();
				const toB = positionB.sub( position ).normalize();
				const normal = toA.cross( toB );

				material.normalNode = transformNormalToView( normal );

				// emissive

				const emissive = elevation.remap( emissiveHigh, emissiveLow ).pow( emissivePower );
				material.emissiveNode = emissiveColor.mul( emissive );

				// mesh

				const geometry = new THREE.PlaneGeometry( 2, 2, 256, 256 );
				geometry.rotateX( - Math.PI * 0.5 );
				const mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.y = - 0.25;
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				// debug

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.addColor( { color: material.color.getHex( THREE.SRGBColorSpace ) }, 'color' ).name( 'color' ).onChange( value => material.color.set( value ) );
				gui.add( material, 'roughness', 0, 1, 0.001 );

				const colorGui = gui.addFolder( 'emissive' );
				colorGui.addColor( { color: emissiveColor.value.getHex( THREE.SRGBColorSpace ) }, 'color' ).name( 'color' ).onChange( value => emissiveColor.value.set( value ) );
				colorGui.add( emissiveLow, 'value', - 1, 0, 0.001 ).name( 'low' );
				colorGui.add( emissiveHigh, 'value', 0, 1, 0.001 ).name( 'high' );
				colorGui.add( emissivePower, 'value', 1, 10, 1 ).name( 'power' );

				const wavesGui = gui.addFolder( 'waves' );
				wavesGui.add( largeWavesSpeed, 'value', 0, 5 ).name( 'largeSpeed' );
				wavesGui.add( largeWavesMultiplier, 'value', 0, 1 ).name( 'largeMultiplier' );
				wavesGui.add( largeWavesFrequency.value, 'x', 0, 10 ).name( 'largeFrequencyX' );
				wavesGui.add( largeWavesFrequency.value, 'y', 0, 10 ).name( 'largeFrequencyY' );
				wavesGui.add( smallWavesIterations, 'value', 0, 5, 1 ).name( 'smallIterations' );
				wavesGui.add( smallWavesFrequency, 'value', 0, 10 ).name( 'smallFrequency' );
				wavesGui.add( smallWavesSpeed, 'value', 0, 1 ).name( 'smallSpeed' );
				wavesGui.add( smallWavesMultiplier, 'value', 0, 1 ).name( 'smallMultiplier' );
				wavesGui.add( normalComputeShift, 'value', 0, 0.1, 0.0001 ).name( 'normalComputeShift' );

				// events

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {
			
				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_transpiler.html
================================================
<html lang="en">
	<head>
		<title>three.js - webgpu - tsl transpiler</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<style>
			* {
				box-sizing: border-box;
			}
			#source {
				position: absolute;
				top: 50px;
				left: 0;
				width: calc(50% - 1px);
				height: calc(100% - 50px);
			}
			#result {
				position: absolute;
				top: 50px;
				right: 0;
				width: 50%;
				height: calc(100% - 50px);
			}
			#source-dropdown {
				position: absolute;
				top: 0;
				width: calc(50% - 1px);
				z-index: 100;
				padding: 10px;
				background: #222;
				text-align: center;
			}
			#result-dropdown {
				position: absolute;
				top: 0;
				left: calc(50%);
				width: 50%;
				padding: 10px;
				z-index: 100;
				background: #222;
				text-align: center;
			}
			select {
				background: #333;
				color: white;
				border: 1px solid #555;
				padding: 5px 10px;
			}
			label {
				color: white;
				font-family: Arial, sans-serif;
				font-size: 14px;
			}
		</style>

		<div id="source-dropdown">
			<label for="decoder-select">Encoder</label>
			<select id="decoder-select">
				<option value="GLSL">GLSL</option>
			</select>
		</div>
		<div id="result-dropdown">
			<label for="encoder-select">Decoder</label>
			<select id="encoder-select">
				<option value="TSL">TSL</option>
				<option value="WGSL">WGSL</option>
			</select>
		</div>
		<div id="source"></div>
		<div id="result"></div>
		<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import Transpiler from 'three/addons/transpiler/Transpiler.js';
			import GLSLDecoder from 'three/addons/transpiler/GLSLDecoder.js';
			import WGSLEncoder from 'three/addons/transpiler/WGSLEncoder.js';
			import TSLEncoder from 'three/addons/transpiler/TSLEncoder.js';

			init();

			function init() {

				// editor

				window.require.config( { paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } } );

				require( [ 'vs/editor/editor.main' ], () => {

					const options = {
						decoder: 'GLSL',
						encoder: 'TSL'
					};

					const encoderLanguages = {
						'TSL': 'javascript',
						'WGSL': 'wgsl'
					};

					let timeout = null;

					const editorDOM = document.getElementById( 'source' );
					const resultDOM = document.getElementById( 'result' );

					const glslCode = `/*
 * Perlin noise
 * https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
 */

const float PI = 3.141592653589793;

float rand(vec2 c){
	return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float noise(vec2 p, float freq ){
	float unit = 1./freq;
	vec2 ij = floor(p/unit);
	vec2 xy = mod(p,unit)/unit;
	//xy = 3.*xy*xy-2.*xy*xy*xy;
	xy = .5*(1.-cos(PI*xy));
	float a = rand((ij+vec2(0.,0.)));
	float b = rand((ij+vec2(1.,0.)));
	float c = rand((ij+vec2(0.,1.)));
	float d = rand((ij+vec2(1.,1.)));
	float x1 = mix(a, b, xy.x);
	float x2 = mix(c, d, xy.x);
	return mix(x1, x2, xy.y);
}

float pNoise(vec2 p, int res){
	float persistence = .5;
	float n = 0.;
	float normK = 0.;
	float f = 4.;
	float amp = 1.;
	int iCount = 0;
	for (int i = 0; i<50; i++){
		n+=amp*noise(p, f);
		f*=2.;
		normK+=amp;
		amp*=persistence;
		if (iCount == res) break;
		iCount++;
	}
	float nf = n/normK;
	return nf*nf*nf*nf;
}
`;

					const editor = window.monaco.editor.create( editorDOM, {
						value: glslCode,
						language: 'c',
						theme: 'vs-dark',
						automaticLayout: true,
						wordWrap: 'on',
						minimap: { enabled: false }
					} );

					const result = window.monaco.editor.create( resultDOM, {
						value: '',
						language: 'javascript',
						theme: 'vs-dark',
						automaticLayout: true,
						wordWrap: 'on',
						readOnly: true,
						minimap: { enabled: false }
					} );

					const showCode = ( code ) => {

						result.setValue( code );
						result.revealLine( 1 );

					};

					const build = () => {

						try {

							let encoder;

							if ( options.encoder === 'TSL' ) {

								encoder = new TSLEncoder();

							} else if ( options.encoder === 'WGSL' ) {

								encoder = new WGSLEncoder();

							} else {

								throw new Error( 'Unknown encoder: ' + options.encoder );

							}

							//

							const glsl = editor.getValue();

							const decoder = new GLSLDecoder();

							const transpiler = new Transpiler( decoder, encoder );
							const tsl = transpiler.parse( glsl );

							showCode( tsl );

						} catch ( e ) {

							result.setValue( 'Error: ' + e.message );

						}

					};

					build();

					editor.getModel().onDidChangeContent( () => {

						if ( timeout ) clearTimeout( timeout );

						timeout = setTimeout( build, 1000 );

					} );

					// dropdowns

					const decoderSelect = document.getElementById( 'decoder-select' );
					const encoderSelect = document.getElementById( 'encoder-select' );

					decoderSelect.addEventListener( 'change', () => {

						options.decoder = decoderSelect.value;
						build();

					} );

					encoderSelect.addEventListener( 'change', () => {

						options.encoder = encoderSelect.value;

						const language = encoderLanguages[ encoderSelect.value ];
						window.monaco.editor.setModelLanguage( result.getModel(), language );

						build();

					} );

				} );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_vfx_flames.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - vfx flames</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>VFX Flames</span>
			</div>

			<small>
				Inspired by <a href="https://x.com/cmzw_/status/1799648702338158747" target="_blank" rel="noopener">@cmzw_</a>.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { TWO_PI, oneMinus, spherizeUV, sin, step, texture, time, Fn, uv, vec2, vec3, vec4, mix, billboarding } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 1, 1, 3 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x201919 );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const cellularTexture = textureLoader.load( './textures/noises/voronoi/grayscale-256x256.png' );
				const perlinTexture = textureLoader.load( './textures/noises/perlin/rgb-256x256.png' );

				// gradient canvas

				const gradient = {};
				gradient.element = document.createElement( 'canvas' );
				gradient.element.width = 128;
				gradient.element.height = 1;
				gradient.context = gradient.element.getContext( '2d' );

				gradient.colors = [
					'#090033',
					'#5f1f93',
					'#e02e96',
					'#ffbd80',
					'#fff0db',
				];

				gradient.texture = new THREE.CanvasTexture( gradient.element );
				gradient.texture.colorSpace = THREE.SRGBColorSpace;

				gradient.update = () => {

					const fillGradient = gradient.context.createLinearGradient( 0, 0, gradient.element.width, 0 );

					for ( let i = 0; i < gradient.colors.length; i ++ ) {

						const progress = i / ( gradient.colors.length - 1 );
						const color = gradient.colors[ i ];
						fillGradient.addColorStop( progress, color );

					}

					gradient.context.fillStyle = fillGradient;
					gradient.context.fillRect( 0, 0, gradient.element.width, gradient.element.height );

					gradient.texture.needsUpdate = true;

				};

				gradient.update();

				// flame 1 material

				const flame1Material = new THREE.SpriteNodeMaterial( { side: THREE.DoubleSide } );

				flame1Material.colorNode = Fn( () => {

					// main UV
					const mainUv = uv().toVar();
					mainUv.assign( spherizeUV( mainUv, 10 ).mul( 0.6 ).add( 0.2 ) ); // spherize
					mainUv.assign( mainUv.pow( vec2( 1, 2 ) ) ); // stretch
					mainUv.assign( mainUv.mul( 2, 1 ).sub( vec2( 0.5, 0 ) ) ); // scale

					// gradients
					const gradient1 = sin( time.mul( 10 ).sub( mainUv.y.mul( TWO_PI ).mul( 2 ) ) ).toVar();
					const gradient2 = mainUv.y.smoothstep( 0, 1 ).toVar();
					mainUv.x.addAssign( gradient1.mul( gradient2 ).mul( 0.2 ) );

					// cellular noise
					const cellularUv = mainUv.mul( 0.5 ).add( vec2( 0, time.negate().mul( 0.5 ) ) ).mod( 1 );
					const cellularNoise = texture( cellularTexture, cellularUv, 0 ).r.oneMinus().smoothstep( 0, 0.5 ).oneMinus();
					cellularNoise.mulAssign( gradient2 );

					// shape
					const shape = mainUv.sub( 0.5 ).mul( vec2( 3, 2 ) ).length().oneMinus().toVar();
					shape.assign( shape.sub( cellularNoise ) );

					// gradient color
					const gradientColor = texture( gradient.texture, vec2( shape.remap( 0, 1, 0, 1 ), 0 ) );

					// output
					const color = mix( gradientColor, vec3( 1 ), shape.step( 0.8 ) );
					const alpha = shape.smoothstep( 0, 0.3 );
					return vec4( color.rgb, alpha );

				} )();

				// flame 2 material

				const flame2Material = new THREE.SpriteNodeMaterial( { side: THREE.DoubleSide } );

				flame2Material.colorNode = Fn( () => {

					// main UV
					const mainUv = uv().toVar();
					mainUv.assign( spherizeUV( mainUv, 10 ).mul( 0.6 ).add( 0.2 ) ); // spherize
					mainUv.assign( mainUv.abs().pow( vec2( 1, 3 ) ).mul( mainUv.sign() ) ); // stretch
					mainUv.assign( mainUv.mul( 2, 1 ).sub( vec2( 0.5, 0 ) ) ); // scale

					// perlin noise
					const perlinUv = mainUv.add( vec2( 0, time.negate().mul( 1 ) ) ).mod( 1 );
					const perlinNoise = texture( perlinTexture, perlinUv, 0 ).sub( 0.5 ).mul( 1 );
					mainUv.x.addAssign( perlinNoise.x.mul( 0.5 ) );

					// gradients
					const gradient1 = sin( time.mul( 10 ).sub( mainUv.y.mul( TWO_PI ).mul( 2 ) ) );
					const gradient2 = mainUv.y.smoothstep( 0, 1 );
					const gradient3 = oneMinus( mainUv.y ).smoothstep( 0, 0.3 );
					mainUv.x.addAssign( gradient1.mul( gradient2 ).mul( 0.2 ) );

					// displaced perlin noise
					const displacementPerlinUv = mainUv.mul( 0.5 ).add( vec2( 0, time.negate().mul( 0.25 ) ) ).mod( 1 );
					const displacementPerlinNoise = texture( perlinTexture, displacementPerlinUv, 0 ).sub( 0.5 ).mul( 1 );
					const displacedPerlinUv = mainUv.add( vec2( 0, time.negate().mul( 0.5 ) ) ).add( displacementPerlinNoise ).mod( 1 );
					const displacedPerlinNoise = texture( perlinTexture, displacedPerlinUv, 0 ).sub( 0.5 ).mul( 1 );
					mainUv.x.addAssign( displacedPerlinNoise.mul( 0.5 ) );

					// cellular noise
					const cellularUv = mainUv.add( vec2( 0, time.negate().mul( 1.5 ) ) ).mod( 1 );
					const cellularNoise = texture( cellularTexture, cellularUv, 0 ).r.oneMinus().smoothstep( 0.25, 1 );

					// shape
					const shape = step( mainUv.sub( 0.5 ).mul( vec2( 6, 1 ) ).length(), 0.5 );
					shape.assign( shape.mul( cellularNoise ) );
					shape.mulAssign( gradient3 );
					shape.assign( step( 0.01, shape ) );

					// output
					return vec4( vec3( 1 ), shape );

				} )();

				// billboarding - follow the camera rotation only horizontally

				flame1Material.vertexNode = billboarding();
				flame2Material.vertexNode = billboarding();

				// meshes

				const flame1 = new THREE.Sprite( flame1Material );
				flame1.center.set( 0.5, 0 );
				flame1.scale.x = 0.5; // optional
				flame1.position.x = - 0.5;
				scene.add( flame1 );

				const flame2 = new THREE.Sprite( flame2Material );
				flame2.center.set( 0.5, 0 );
				flame2.position.x = 0.5;
				scene.add( flame2 );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				controls.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_vfx_linkedparticles.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - vfx linked particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>VFX Linked Particles</span>
			</div>

			<small>
				Based on <a href="https://github.com/ULuIQ12/webgpu-tsl-linkedparticles" target="_blank" rel="noopener">this experiment</a> by Christophe Choffel.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { atan, cos, float, max, min, mix, PI, TWO_PI, sin, vec2, vec3, color, Fn, hash, hue, If, instanceIndex, Loop, mx_fractal_noise_float, mx_fractal_noise_vec3, pass, pcurve, storage, deltaTime, time, uv, uniform, step } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let camera, scene, renderer, postProcessing, controls, timer, light;

			let updateParticles, spawnParticles; // TSL compute nodes
			let getInstanceColor; // TSL function

			const screenPointer = new THREE.Vector2();
			const scenePointer = new THREE.Vector3();
			const raycastPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1 ), 0 );
			const raycaster = new THREE.Raycaster();

			const nbParticles = Math.pow( 2, 13 );

			const timeScale = uniform( 1.0 );
			const particleLifetime = uniform( 0.5 );
			const particleSize = uniform( 1.0 );
			const linksWidth = uniform( 0.005 );

			const colorOffset = uniform( 0.0 );
			const colorVariance = uniform( 2.0 );
			const colorRotationSpeed = uniform( 1.0 );

			const spawnIndex = uniform( 0 );
			const nbToSpawn = uniform( 5 );
			const spawnPosition = uniform( vec3( 0.0 ) );
			const previousSpawnPosition = uniform( vec3( 0.0 ) );

			const turbFrequency = uniform( 0.5 );
			const turbAmplitude = uniform( 0.5 );
			const turbOctaves = uniform( 2 );
			const turbLacunarity = uniform( 2.0 );
			const turbGain = uniform( 0.5 );
			const turbFriction = uniform( 0.01 );

			init();

			async function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 200 );
				camera.position.set( 0, 0, 10 );

				scene = new THREE.Scene();

				timer = new THREE.Timer();
				timer.connect( document );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setClearColor( 0x14171a );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				// TSL function
				// current color from index
				getInstanceColor = Fn( ( [ i ] ) => {

					return hue( color( 0x0000ff ), colorOffset.add( mx_fractal_noise_float( i.toFloat().mul( .1 ), 2, 2.0, 0.5, colorVariance ) ) );

				} );

				// Particles
				// storage buffers
				const particlePositions = storage( new THREE.StorageInstancedBufferAttribute( nbParticles, 4 ), 'vec4', nbParticles );
				const particleVelocities = storage( new THREE.StorageInstancedBufferAttribute( nbParticles, 4 ), 'vec4', nbParticles );

				// init particles buffers
				renderer.compute( Fn( () => {

					particlePositions.element( instanceIndex ).xyz.assign( vec3( 10000.0 ) );
					particlePositions.element( instanceIndex ).w.assign( vec3( - 1.0 ) ); // life is stored in w component; x<0 means dead

				} )().compute( nbParticles ) );

				// particles output
				const particleQuadSize = 0.05;
				const particleGeom = new THREE.PlaneGeometry( particleQuadSize, particleQuadSize );

				const particleMaterial = new THREE.SpriteNodeMaterial();
				particleMaterial.blending = THREE.AdditiveBlending;
				particleMaterial.depthWrite = false;
				particleMaterial.positionNode = particlePositions.toAttribute();
				particleMaterial.scaleNode = vec2( particleSize );
				particleMaterial.rotationNode = atan( particleVelocities.toAttribute().y, particleVelocities.toAttribute().x );

				particleMaterial.colorNode = Fn( () => {

					const life = particlePositions.toAttribute().w;
					const modLife = pcurve( life.oneMinus(), 8.0, 1.0 );
					const pulse = pcurve(
						sin( hash( instanceIndex ).mul( TWO_PI ).add( time.mul( 0.5 ).mul( TWO_PI ) ) ).mul( 0.5 ).add( 0.5 ),
						0.25,
						0.25
					).mul( 10.0 ).add( 1.0 );

					return getInstanceColor( instanceIndex ).mul( pulse.mul( modLife ) );

				} )();

				particleMaterial.opacityNode = Fn( () => {

					const circle = step( uv().xy.sub( 0.5 ).length(), 0.5 );
					const life = particlePositions.toAttribute().w;

					return circle.mul( life );

				} )();

				const particleMesh = new THREE.InstancedMesh( particleGeom, particleMaterial, nbParticles );
				particleMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				particleMesh.frustumCulled = false;

				scene.add( particleMesh );

				// Links between particles
				// first, we define the indices for the links, 2 quads per particle, the indexation is fixed
				const linksIndices = [];
				for ( let i = 0; i < nbParticles; i ++ ) {

					const baseIndex = i * 8;
					for ( let j = 0; j < 2; j ++ ) {

						const offset = baseIndex + j * 4;
						linksIndices.push( offset, offset + 1, offset + 2, offset, offset + 2, offset + 3 );

					}

				}

				// storage buffers attributes for the links
				const nbVertices = nbParticles * 8;
				const linksVerticesSBA = new THREE.StorageBufferAttribute( nbVertices, 4 );
				const linksColorsSBA = new THREE.StorageBufferAttribute( nbVertices, 4 );

				// links output
				const linksGeom = new THREE.BufferGeometry();
				linksGeom.setAttribute( 'position', linksVerticesSBA );
				linksGeom.setAttribute( 'color', linksColorsSBA );
				linksGeom.setIndex( linksIndices );

				const linksMaterial = new THREE.MeshBasicNodeMaterial();
				linksMaterial.vertexColors = true;
				linksMaterial.side = THREE.DoubleSide;
				linksMaterial.transparent = true;
				linksMaterial.depthWrite = false;
				linksMaterial.depthTest = false;
				linksMaterial.blending = THREE.AdditiveBlending;
				linksMaterial.opacityNode = storage( linksColorsSBA, 'vec4', linksColorsSBA.count ).toAttribute().w;

				const linksMesh = new THREE.Mesh( linksGeom, linksMaterial );
				linksMesh.frustumCulled = false;
				scene.add( linksMesh );

				// compute nodes
				updateParticles = Fn( () => {

					const position = particlePositions.element( instanceIndex ).xyz;
					const life = particlePositions.element( instanceIndex ).w;
					const velocity = particleVelocities.element( instanceIndex ).xyz;
					const dt = deltaTime.mul( 0.1 ).mul( timeScale );

					If( life.greaterThan( 0.0 ), () => {

						// first we update the particles positions and velocities
						// velocity comes from a turbulence field, and is multiplied by the particle lifetime so that it slows down over time
						const localVel = mx_fractal_noise_vec3( position.mul( turbFrequency ), turbOctaves, turbLacunarity, turbGain, turbAmplitude ).mul( life.add( .01 ) );
						velocity.addAssign( localVel );
						velocity.mulAssign( turbFriction.oneMinus() );
						position.addAssign( velocity.mul( dt ) );

						// then we decrease the lifetime
						life.subAssign( dt.mul( particleLifetime.reciprocal() ) );

						// then we find the two closest particles and set a quad to each of them
						const closestDist1 = float( 10000.0 ).toVar();
						const closestPos1 = vec3( 0.0 ).toVar();
						const closestLife1 = float( 0.0 ).toVar();
						const closestDist2 = float( 10000.0 ).toVar();
						const closestPos2 = vec3( 0.0 ).toVar();
						const closestLife2 = float( 0.0 ).toVar();

						Loop( nbParticles, ( { i } ) => {

							const otherPart = particlePositions.element( i );

							If( i.notEqual( instanceIndex ).and( otherPart.w.greaterThan( 0.0 ) ), () => { // if not self and other particle is alive

								const otherPosition = otherPart.xyz;
								const dist = position.sub( otherPosition ).lengthSq();
								const moreThanZero = dist.greaterThan( 0.0 );

								If( dist.lessThan( closestDist1 ).and( moreThanZero ), () => {

									closestDist1.assign( dist );
									closestPos1.assign( otherPosition.xyz );
									closestLife1.assign( otherPart.w );

								} ).ElseIf( dist.lessThan( closestDist2 ).and( moreThanZero ), () => {

									closestDist2.assign( dist );
									closestPos2.assign( otherPosition.xyz );
									closestLife2.assign( otherPart.w );

								} );

							} );

						} );

						// then we update the links correspondingly
						const linksPositions = storage( linksVerticesSBA, 'vec4', linksVerticesSBA.count );
						const linksColors = storage( linksColorsSBA, 'vec4', linksColorsSBA.count );
						const firstLinkIndex = instanceIndex.mul( 8 );
						const secondLinkIndex = firstLinkIndex.add( 4 );

						// positions link 1
						linksPositions.element( firstLinkIndex ).xyz.assign( position );
						linksPositions.element( firstLinkIndex ).y.addAssign( linksWidth );
						linksPositions.element( firstLinkIndex.add( 1 ) ).xyz.assign( position );
						linksPositions.element( firstLinkIndex.add( 1 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( firstLinkIndex.add( 2 ) ).xyz.assign( closestPos1 );
						linksPositions.element( firstLinkIndex.add( 2 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( firstLinkIndex.add( 3 ) ).xyz.assign( closestPos1 );
						linksPositions.element( firstLinkIndex.add( 3 ) ).y.addAssign( linksWidth );

						// positions link 2
						linksPositions.element( secondLinkIndex ).xyz.assign( position );
						linksPositions.element( secondLinkIndex ).y.addAssign( linksWidth );
						linksPositions.element( secondLinkIndex.add( 1 ) ).xyz.assign( position );
						linksPositions.element( secondLinkIndex.add( 1 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( secondLinkIndex.add( 2 ) ).xyz.assign( closestPos2 );
						linksPositions.element( secondLinkIndex.add( 2 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( secondLinkIndex.add( 3 ) ).xyz.assign( closestPos2 );
						linksPositions.element( secondLinkIndex.add( 3 ) ).y.addAssign( linksWidth );

						// colors are the same for all vertices of both quads
						const linkColor = getInstanceColor( instanceIndex );

						// store the minimum lifetime of the closest particles in the w component of colors
						const l1 = max( 0.0, min( closestLife1, life ) ).pow( 0.8 ); // pow is here to apply a slight curve to the opacity
						const l2 = max( 0.0, min( closestLife2, life ) ).pow( 0.8 );

						Loop( 4, ( { i } ) => {

							linksColors.element( firstLinkIndex.add( i ) ).xyz.assign( linkColor );
							linksColors.element( firstLinkIndex.add( i ) ).w.assign( l1 );
							linksColors.element( secondLinkIndex.add( i ) ).xyz.assign( linkColor );
							linksColors.element( secondLinkIndex.add( i ) ).w.assign( l2 );

						} );

					} );

				} )().compute( nbParticles ).setName( 'Update Particles' );

				spawnParticles = Fn( () => {

					const particleIndex = spawnIndex.add( instanceIndex ).mod( nbParticles ).toInt();
					const position = particlePositions.element( particleIndex ).xyz;
					const life = particlePositions.element( particleIndex ).w;
					const velocity = particleVelocities.element( particleIndex ).xyz;

					life.assign( 1.0 ); // sets it alive

					// random spherical direction
					const rRange = float( 0.01 );
					const rTheta = hash( particleIndex ).mul( TWO_PI );
					const rPhi = hash( particleIndex.add( 1 ) ).mul( PI );
					const rx = sin( rTheta ).mul( cos( rPhi ) );
					const ry = sin( rTheta ).mul( sin( rPhi ) );
					const rz = cos( rTheta );
					const rDir = vec3( rx, ry, rz );

					// position is interpolated between the previous cursor position and the current one over the number of particles spawned
					const pos = mix( previousSpawnPosition, spawnPosition, instanceIndex.toFloat().div( nbToSpawn.sub( 1 ).toFloat() ).clamp() );
					position.assign( pos.add( rDir.mul( rRange ) ) );

					// start in that direction
					velocity.assign( rDir.mul( 5.0 ) );

				} )().compute( nbToSpawn.value ).setName( 'Spawn Particles' );


				// background , an inverted icosahedron
				const backgroundGeom = new THREE.IcosahedronGeometry( 100, 5 ).applyMatrix4( new THREE.Matrix4().makeScale( - 1, 1, 1 ) );
				const backgroundMaterial = new THREE.MeshStandardNodeMaterial();
				backgroundMaterial.roughness = 0.4;
				backgroundMaterial.metalness = 0.9;
				backgroundMaterial.flatShading = true;
				backgroundMaterial.colorNode = color( 0x0 );

				const backgroundMesh = new THREE.Mesh( backgroundGeom, backgroundMaterial );
				scene.add( backgroundMesh );

				// light for the background
				light = new THREE.PointLight( 0xffffff, 3000 );
				scene.add( light );

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode( 'output' );

				const bloomPass = bloom( scenePassColor, 0.75, 0.1, 0.5 );

				postProcessing.outputNode = scenePassColor.add( bloomPass );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.autoRotate = true;
				controls.maxDistance = 75;
				window.addEventListener( 'resize', onWindowResize );

				// pointer handling

				window.addEventListener( 'pointermove', onPointerMove );

				// GUI

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.add( controls, 'autoRotate' ).name( 'Auto Rotate' );
				gui.add( controls, 'autoRotateSpeed', - 10.0, 10.0, 0.01 ).name( 'Auto Rotate Speed' );

				const partFolder = gui.addFolder( 'Particles' );
				partFolder.add( timeScale, 'value', 0.0, 4.0, 0.01 ).name( 'timeScale' );
				partFolder.add( nbToSpawn, 'value', 1, 100, 1 ).name( 'Spawn rate' );
				partFolder.add( particleSize, 'value', 0.01, 3.0, 0.01 ).name( 'Size' );
				partFolder.add( particleLifetime, 'value', 0.01, 2.0, 0.01 ).name( 'Lifetime' );
				partFolder.add( linksWidth, 'value', 0.001, 0.1, 0.001 ).name( 'Links width' );
				partFolder.add( colorVariance, 'value', 0.0, 10.0, 0.01 ).name( 'Color variance' );
				partFolder.add( colorRotationSpeed, 'value', 0.0, 5.0, 0.01 ).name( 'Color rotation speed' );

				const turbFolder = gui.addFolder( 'Turbulence' );
				turbFolder.add( turbFriction, 'value', 0.0, 0.3, 0.01 ).name( 'Friction' );
				turbFolder.add( turbFrequency, 'value', 0.0, 1.0, 0.01 ).name( 'Frequency' );
				turbFolder.add( turbAmplitude, 'value', 0.0, 10.0, 0.01 ).name( 'Amplitude' );
				turbFolder.add( turbOctaves, 'value', 1, 9, 1 ).name( 'Octaves' );
				turbFolder.add( turbLacunarity, 'value', 1.0, 5.0, 0.01 ).name( 'Lacunarity' );
				turbFolder.add( turbGain, 'value', 0.0, 1.0, 0.01 ).name( 'Gain' );

				const bloomFolder = gui.addFolder( 'bloom' );
				bloomFolder.add( bloomPass.threshold, 'value', 0, 2.0, 0.01 ).name( 'Threshold' );
				bloomFolder.add( bloomPass.strength, 'value', 0, 10, 0.01 ).name( 'Strength' );
				bloomFolder.add( bloomPass.radius, 'value', 0, 1, 0.01 ).name( 'Radius' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( e ) {

				screenPointer.x = ( e.clientX / window.innerWidth ) * 2 - 1;
				screenPointer.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

			}

			function updatePointer() {

				raycaster.setFromCamera( screenPointer, camera );
				raycaster.ray.intersectPlane( raycastPlane, scenePointer );

			}

			function animate() {

				timer.update();

				// compute particles
				renderer.compute( updateParticles );
				renderer.compute( spawnParticles );

				// update particle index for next spawn
				spawnIndex.value = ( spawnIndex.value + nbToSpawn.value ) % nbParticles;

				// update raycast plane to face camera
				raycastPlane.normal.applyEuler( camera.rotation );
				updatePointer();

				// lerping spawn position
				previousSpawnPosition.value.copy( spawnPosition.value );
				spawnPosition.value.lerp( scenePointer, 0.1 );

				// rotating colors
				colorOffset.value += timer.getDelta() * colorRotationSpeed.value * timeScale.value;

				const elapsedTime = timer.getElapsed();
				light.position.set(
					Math.sin( elapsedTime * 0.5 ) * 30,
					Math.cos( elapsedTime * 0.3 ) * 30,
					Math.sin( elapsedTime * 0.2 ) * 30,
				);

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_vfx_tornado.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - vfx tornado</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>VFX Tornado</span>
			</div>

			<small>
				Based on <a href="https://threejs-journey.com/lessons/galaxy-generator" target="_blank" rel="noopener">Three.js Journey</a> lesson.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { luminance, cos, min, time, atan, uniform, pass, PI, TWO_PI, color, positionLocal, sin, texture, Fn, uv, vec2, vec3, vec4 } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let camera, scene, renderer, postProcessing, controls;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 50 );
				camera.position.set( 1, 1, 3 );

				scene = new THREE.Scene();

				// textures

				const textureLoader = new THREE.TextureLoader();
				const perlinTexture = textureLoader.load( './textures/noises/perlin/rgb-256x256.png' );
				perlinTexture.wrapS = THREE.RepeatWrapping;
				perlinTexture.wrapT = THREE.RepeatWrapping;

				// TSL functions

				const toRadialUv = Fn( ( [ uv, multiplier, rotation, offset ] ) => {

					const centeredUv = uv.sub( 0.5 ).toVar();
					const distanceToCenter = centeredUv.length();
					const angle = atan( centeredUv.y, centeredUv.x );
					const radialUv = vec2( angle.add( PI ).div( TWO_PI ), distanceToCenter ).toVar();
					radialUv.mulAssign( multiplier );
					radialUv.x.addAssign( rotation );
					radialUv.y.addAssign( offset );

					return radialUv;

				} );

				const toSkewedUv = Fn( ( [ uv, skew ] ) => {

					return vec2(
						uv.x.add( uv.y.mul( skew.x ) ),
						uv.y.add( uv.x.mul( skew.y ) )
					);

				} );

				const twistedCylinder = Fn( ( [ position, parabolStrength, parabolOffset, parabolAmplitude, time ] ) => {

					const angle = atan( position.z, position.x ).toVar();
					const elevation = position.y;

					// parabol
					const radius = parabolStrength.mul( position.y.sub( parabolOffset ) ).pow( 2 ).add( parabolAmplitude ).toVar();

					// turbulences
					radius.addAssign( sin( elevation.sub( time ).mul( 20 ).add( angle.mul( 2 ) ) ).mul( 0.05 ) );

					const twistedPosition = vec3(
						cos( angle ).mul( radius ),
						elevation,
						sin( angle ).mul( radius )
					);

					return twistedPosition;

				} );

				// uniforms

				const emissiveColor = uniform( color( '#ff8b4d' ) );
				const timeScale = uniform( 0.2 );
				const parabolStrength = uniform( 1 );
				const parabolOffset = uniform( 0.3 );
				const parabolAmplitude = uniform( 0.2 );

				// tornado floor

				const floorMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, wireframe: false } );

				floorMaterial.outputNode = Fn( () => {

					const scaledTime = time.mul( timeScale );

					// noise 1
					const noise1Uv = toRadialUv(
						uv(),
						vec2( 0.5, 0.5 ),
						scaledTime,
						scaledTime
					);
					noise1Uv.assign( toSkewedUv(
						noise1Uv,
						vec2( - 1, 0 )
					) );
					noise1Uv.mulAssign( vec2( 4, 1 ) );
					const noise1 = texture( perlinTexture, noise1Uv, 1 ).r.remap( 0.45, 0.7 );

					// noise 2
					const noise2Uv = toRadialUv(
						uv(),
						vec2( 2, 8 ),
						scaledTime.mul( 2 ),
						scaledTime.mul( 8 )
					);
					noise2Uv.assign( toSkewedUv(
						noise2Uv,
						vec2( - 0.25, 0 )
					) );
					noise2Uv.mulAssign( vec2( 2, 0.25 ) );
					const noise2 = texture( perlinTexture, noise2Uv, 1 ).b.remap( 0.45, 0.7 );

					// outer fade
					const distanceToCenter = uv().sub( 0.5 ).toVar();
					const outerFade = min(
						distanceToCenter.length().oneMinus().smoothstep( 0.5, 0.9 ),
						distanceToCenter.length().smoothstep( 0, 0.2 )
					);

					// effect
					const effect = noise1.mul( noise2 ).mul( outerFade ).toVar();

					// output
					return vec4(
						emissiveColor.mul( effect.step( 0.2 ) ).mul( 3 ), // Emissive
						effect.smoothstep( 0, 0.01 ) // Alpha
					);

				} )();

				const floor = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), floorMaterial );
				floor.rotation.x = - Math.PI * 0.5;
				scene.add( floor );

				// tornado cylinder geometry

				const cylinderGeometry = new THREE.CylinderGeometry( 1, 1, 1, 20, 20, true );
				cylinderGeometry.translate( 0, 0.5, 0 );

				// tornado emissive cylinder

				const emissiveMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, side: THREE.DoubleSide, wireframe: false } );

				emissiveMaterial.positionNode = twistedCylinder( positionLocal, parabolStrength, parabolOffset, parabolAmplitude.sub( 0.05 ), time.mul( timeScale ) );

				emissiveMaterial.outputNode = Fn( () => {

					const scaledTime = time.mul( timeScale );

					// noise 1
					const noise1Uv = uv().add( vec2( scaledTime, scaledTime.negate() ) ).toVar();
					noise1Uv.assign( toSkewedUv(
						noise1Uv,
						vec2( - 1, 0 )
					) );
					noise1Uv.mulAssign( vec2( 2, 0.25 ) );
					const noise1 = texture( perlinTexture, noise1Uv, 1 ).r.remap( 0.45, 0.7 );

					// noise 2
					const noise2Uv = uv().add( vec2( scaledTime.mul( 0.5 ), scaledTime.negate() ) ).toVar();
					noise2Uv.assign( toSkewedUv(
						noise2Uv,
						vec2( - 1, 0 )
					) );
					noise2Uv.mulAssign( vec2( 5, 1 ) );
					const noise2 = texture( perlinTexture, noise2Uv, 1 ).g.remap( 0.45, 0.7 );

					// outer fade
					const outerFade = min(
						uv().y.smoothstep( 0, 0.1 ),
						uv().y.oneMinus().smoothstep( 0, 0.4 )
					);

					// effect
					const effect = noise1.mul( noise2 ).mul( outerFade );

					const emissiveColorLuminance = luminance( emissiveColor );

					// output
					return vec4(
						emissiveColor.mul( 1.2 ).div( emissiveColorLuminance ), // emissive
						effect.smoothstep( 0, 0.1 ) // alpha
					);

				} )();

				const emissive = new THREE.Mesh( cylinderGeometry, emissiveMaterial );
				emissive.scale.set( 1, 1, 1 );
				scene.add( emissive );

				// tornado dark cylinder

				const darkMaterial = new THREE.MeshBasicNodeMaterial( { transparent: true, side: THREE.DoubleSide, wireframe: false } );

				darkMaterial.positionNode = twistedCylinder( positionLocal, parabolStrength, parabolOffset, parabolAmplitude, time.mul( timeScale ) );

				darkMaterial.outputNode = Fn( () => {

					const scaledTime = time.mul( timeScale ).add( 123.4 );

					// noise 1
					const noise1Uv = uv().add( vec2( scaledTime, scaledTime.negate() ) ).toVar();
					noise1Uv.assign( toSkewedUv(
						noise1Uv,
						vec2( - 1, 0 )
					) );
					noise1Uv.mulAssign( vec2( 2, 0.25 ) );
					const noise1 = texture( perlinTexture, noise1Uv, 1 ).g.remap( 0.45, 0.7 );

					// noise 2
					const noise2Uv = uv().add( vec2( scaledTime.mul( 0.5 ), scaledTime.negate() ) ).toVar();
					noise2Uv.assign( toSkewedUv(
						noise2Uv,
						vec2( - 1, 0 )
					) );
					noise2Uv.mulAssign( vec2( 5, 1 ) );
					const noise2 = texture( perlinTexture, noise2Uv, 1 ).b.remap( 0.45, 0.7 );

					// outer fade
					const outerFade = min(
						uv().y.smoothstep( 0, 0.2 ),
						uv().y.oneMinus().smoothstep( 0, 0.4 )
					);

					// effect
					const effect = noise1.mul( noise2 ).mul( outerFade );

					return vec4(
						vec3( 0 ),
						effect.smoothstep( 0, 0.01 )
					);

				} )();

				const dark = new THREE.Mesh( cylinderGeometry, darkMaterial );
				dark.scale.set( 1, 1, 1 );
				scene.add( dark );

				// renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setClearColor( 0x201919 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );
				const scenePassColor = scenePass.getTextureNode( 'output' );

				const bloomPass = bloom( scenePassColor, 1, 0.1, 1 );

				postProcessing.outputNode = scenePassColor.add( bloomPass );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.y = 0.4;
				controls.enableDamping = true;
				controls.minDistance = 0.1;
				controls.maxDistance = 50;

				window.addEventListener( 'resize', onWindowResize );

				// debug

				const gui = renderer.inspector.createParameters( 'Parameters' );

				gui.addColor( { color: emissiveColor.value.getHexString( THREE.SRGBColorSpace ) }, 'color' ).onChange( value => emissiveColor.value.set( value ) ).name( 'emissiveColor' );
				gui.add( timeScale, 'value', - 1, 1, 0.01 ).name( 'timeScale' );
				gui.add( parabolStrength, 'value', 0, 2, 0.01 ).name( 'parabolStrength' );
				gui.add( parabolOffset, 'value', 0, 1, 0.01 ).name( 'parabolOffset' );
				gui.add( parabolAmplitude, 'value', 0, 2, 0.01 ).name( 'parabolAmplitude' );

				const bloomGui = gui.addFolder( 'bloom' );
				bloomGui.add( bloomPass.strength, 'value', 0, 10, 0.01 ).name( 'strength' );
				bloomGui.add( bloomPass.radius, 'value', 0, 1, 0.01 ).name( 'radius' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function animate() {

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_tsl_wood.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Three.js webgpu - procedural wood materials</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="author" content="Logan Seeley"/>
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>

			body {
				color:rgb(55, 55, 55);
			}

		</style>
	</head>
	<body>

		<div id="info" class="invert">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Procedural Woord Material</span>
			</div>

			<small>
				By Logan Seeley, based on <a href="https://www.youtube.com/watch?v=n7e0vxgBS8A">Lance Phan's Blender tutorial.</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import * as TSL from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

			import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
			import { WoodNodeMaterial, WoodGenuses, Finishes } from 'three/addons/materials/WoodNodeMaterial.js';

			let scene, base, camera, renderer, controls, font, blockGeometry, gui;

			// Helper function to get grid position
			function getGridPosition( woodIndex, finishIndex ) {

				return {
					x: 0,
					y: ( finishIndex - Finishes.length / 2 ) * 1.0,
					z: ( woodIndex - WoodGenuses.length / 2 + 0.45 ) * 1.0
				};

			}

			// Helper function to create the grid plane
			function createGridPlane() {

				const material = new THREE.MeshBasicNodeMaterial();

				const gridXZ = TSL.Fn( ( [ gridSize = TSL.float( 1.0 ), dotWidth = TSL.float( 0.1 ), lineWidth = TSL.float( 0.02 ) ] ) => {

					const coord = TSL.positionWorld.xz.div( gridSize );
					const grid = TSL.fract( coord );

					// Screen-space derivative for automatic antialiasing
					const fw = TSL.fwidth( coord );
					const smoothing = TSL.max( fw.x, fw.y ).mul( 0.5 );

					// Create squares at cell centers
					const squareDist = TSL.max( TSL.abs( grid.x.sub( 0.5 ) ), TSL.abs( grid.y.sub( 0.5 ) ) );
					const dots = TSL.smoothstep( dotWidth.add( smoothing ), dotWidth.sub( smoothing ), squareDist );

					// Create grid lines
					const lineX = TSL.smoothstep( lineWidth.add( smoothing ), lineWidth.sub( smoothing ), TSL.abs( grid.x.sub( 0.5 ) ) );
					const lineZ = TSL.smoothstep( lineWidth.add( smoothing ), lineWidth.sub( smoothing ), TSL.abs( grid.y.sub( 0.5 ) ) );
					const lines = TSL.max( lineX, lineZ );

					return TSL.max( dots, lines );

				} );

				const radialGradient = TSL.Fn( ( [ radius = TSL.float( 10.0 ), falloff = TSL.float( 1.0 ) ] ) => {

					return TSL.smoothstep( radius, radius.sub( falloff ), TSL.length( TSL.positionWorld ) );

				} );

				// Create grid pattern
				const gridPattern = gridXZ( 1.0, 0.03, 0.005 );
				const baseColor = TSL.vec4( 1.0, 1.0, 1.0, 0.0 );
				const gridColor = TSL.vec4( 0.5, 0.5, 0.5, 1.0 );

				// Mix base color with grid lines
				material.colorNode = gridPattern.mix( baseColor, gridColor ).mul( radialGradient( 30.0, 20.0 ) );
				material.transparent = true;

				const plane = new THREE.Mesh( new THREE.CircleGeometry( 40 ), material );
				plane.rotation.x = - Math.PI / 2;
				plane.renderOrder = - 1;

				return plane;

			}

			// Helper function to create and position labels
			function createLabel( text, font, material, position ) {

				const txt_geo = new TextGeometry( text, {
					font: font,
					size: 0.1,
					depth: 0.001,
					curveSegments: 12,
					bevelEnabled: false
				} );

				txt_geo.computeBoundingBox();
				const offx = - 0.5 * ( txt_geo.boundingBox.max.x - txt_geo.boundingBox.min.x );
				const offy = - 0.5 * ( txt_geo.boundingBox.max.y - txt_geo.boundingBox.min.y );
				const offz = - 0.5 * ( txt_geo.boundingBox.max.z - txt_geo.boundingBox.min.z );
				txt_geo.translate( offx, offy, offz );

				const label = new THREE.Group();
				const mesh = new THREE.Mesh( txt_geo );
				label.add( mesh );

				// Apply default rotation for labels
				label.rotateY( - Math.PI / 2 );

				label.children[ 0 ].material = material;
				label.position.copy( position );
				base.add( label );
			
			}

			async function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );
			

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( - 0.1, 5, 0.548 );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( 1.0 ); // important for performance
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1.0;
				renderer.inspector = new Inspector();
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, 0.548 );

				gui = renderer.inspector.createParameters( 'Parameters' );
			
				font = await new FontLoader().loadAsync( './fonts/helvetiker_regular.typeface.json' );

				// Create shared block geometry
				blockGeometry = new RoundedBoxGeometry( 0.125, 0.9, 0.9, 10, 0.02 );

				base = new THREE.Group();
				base.rotation.set( 0, 0, - Math.PI / 2 );
				base.position.set( 0, 0, 0.548 );
				scene.add( base );

				const text_mat = new THREE.MeshStandardMaterial();
				text_mat.colorNode = TSL.color( '#000000' );

				// Create finish labels (using negative wood index for left column)
				for ( let y = 0; y < Finishes.length; y ++ ) {

					createLabel( Finishes[ y ], font, text_mat, getGridPosition( - 1, y ) );

				}

				// Create and add the grid plane
				const plane = createGridPlane();
				scene.add( plane );

				await new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.loadAsync( 'san_giuseppe_bridge_2k.hdr' ).then( ( texture ) => {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.environment = texture;
						scene.environmentIntensity = 2;

					} );

				// Create wood labels (using negative finish index for top row)
				for ( let x = 0; x < WoodGenuses.length; x ++ ) {

					createLabel( WoodGenuses[ x ], font, text_mat, getGridPosition( x, - 1 ) );

				}

				// Create wood blocks
				for ( let x = 0; x < WoodGenuses.length; x ++ ) {

					for ( let y = 0; y < Finishes.length; y ++ ) {

						const material = WoodNodeMaterial.fromPreset( WoodGenuses[ x ], Finishes[ y ] );
						const cube = new THREE.Mesh( blockGeometry, material );

						cube.position.copy( getGridPosition( x, y ) );
						material.transformationMatrix = new THREE.Matrix4().setPosition( new THREE.Vector3( -0.1, 0, Math.random() ) );
						base.add( cube );

						await new Promise( resolve => setTimeout( resolve, 0 ) );

					}

				}

				add_custom_wood( text_mat );

			}

			function render() {

				controls.update();

				renderer.render( scene, camera );
			
			}

			window.addEventListener( 'resize', () => {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			} );

			if ( WebGPU.isAvailable() ) {

				init();
			
			} else {

				document.body.appendChild( WebGPU.getErrorMessage() );

			}



			function add_custom_wood( text_mat ) {

				// Add "Custom" label (positioned at the end of the grid)
				createLabel( 'custom', font, text_mat, getGridPosition( Math.round( WoodGenuses.length / 2 - 1 ), 5 ) );

				// Create custom wood material with unique parameters
				const customMaterial = new WoodNodeMaterial( {
					centerSize: 1.11,
					largeWarpScale: 0.32,
					largeGrainStretch: 0.24,
					smallWarpStrength: 0.059,
					smallWarpScale: 2,
					fineWarpStrength: 0.006,
					fineWarpScale: 32.8,
					ringThickness: 1/34,
					ringBias: 0.03,
					ringSizeVariance: 0.03,
					ringVarianceScale: 4.4,
					barkThickness: 0.3,
					splotchScale: 0.2,
					splotchIntensity: 0.541,
					cellScale: 910,
					cellSize: 0.1,
					darkGrainColor: new THREE.Color( '#0c0504') ,
					lightGrainColor: new THREE.Color( '#926c50' ),
					clearcoat: 1,
					clearcoatRoughness: 0.2
				} );

				gui.add( customMaterial, 'centerSize', 0.0, 2.0, 0.01 ).name( 'centerSize' );
				gui.add( customMaterial, 'largeWarpScale', 0.0, 1.0, 0.001 ).name( 'largeWarpScale' );
				gui.add( customMaterial, 'largeGrainStretch', 0.0, 1.0, 0.001 ).name( 'largeGrainStretch' );
				gui.add( customMaterial, 'smallWarpStrength', 0.0, 0.2, 0.001 ).name( 'smallWarpStrength' );
				gui.add( customMaterial, 'smallWarpScale', 0.0, 5.0, 0.01 ).name( 'smallWarpScale' );
				gui.add( customMaterial, 'fineWarpStrength', 0.0, 0.05, 0.001 ).name( 'fineWarpStrength' );
				gui.add( customMaterial, 'fineWarpScale', 0.0, 50.0, 0.1 ).name( 'fineWarpScale' );
				gui.add( customMaterial, 'ringThickness', 0.0, 0.1, 0.001 ).name( 'ringThickness' );
				gui.add( customMaterial, 'ringBias', -0.2, 0.2, 0.001 ).name( 'ringBias' );
				gui.add( customMaterial, 'ringSizeVariance', 0.0, 0.2, 0.001 ).name( 'ringSizeVariance' );
				gui.add( customMaterial, 'ringVarianceScale', 0.0, 10.0, 0.1 ).name( 'ringVarianceScale' );
				gui.add( customMaterial, 'barkThickness', 0.0, 1.0, 0.01 ).name( 'barkThickness' );
				gui.add( customMaterial, 'splotchScale', 0.0, 1.0, 0.01 ).name( 'splotchScale' );
				gui.add( customMaterial, 'splotchIntensity', 0.0, 1.0, 0.01 ).name( 'splotchIntensity' );
				gui.add( customMaterial, 'cellScale', 100, 2000, 1 ).name( 'cellScale' );
				gui.add( customMaterial, 'cellSize', 0.01, 0.5, 0.001 ).name( 'cellSize' );
				gui.addColor( { darkGrainColor: '#0c0504' }, 'darkGrainColor' ).onChange( v => customMaterial.darkGrainColor.set( v ) );
				gui.addColor( { lightGrainColor: '#926c50' }, 'lightGrainColor' ).onChange( v => customMaterial.lightGrainColor.set( v ) );
				gui.add( customMaterial, 'clearcoat', 0.0, 1.0, 0.01 ).name( 'clearcoat' );
				gui.add( customMaterial, 'clearcoatRoughness', 0.0, 1.0, 0.01 ).name( 'clearcoatRoughness' );

				const cube = new THREE.Mesh( blockGeometry, customMaterial );

				customMaterial.transformationMatrix = new THREE.Matrix4().setPosition( new THREE.Vector3( -0.1, 0, Math.random() ) );
				cube.position.copy( getGridPosition( Math.round( WoodGenuses.length / 2 ), 5 ) );

				base.add( cube );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_video_frame.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - video frames</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Video Frames</span>
			</div>

			<small>
				Decodes all frames from a MP4 file and renders them onto a plane as fast as possible.<br/>
				<a href="https://github.com/gpac/mp4box.js/" target="_blank" rel="noopener">mp4box.js</a> used for MP4 parsing.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { MP4Demuxer } from 'three/addons/libs/demuxer_mp4.js';

			let camera, scene, renderer;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .25, 10 );
				camera.position.set( 0, 0, 1 );

				scene = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry();

				const videoTexture = new THREE.VideoFrameTexture();
				videoTexture.colorSpace = THREE.SRGBColorSpace;

				// eslint-disable-next-line compat/compat
				const decoder = new VideoDecoder( {
					output( frame ) {

						// To avoid video decoder stalls, we should close the VideoFrame which is no longer needed. https://w3c.github.io/webcodecs/#dom-videodecoder-decode
						if ( videoTexture.image instanceof VideoFrame ) videoTexture.image.close();

						videoTexture.setFrame( frame );
			
					},
					error( e ) {

						console.error( 'VideoDecoder:', e );

					}
				} );

				new MP4Demuxer( './textures/sintel.mp4', {
					onConfig( config ) {

						decoder.configure( config );

					},
					onChunk( chunk ) {

						decoder.decode( chunk );

					},
					setStatus( kind, status ) {

						console.info( 'MP4Demuxer:', kind );

						if ( kind === 'fetch' && status === 'Done' ) {

							decoder.flush().then( () => {

								decoder.close();

								// In case our VideoFrameTexture is no longer needed, we should close its backed VideoFrame, see issue #30379:
								if ( videoTexture.image instanceof VideoFrame ) videoTexture.image.close();

								videoTexture.image = null;

								scene.remove( mesh );

							} );

						}

					}
				} );
			
				const material = new THREE.MeshBasicMaterial( { map: videoTexture } );

				const mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}


		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_video_panorama.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - video panorama</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			body {
				touch-action: none;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Video Panorama</span>
			</div>

			<small>Video panorama using equirectangular projection.</small>
		</div>

		<div id="container"></div>

		<video id="video" loop muted crossOrigin="anonymous" playsinline style="display:none">
			<source src="textures/pano.webm">
			<source src="textures/pano.mp4">
		</video>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			let camera, scene, renderer;

			let isUserInteracting = false,
				lon = 0, lat = 0,
				phi = 0, theta = 0,
				onPointerDownPointerX = 0,
				onPointerDownPointerY = 0,
				onPointerDownLon = 0,
				onPointerDownLat = 0;

			const distance = .5;

			init();

			function init() {

				const container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .25, 10 );

				scene = new THREE.Scene();

				const geometry = new THREE.SphereGeometry( 5, 60, 40 );
				// invert the geometry on the x-axis so that all of the faces point inward
				geometry.scale( - 1, 1, 1 );

				const video = document.getElementById( 'video' );
				video.play();

				const texture = new THREE.VideoTexture( video );
				texture.colorSpace = THREE.SRGBColorSpace;
				const material = new THREE.MeshBasicMaterial( { map: texture } );

				const mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'pointerdown', onPointerDown );
				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerup', onPointerUp );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerDown( event ) {

				isUserInteracting = true;

				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;

				onPointerDownLon = lon;
				onPointerDownLat = lat;

			}

			function onPointerMove( event ) {

				if ( isUserInteracting === true ) {

					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( onPointerDownPointerY - event.clientY ) * 0.1 + onPointerDownLat;

				}

			}

			function onPointerUp() {

				isUserInteracting = false;

			}

			function animate() {

				update();

			}

			function update() {

				lat = Math.max( - 85, Math.min( 85, lat ) );
				phi = THREE.MathUtils.degToRad( 90 - lat );
				theta = THREE.MathUtils.degToRad( lon );

				camera.position.x = distance * Math.sin( phi ) * Math.cos( theta );
				camera.position.y = distance * Math.cos( phi );
				camera.position.z = distance * Math.sin( phi ) * Math.sin( theta );

				camera.lookAt( 0, 0, 0 );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_volume_caustics.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - volumetric caustics</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Volumetric Caustics</span>
			</div>

			<small>Real-time volumetric caustics effects.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { uniform, refract, div, frameId, lightViewPosition, float, positionView, positionViewDirection, screenUV, pass, texture3D, time, screenCoordinate, normalView, texture, Fn, vec2, vec3 } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { bayer16 } from 'three/addons/tsl/math/Bayer.js';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			let camera, scene, renderer, controls;
			let postProcessing;
			let gltf;

			init();

			async function init() {

				const LAYER_VOLUMETRIC_LIGHTING = 10;

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.025, 5 );
				camera.position.set( - 0.7, 0.2, 0.2 );

				scene = new THREE.Scene();

				// Light

				const spotLight = new THREE.SpotLight( 0xffffff, 1 );
				spotLight.position.set( .2, .3, .2 );
				spotLight.castShadow = true;
				spotLight.angle = Math.PI / 6;
				spotLight.penumbra = 1;
				spotLight.decay = 2;
				spotLight.distance = 0;
				spotLight.shadow.mapType = THREE.HalfFloatType; // For HDR Caustics
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = .1;
				spotLight.shadow.camera.far = 1;
				spotLight.shadow.bias = - .003;
				spotLight.shadow.intensity = .95;
				spotLight.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				scene.add( spotLight );

				// Model / Textures

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/' );
				dracoLoader.setDecoderConfig( { type: 'js' } );

				gltf = ( await new GLTFLoader().setDRACOLoader( dracoLoader ).loadAsync( './models/gltf/duck.glb' ) ).scene;
				gltf.scale.setScalar( .5 );
				scene.add( gltf );

				const causticMap = new THREE.TextureLoader().load( './textures/opengameart/Caustic_Free.jpg' );
				causticMap.wrapS = causticMap.wrapT = THREE.RepeatWrapping;
				causticMap.colorSpace = THREE.SRGBColorSpace;

				// Material

				const duck = gltf.children[ 0 ];
				duck.material = new THREE.MeshPhysicalNodeMaterial();
				duck.material.side = THREE.DoubleSide;
				duck.material.transparent = true;
				duck.material.color = new THREE.Color( 0xFFD700 );
				duck.material.transmission = 1;
				duck.material.thickness = .25;
				duck.material.ior = 1.5;
				duck.material.metalness = 0;
				duck.material.roughness = .1;
				duck.castShadow = true;

				// TSL Shader

				const causticOcclusion = uniform( 1 );

				const causticEffect = Fn( () => {

					const refractionVector = refract( positionViewDirection.negate(), normalView, div( 1.0, duck.material.ior ) ).normalize();
					const viewZ = normalView.z.pow( causticOcclusion );

					const textureUV = refractionVector.xy.mul( .6 );

					const causticColor = uniform( duck.material.color );
					const chromaticAberrationOffset = normalView.z.pow( - .9 ).mul( .004 );

					const causticProjection = vec3(
						texture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x.negate(), 0 ) ) ).r,
						texture( causticMap, textureUV.add( vec2( 0, chromaticAberrationOffset.y.negate() ) ) ).g,
						texture( causticMap, textureUV.add( vec2( chromaticAberrationOffset.x, chromaticAberrationOffset.y ) ) ).b
					);

					return causticProjection.mul( viewZ.mul( 60 ) ).add( viewZ ).mul( causticColor );

				} )().toVar();

				duck.material.castShadowNode = causticEffect;

				duck.material.emissiveNode = Fn( () => {

					// Custom emissive for illuminating backside of the mesh based on the caustic effect and light direction

					const thicknessPowerNode = float( 3.0 );

					const scatteringHalf = lightViewPosition( spotLight ).sub( positionView ).normalize();
					const scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ) );

					return causticEffect.mul( scatteringDot.add( .1 ) ).mul( .02 );

				} )();

				// Ground

				const textureLoader = new THREE.TextureLoader();
				const map = textureLoader.load( 'textures/hardwood2_diffuse.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.repeat.set( 10, 10 );

				const geometry = new THREE.PlaneGeometry( 2, 2 );
				const material = new THREE.MeshStandardMaterial( { color: 0 } );

				const ground = new THREE.Mesh( geometry, material );
				ground.rotation.x = - Math.PI / 2;
				ground.receiveShadow = true;
				scene.add( ground );

				// Renderer

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				// GUI

				const gui = renderer.inspector.createParameters( 'Volumetric Caustics' );
				gui.add( causticOcclusion, 'value', 0, 20 ).name( 'caustic occlusion' );
				gui.addColor( duck.material, 'color' ).name( 'material color' );

				// Post-Processing

				postProcessing = new THREE.PostProcessing( renderer );

				// Layers

				const volumetricLightingIntensity = uniform( .7 );

				const volumetricLayer = new THREE.Layers();
				volumetricLayer.disableAll();
				volumetricLayer.enable( LAYER_VOLUMETRIC_LIGHTING );

				// Volumetric Fog Area

				function createTexture3D() {

					let i = 0;

					const size = 128;
					const data = new Uint8Array( size * size * size );

					const scale = 10;
					const perlin = new ImprovedNoise();

					const repeatFactor = 5.0;

					for ( let z = 0; z < size; z ++ ) {

						for ( let y = 0; y < size; y ++ ) {

							for ( let x = 0; x < size; x ++ ) {

								const nx = ( x / size ) * repeatFactor;
								const ny = ( y / size ) * repeatFactor;
								const nz = ( z / size ) * repeatFactor;

								const noiseValue = perlin.noise( nx * scale, ny * scale, nz * scale );

								data[ i ] = ( 128 + 128 * noiseValue );

								i ++;

							}

						}

					}

					const texture = new THREE.Data3DTexture( data, size, size, size );
					texture.format = THREE.RedFormat;
					texture.minFilter = THREE.LinearFilter;
					texture.magFilter = THREE.LinearFilter;
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					texture.unpackAlignment = 1;
					texture.needsUpdate = true;

					return texture;

				}

				const noiseTexture3D = createTexture3D();

				const smokeAmount = uniform( 3 );

				const volumetricMaterial = new THREE.VolumeNodeMaterial();
				volumetricMaterial.steps = 20;
				volumetricMaterial.offsetNode = bayer16( screenCoordinate.add( frameId ) ); // Add dithering to reduce banding
				volumetricMaterial.scatteringNode = Fn( ( { positionRay } ) => {

					// Return the amount of fog based on the noise texture

					const timeScaled = vec3( time.mul( .01 ), 0, time.mul( .03 ) );

					const sampleGrain = ( scale, timeScale = 1 ) => texture3D( noiseTexture3D, positionRay.add( timeScaled.mul( timeScale ) ).mul( scale ).mod( 1 ), 0 ).r.add( .5 );

					let density = sampleGrain( 1 );
					density = density.mul( sampleGrain( .5, 1 ) );
					density = density.mul( sampleGrain( .2, 2 ) );

					return smokeAmount.mix( 1, density );

				} );

				const volumetricMesh = new THREE.Mesh( new THREE.BoxGeometry( 1.5, .5, 1.5 ), volumetricMaterial );
				volumetricMesh.receiveShadow = true;
				volumetricMesh.position.y = .25;
				volumetricMesh.layers.disableAll();
				volumetricMesh.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				scene.add( volumetricMesh );

				// Scene Pass

				const scenePass = pass( scene, camera ).toInspector();
				scenePass.name = 'Scene';

				const sceneDepth = scenePass.getTextureNode( 'depth' );
				sceneDepth.name = 'Scene Depth';

				// Material - Apply occlusion depth of volumetric lighting based on the scene depth

				volumetricMaterial.depthNode = sceneDepth.sample( screenUV );

				// Volumetric Lighting Pass

				const volumetricPass = pass( scene, camera, { depthBuffer: false, samples: 0 } ).toInspector( 'Volumetric Lighting / Raw' );
				volumetricPass.name = 'Volumetric Lighting';
				volumetricPass.setLayers( volumetricLayer );
				volumetricPass.setResolutionScale( .5 );

				// Compose and Denoise

				const bloomPass = bloom( volumetricPass, 1, 1, 0 ).toInspector( 'Volumetric Lighting / Mip-Chain Gaussian Blur' );
				bloomPass.name = 'Bloom';

				const scenePassColor = scenePass.add( bloomPass.mul( volumetricLightingIntensity ) );

				postProcessing.outputNode = scenePassColor;

				// Controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.z = - .05;
				controls.target.y = .02;
				controls.maxDistance = 1;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				for ( const mesh of gltf.children ) {

					mesh.rotation.y -= .01;

				}

				controls.update();

				postProcessing.render();

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_volume_cloud.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - volumetric cloud</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Volumetric Cloud</span>
			</div>

			<small>
				Volumetric cloud using 3D texture raymarching.
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { float, vec3, vec4, If, Break, Fn, smoothstep, texture3D, uniform } from 'three/tsl';

			import { RaymarchingBox } from 'three/addons/tsl/utils/Raymarching.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let renderer, scene, camera;
			let mesh;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 0, 1.5 );

				new OrbitControls( camera, renderer.domElement );

				// Sky

				const canvas = document.createElement( 'canvas' );
				canvas.width = 1;
				canvas.height = 32;

				const context = canvas.getContext( '2d' );
				const gradient = context.createLinearGradient( 0, 0, 0, 32 );
				gradient.addColorStop( 0.0, '#014a84' );
				gradient.addColorStop( 0.5, '#0561a0' );
				gradient.addColorStop( 1.0, '#437ab6' );
				context.fillStyle = gradient;
				context.fillRect( 0, 0, 1, 32 );

				const skyMap = new THREE.CanvasTexture( canvas );
				skyMap.colorSpace = THREE.SRGBColorSpace;

				const sky = new THREE.Mesh(
					new THREE.SphereGeometry( 10 ),
					new THREE.MeshBasicNodeMaterial( { map: skyMap, side: THREE.BackSide } )
				);
				scene.add( sky );

				// Texture

				const size = 128;
				const data = new Uint8Array( size * size * size );

				let i = 0;
				const scale = 0.05;
				const perlin = new ImprovedNoise();
				const vector = new THREE.Vector3();

				for ( let z = 0; z < size; z ++ ) {

					for ( let y = 0; y < size; y ++ ) {

						for ( let x = 0; x < size; x ++ ) {

							const d = 1.0 - vector.set( x, y, z ).subScalar( size / 2 ).divideScalar( size ).length();
							data[ i ] = ( 128 + 128 * perlin.noise( x * scale / 1.5, y * scale, z * scale / 1.5 ) ) * d * d;
							i ++;

						}

					}

				}

				const texture = new THREE.Data3DTexture( data, size, size, size );
				texture.format = THREE.RedFormat;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.unpackAlignment = 1;
				texture.needsUpdate = true;

				// Shader

				const transparentRaymarchingTexture = Fn( ( {
					texture,
					range = float( 0.1 ),
					threshold = float( 0.25 ),
					opacity = float( 0.25 ),
					steps = float( 100 )
				} ) => {

					const finalColor = vec4( 0 ).toVar();

					RaymarchingBox( steps, ( { positionRay } ) => {

						const mapValue = float( texture.sample( positionRay.add( 0.5 ) ).r ).toVar();

						mapValue.assign( smoothstep( threshold.sub( range ), threshold.add( range ), mapValue ).mul( opacity ) );

						const shading = texture.sample( positionRay.add( vec3( - 0.01 ) ) ).r.sub( texture.sample( positionRay.add( vec3( 0.01 ) ) ).r );

						const col = shading.mul( 3.0 ).add( positionRay.x.add( positionRay.y ).mul( 0.25 ) ).add( 0.2 );

						finalColor.rgb.addAssign( finalColor.a.oneMinus().mul( mapValue ).mul( col ) );

						finalColor.a.addAssign( finalColor.a.oneMinus().mul( mapValue ) );

						If( finalColor.a.greaterThanEqual( 0.95 ), () => {

							Break();

						} );

					} );

					return finalColor;

				} );

				// Material

				const baseColor = uniform( new THREE.Color( 0x798aa0 ) );
				const range = uniform( 0.1 );
				const threshold = uniform( 0.25 );
				const opacity = uniform( 0.25 );
				const steps = uniform( 100 );

				const cloud3d = transparentRaymarchingTexture( {
					texture: texture3D( texture, null, 0 ),
					range,
					threshold,
					opacity,
					steps
				} );

				const finalCloud = cloud3d.setRGB( cloud3d.rgb.add( baseColor ) );

				const material = new THREE.NodeMaterial();
				material.colorNode = finalCloud;
				material.side = THREE.BackSide;
				material.transparent = true;

				mesh = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), material );
				scene.add( mesh );

				//

				const gui = renderer.inspector.createParameters( 'Parameters' );
				gui.add( threshold, 'value', 0, 1, 0.01 ).name( 'threshold' );
				gui.add( opacity, 'value', 0, 1, 0.01 ).name( 'opacity' );
				gui.add( range, 'value', 0, 1, 0.01 ).name( 'range' );
				gui.add( steps, 'value', 0, 200, 1 ).name( 'steps' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				mesh.rotation.y = - performance.now() / 7500;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_volume_lighting.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - volumetric lighting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Volumetric Lighting</span>
			</div>

			<small>Compatible with native lights and shadows using post-processing pass.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { vec3, Fn, time, texture3D, screenUV, uniform, screenCoordinate, pass } from 'three/tsl';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
			import { TeapotGeometry } from 'three/addons/geometries/TeapotGeometry.js';

			import { bayer16 } from 'three/addons/tsl/math/Bayer.js';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			let renderer, scene, camera;
			let volumetricMesh, teapot, pointLight, spotLight;
			let postProcessing;

			init();

			function createTexture3D() {

				let i = 0;

				const size = 128;
				const data = new Uint8Array( size * size * size );

				const scale = 10;
				const perlin = new ImprovedNoise();

				const repeatFactor = 5.0;

				for ( let z = 0; z < size; z ++ ) {

					for ( let y = 0; y < size; y ++ ) {

						for ( let x = 0; x < size; x ++ ) {

							const nx = ( x / size ) * repeatFactor;
							const ny = ( y / size ) * repeatFactor;
							const nz = ( z / size ) * repeatFactor;

							const noiseValue = perlin.noise( nx * scale, ny * scale, nz * scale );

							data[ i ] = ( 128 + 128 * noiseValue );

							i ++;

						}

					}

				}

				const texture = new THREE.Data3DTexture( data, size, size, size );
				texture.format = THREE.RedFormat;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.unpackAlignment = 1;
				texture.needsUpdate = true;

				return texture;

			}

			function init() {

				const LAYER_VOLUMETRIC_LIGHTING = 10;

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 2;
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( - 8, 1, - 6 );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.maxDistance = 40;
				controls.minDistance = 2;

				// Volumetric Fog Area

				const noiseTexture3D = createTexture3D();

				const smokeAmount = uniform( 2 );

				const volumetricMaterial = new THREE.VolumeNodeMaterial();
				volumetricMaterial.steps = 12;
				volumetricMaterial.offsetNode = bayer16( screenCoordinate ); // Add dithering to reduce banding
				volumetricMaterial.scatteringNode = Fn( ( { positionRay } ) => {

					// Return the amount of fog based on the noise texture

					const timeScaled = vec3( time, 0, time.mul( .3 ) );

					const sampleGrain = ( scale, timeScale = 1 ) => texture3D( noiseTexture3D, positionRay.add( timeScaled.mul( timeScale ) ).mul( scale ).mod( 1 ), 0 ).r.add( .5 );

					let density = sampleGrain( .1 );
					density = density.mul( sampleGrain( .05, 1 ) );
					density = density.mul( sampleGrain( .02, 2 ) );

					return smokeAmount.mix( 1, density );

				} );

				volumetricMesh = new THREE.Mesh( new THREE.BoxGeometry( 20, 10, 20 ), volumetricMaterial );
				volumetricMesh.receiveShadow = true;
				volumetricMesh.position.y = 2;
				volumetricMesh.layers.disableAll();
				volumetricMesh.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				scene.add( volumetricMesh );

				// Objects

				teapot = new THREE.Mesh( new TeapotGeometry( .8, 18 ), new THREE.MeshStandardMaterial( { color: 0xffffff, side: THREE.DoubleSide } ) );
				teapot.castShadow = true;
				scene.add( teapot );

				const floor = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshStandardMaterial( { color: 0xffffff } ) );
				floor.rotation.x = - Math.PI / 2;
				floor.position.y = - 3;
				floor.receiveShadow = true;
				scene.add( floor );

				// Lights

				pointLight = new THREE.PointLight( 0xf9bb50, 3, 100 );
				pointLight.castShadow = true;
				pointLight.position.set( 0, 1.4, 0 );
				pointLight.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				//lightBase.add( new THREE.Mesh( new THREE.SphereGeometry( 0.1, 16, 16 ), new THREE.MeshBasicMaterial( { color: 0xf9bb50 } ) ) );
				scene.add( pointLight );

				spotLight = new THREE.SpotLight( 0xffffff, 100 );
				spotLight.position.set( 2.5, 5, 2.5 );
				spotLight.angle = Math.PI / 6;
				spotLight.penumbra = 1;
				spotLight.decay = 2;
				spotLight.distance = 0;
				spotLight.map = new THREE.TextureLoader().setPath( 'textures/' ).load( 'colors.png' );
				spotLight.castShadow = true;
				spotLight.shadow.intensity = .98;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = 1;
				spotLight.shadow.camera.far = 15;
				spotLight.shadow.focus = 1;
				spotLight.shadow.bias = - .003;
				spotLight.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				//sunLight.add( new THREE.Mesh( new THREE.SphereGeometry( 0.1, 16, 16 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
				scene.add( spotLight );

				// Post-Processing

				postProcessing = new THREE.PostProcessing( renderer );

				// Layers

				const volumetricLightingIntensity = uniform( 1 );

				const volumetricLayer = new THREE.Layers();
				volumetricLayer.disableAll();
				volumetricLayer.enable( LAYER_VOLUMETRIC_LIGHTING );

				// Scene Pass

				const scenePass = pass( scene, camera );
				const sceneDepth = scenePass.getTextureNode( 'depth' );

				// Material - Apply occlusion depth of volumetric lighting based on the scene depth

				volumetricMaterial.depthNode = sceneDepth.sample( screenUV );

				// Volumetric Lighting Pass

				const volumetricPass = pass( scene, camera, { depthBuffer: false } );
				volumetricPass.name = 'Volumetric Lighting';
				volumetricPass.setLayers( volumetricLayer );
				volumetricPass.setResolutionScale( .25 );

				// Compose and Denoise

				const denoiseStrength = uniform( .6 );

				const blurredVolumetricPass = gaussianBlur( volumetricPass, denoiseStrength );

				const scenePassColor = scenePass.add( blurredVolumetricPass.mul( volumetricLightingIntensity ) );

				postProcessing.outputNode = scenePassColor;

				// GUI

				const params = {
					resolution: volumetricPass.getResolutionScale(),
					denoise: true
				};

				const gui = renderer.inspector.createParameters( 'Volumetric Lighting' );

				const rayMarching = gui.addFolder( 'Ray Marching' );
				rayMarching.add( params, 'resolution', .1, .5 ).onChange( ( resolution ) => {

					volumetricPass.setResolutionScale( resolution );

				} );
				rayMarching.add( volumetricMaterial, 'steps', 2, 12 ).name( 'step count' );
				rayMarching.add( denoiseStrength, 'value', 0, 1 ).name( 'denoise strength' );
				rayMarching.add( params, 'denoise' ).onChange( ( denoise ) => {

					const volumetric = denoise ? blurredVolumetricPass : volumetricPass;

					const scenePassColor = scenePass.add( volumetric.mul( volumetricLightingIntensity ) );

					postProcessing.outputNode = scenePassColor;
					postProcessing.needsUpdate = true;

				} );

				const lighting = gui.addFolder( 'Lighting / Scene' );
				lighting.add( pointLight, 'intensity', 0, 6 ).name( 'light intensity' );
				lighting.add( spotLight, 'intensity', 0, 200 ).name( 'spot intensity' );
				lighting.add( volumetricLightingIntensity, 'value', 0, 2 ).name( 'fog intensity' );
				lighting.add( smokeAmount, 'value', 0, 3 ).name( 'smoke amount' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = performance.now() * 0.001;
				const scale = 2.4;

				pointLight.position.x = Math.sin( time * 0.7 ) * scale;
				pointLight.position.y = Math.cos( time * 0.5 ) * scale;
				pointLight.position.z = Math.cos( time * 0.3 ) * scale;

				spotLight.position.x = Math.cos( time * 0.3 ) * scale;
				spotLight.lookAt( 0, 0, 0 );

				teapot.rotation.y = time * 0.2;

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_volume_lighting_rectarea.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - volumetric lighting rect area</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Volumetric Lighting Rect Area</span>
			</div>

			<small>Compatible with rect area lights and shadows using post-processing pass.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { vec3, Fn, time, texture3D, screenUV, uniform, screenCoordinate, pass } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
			import { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { bayer16 } from 'three/addons/tsl/math/Bayer.js';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			let renderer, scene, camera;
			let volumetricMesh, meshKnot;
			let rectLight1, rectLight2, rectLight3;
			let clock;
			let postProcessing;

			init();

			function createTexture3D() {

				let i = 0;

				const size = 128;
				const data = new Uint8Array( size * size * size );

				const scale = 10;
				const perlin = new ImprovedNoise();

				const repeatFactor = 5.0;

				for ( let z = 0; z < size; z ++ ) {

					for ( let y = 0; y < size; y ++ ) {

						for ( let x = 0; x < size; x ++ ) {

							const nx = ( x / size ) * repeatFactor;
							const ny = ( y / size ) * repeatFactor;
							const nz = ( z / size ) * repeatFactor;

							const noiseValue = perlin.noise( nx * scale, ny * scale, nz * scale );

							data[ i ] = ( 128 + 128 * noiseValue );

							i ++;

						}

					}

				}

				const texture = new THREE.Data3DTexture( data, size, size, size );
				texture.format = THREE.RedFormat;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.unpackAlignment = 1;
				texture.needsUpdate = true;

				return texture;

			}

			function init() {

				THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() );

				const LAYER_VOLUMETRIC_LIGHTING = 10;

				clock = new THREE.Clock();

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 2;
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 250 );
				camera.position.set( 0, 5, - 15 );

				// Volumetric Fog Area

				const noiseTexture3D = createTexture3D();

				const smokeAmount = uniform( 2 );

				const volumetricMaterial = new THREE.VolumeNodeMaterial();
				volumetricMaterial.steps = 12;
				volumetricMaterial.offsetNode = bayer16( screenCoordinate ); // Add dithering to reduce banding
				volumetricMaterial.scatteringNode = Fn( ( { positionRay } ) => {

					// Return the amount of fog based on the noise texture

					const timeScaled = vec3( time, 0, time.mul( .3 ) );

					const sampleGrain = ( scale, timeScale = 1 ) => texture3D( noiseTexture3D, positionRay.add( timeScaled.mul( timeScale ) ).mul( scale ).mod( 1 ), 0 ).r.add( .5 );

					let density = sampleGrain( .1 );
					density = density.mul( sampleGrain( .05, 1 ) );
					density = density.mul( sampleGrain( .02, 2 ) );

					return smokeAmount.mix( 1, density );

				} );

				volumetricMesh = new THREE.Mesh( new THREE.BoxGeometry( 50, 40, 50 ), volumetricMaterial );
				volumetricMesh.receiveShadow = true;
				volumetricMesh.position.y = 20;
				volumetricMesh.layers.disableAll();
				volumetricMesh.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				scene.add( volumetricMesh );

				// Objects

				rectLight1 = new THREE.RectAreaLight( 0xff0000, 5, 4, 10 );
				rectLight1.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				rectLight1.position.set( - 5, 5, 5 );
				scene.add( rectLight1 );

				rectLight2 = new THREE.RectAreaLight( 0x00ff00, 5, 4, 10 );
				rectLight2.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				rectLight2.position.set( 0, 5, 5 );
				scene.add( rectLight2 );

				rectLight3 = new THREE.RectAreaLight( 0x0000ff, 5, 4, 10 );
				rectLight3.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				rectLight3.position.set( 5, 5, 5 );
				scene.add( rectLight3 );

				//

				const createRectLightMesh = ( rectLight ) => {

					const geometry = new THREE.PlaneGeometry( 4, 10 );
					const frontMaterial = new THREE.MeshBasicMaterial( { color: rectLight.color, side: THREE.BackSide } );
					const backMaterial = new THREE.MeshStandardMaterial( { color: 0x111111 } );

					const backSide = new THREE.Mesh( geometry, backMaterial );
					backSide.position.set( 0, 0, .08 );

					const frontSide = new THREE.Mesh( geometry, frontMaterial );
					frontSide.position.set( 0, 0, .01 );

					rectLight.add( backSide );
					rectLight.add( frontSide );

				};

				createRectLightMesh( rectLight1 );
				createRectLightMesh( rectLight2 );
				createRectLightMesh( rectLight3 );

				//

				const geoFloor = new THREE.BoxGeometry( 2000, 0.1, 2000 );
				const matStdFloor = new THREE.MeshStandardMaterial( { color: 0xbcbcbc, roughness: 0.1, metalness: 0 } );
				const mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );
				scene.add( mshStdFloor );

				const geoKnot = new THREE.TorusKnotGeometry( 1.5, 0.5, 200, 16 );
				const matKnot = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0, metalness: 0 } );
				meshKnot = new THREE.Mesh( geoKnot, matKnot );
				meshKnot.position.set( 0, 5, 0 );
				scene.add( meshKnot );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 5;
				controls.maxDistance = 200;
				controls.target.copy( meshKnot.position );
				controls.update();

				// Post-Processing

				postProcessing = new THREE.PostProcessing( renderer );

				// Layers

				const volumetricLightingIntensity = uniform( 1 );

				const volumetricLayer = new THREE.Layers();
				volumetricLayer.disableAll();
				volumetricLayer.enable( LAYER_VOLUMETRIC_LIGHTING );

				// Scene Pass

				const scenePass = pass( scene, camera );
				const sceneDepth = scenePass.getTextureNode( 'depth' );

				// Material - Apply occlusion depth of volumetric lighting based on the scene depth

				volumetricMaterial.depthNode = sceneDepth.sample( screenUV );

				// Volumetric Lighting Pass

				const volumetricPass = pass( scene, camera, { depthBuffer: false } );
				volumetricPass.setLayers( volumetricLayer );
				volumetricPass.setResolutionScale( .25 );

				// Compose and Denoise

				const denoiseStrength = uniform( .6 );

				const blurredVolumetricPass = gaussianBlur( volumetricPass, denoiseStrength );

				const scenePassColor = scenePass.add( blurredVolumetricPass.mul( volumetricLightingIntensity ) );

				postProcessing.outputNode = scenePassColor;

				// GUI

				const params = {
					resolution: volumetricPass.getResolutionScale(),
					denoise: true
				};

				const gui = renderer.inspector.createParameters( 'Volumetric Lighting' );

				const rayMarching = gui.addFolder( 'Ray Marching' );
				rayMarching.add( params, 'resolution', .1, .5 ).onChange( ( resolution ) => {

					volumetricPass.setResolutionScale( resolution );

				} );
				rayMarching.add( volumetricMaterial, 'steps', 2, 12 ).name( 'step count' );
				rayMarching.add( denoiseStrength, 'value', 0, 1 ).name( 'denoise strength' );
				rayMarching.add( params, 'denoise' ).onChange( ( denoise ) => {

					const volumetric = denoise ? blurredVolumetricPass : volumetricPass;

					const scenePassColor = scenePass.add( volumetric.mul( volumetricLightingIntensity ) );

					postProcessing.outputNode = scenePassColor;
					postProcessing.needsUpdate = true;

				} );

				const lighting = gui.addFolder( 'Lighting / Scene' );
				lighting.add( volumetricLightingIntensity, 'value', 0, 2 ).name( 'fog intensity' );
				lighting.add( smokeAmount, 'value', 0, 3 ).name( 'smoke amount' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				rectLight1.rotation.y += - delta;
				rectLight2.rotation.y += delta * .5;
				rectLight3.rotation.y += delta;

				postProcessing.render();

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_volume_perlin.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - volumetric perlin</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Volumetric Perlin</span>
			</div>

			<small>Volumetric rendering using raymarching and 3D Perlin noise texture.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { Break, If, vec3, vec4, texture3D, uniform, Fn } from 'three/tsl';

			import { RaymarchingBox } from 'three/addons/tsl/utils/Raymarching.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			let renderer, scene, camera;
			let mesh;

			init();

			function init() {

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 0, 2 );

				new OrbitControls( camera, renderer.domElement );

				// Texture

				const size = 128;
				const data = new Uint8Array( size * size * size );

				let i = 0;
				const perlin = new ImprovedNoise();
				const vector = new THREE.Vector3();

				for ( let z = 0; z < size; z ++ ) {

					for ( let y = 0; y < size; y ++ ) {

						for ( let x = 0; x < size; x ++ ) {

							vector.set( x, y, z ).divideScalar( size );

							const d = perlin.noise( vector.x * 6.5, vector.y * 6.5, vector.z * 6.5 );

							data[ i ++ ] = d * 128 + 128;

						}

					}

				}

				const texture = new THREE.Data3DTexture( data, size, size, size );
				texture.format = THREE.RedFormat;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.unpackAlignment = 1;
				texture.needsUpdate = true;

				// Shader

				const opaqueRaymarchingTexture = Fn( ( { texture, steps, threshold } ) => {

					const finalColor = vec4( 0 ).toVar();

					RaymarchingBox( steps, ( { positionRay } ) => {

						const mapValue = texture.sample( positionRay.add( 0.5 ) ).r.toVar();

						If( mapValue.greaterThan( threshold ), () => {

							const p = vec3( positionRay ).add( 0.5 );

							finalColor.rgb.assign( texture.normal( p ).mul( 0.5 ).add( positionRay.mul( 1.5 ).add( 0.25 ) ) );
							finalColor.a.assign( 1 );
							Break();

						} );

					} );

					return finalColor;

				} );

				//

				const threshold = uniform( 0.6 );
				const steps = uniform( 200 );

				const material = new THREE.NodeMaterial();
				material.colorNode = opaqueRaymarchingTexture( {
					texture: texture3D( texture, null, 0 ),
					steps,
					threshold
				} );
				material.side = THREE.BackSide;
				material.transparent = true;

				mesh = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), material );
				scene.add( mesh );

				//

				const gui = renderer.inspector.createParameters( 'Parameters' );
				gui.add( threshold, 'value', 0, 1, 0.01 ).name( 'threshold' );
				gui.add( steps, 'value', 0, 300, 1 ).name( 'steps' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_water.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - water</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="container"></div>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Water</span>
			</div>

			<small>
				<a href="https://skfb.ly/6WOOR" target="_blank" rel="noopener">The Night Pool</a> by 
			<a href="https://sketchfab.com/syntheticplants" target="_blank" rel="noopener">syntheticplants</a> is licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY 4.0</a>
			</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { pass, mrt, output, emissive, renderOutput } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';
			import { fxaa } from 'three/addons/tsl/display/FXAANode.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';

			import { WaterMesh } from 'three/addons/objects/Water2Mesh.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let scene, camera, renderer, water, postProcessing, controls;

			const params = {
				color: '#99e0ff',
				scale: 2,
				flowX: 1,
				flowY: 1
			};

			init();

			async function init() {

				scene = new THREE.Scene();

				const loader = new UltraHDRLoader();
				loader.setDataType( THREE.HalfFloatType );
				loader.load( 'textures/equirectangular/moonless_golf_2k.hdr.jpg', function ( texture ) {

					texture.mapping = THREE.EquirectangularReflectionMapping;
					texture.needsUpdate = true;

					scene.background = texture;
					scene.environment = texture;

				} );

				// camera

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200 );
				camera.position.set( - 20, 6, - 30 );

				// asset loading

				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

				const gltfLoader = new GLTFLoader();
				gltfLoader.setDRACOLoader( dracoLoader );
			
				const textureLoader = new THREE.TextureLoader();

				const [ gltf, normalMap0, normalMap1 ] = await Promise.all( [
					gltfLoader.loadAsync( 'models/gltf/pool.glb' ),
					textureLoader.loadAsync( 'textures/water/Water_1_M_Normal.jpg' ),
					textureLoader.loadAsync( 'textures/water/Water_2_M_Normal.jpg' )
				] );

				gltf.scene.position.z = 2;
				gltf.scene.scale.setScalar( 0.1 );
				scene.add( gltf.scene );

				// water

				normalMap0.wrapS = normalMap0.wrapT = THREE.RepeatWrapping;
				normalMap1.wrapS = normalMap1.wrapT = THREE.RepeatWrapping;

				const waterGeometry = new THREE.PlaneGeometry( 30, 40 );

				water = new WaterMesh( waterGeometry, {
					color: params.color,
					scale: params.scale,
					flowDirection: new THREE.Vector2( params.flowX, params.flowY ),
					normalMap0: normalMap0,
					normalMap1: normalMap1
				} );

				water.position.set( 0, 0.2, - 2 );
				water.rotation.x = Math.PI * - 0.5;
				water.renderOrder = Infinity;
				scene.add( water );

				// floor

				const floorGeometry = new THREE.PlaneGeometry( 1, 1 );
				floorGeometry.rotateX( - Math.PI * 0.5 );
				const floorMaterial = new THREE.MeshStandardMaterial( {
					color: 0x444444,
					roughness: 1,
					metalness: 0,
					side: THREE.DoubleSide
				} );

				{

					const floor = new THREE.Mesh( floorGeometry, floorMaterial );
					floor.position.set( 20, 0, 0 );
					floor.scale.set( 15, 1, 80 );
					scene.add( floor );

				}

				{

					const floor = new THREE.Mesh( floorGeometry, floorMaterial );
					floor.position.set( - 20, 0, 0 );
					floor.scale.set( 15, 1, 80 );
					scene.add( floor );

				}

				{

					const floor = new THREE.Mesh( floorGeometry, floorMaterial );
					floor.position.set( 0, 0, 30 );
					floor.scale.set( 30, 1, 20 );
					scene.add( floor );

				}

				{

					const floor = new THREE.Mesh( floorGeometry, floorMaterial );
					floor.position.set( 0, 0, - 30 );
					floor.scale.set( 30, 1, 20 );
					scene.add( floor );

				}

				// renderer

				renderer = new THREE.WebGPURenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 0.5;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				// postprocessing

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputColorTransform = false;
			
				const scenePass = pass( scene, camera );
				scenePass.setMRT( mrt( {
					output,
					emissive
				} ) );

				const beautyPass = scenePass.getTextureNode();
				const emissivePass = scenePass.getTextureNode( 'emissive' );

				const bloomPass = bloom( emissivePass, 2 );

				const outputPass = renderOutput( beautyPass.add( bloomPass ) );

				const fxaaPass = fxaa( outputPass );
				postProcessing.outputNode = fxaaPass;

				// gui

				const gui = renderer.inspector.createParameters( 'Water' );
				const waterNode = water.material.colorNode;

				gui.addColor( params, 'color' ).onChange( function ( value ) {

					waterNode.color.value.set( value );

				} );
				gui.add( params, 'scale', 1, 10 ).onChange( function ( value ) {

					waterNode.scale.value = value;

				} );
				gui.add( params, 'flowX', - 1, 1, 0.01 ).onChange( function ( value ) {

					waterNode.flowDirection.value.x = value;
					waterNode.flowDirection.value.normalize();

				} );
				gui.add( params, 'flowY', - 1, 1, 0.01 ).onChange( function ( value ) {

					waterNode.flowDirection.value.y = value;
					waterNode.flowDirection.value.normalize();

				} );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.target.set( 0, 0, - 5 );
				controls.update();

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				controls.update();

				postProcessing.render();

			}

		</script>

</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_xr_cubes.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js xr - cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> xr - interactive cubes
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { XRButton } from 'three/addons/webxr/XRButton.js';
			import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

			const clock = new THREE.Clock();

			let container;
			let camera, scene, raycaster, renderer;

			let room;

			let controller, controllerGrip;
			let INTERSECTED;

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x505050 );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.set( 0, 1.6, 3 );
				scene.add( camera );

				room = new THREE.LineSegments(
					new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),
					new THREE.LineBasicMaterial( { color: 0xbcbcbc } )
				);
				scene.add( room );

				scene.add( new THREE.HemisphereLight( 0xa5a5a5, 0x898989, 3 ) );

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				const geometry = new THREE.BoxGeometry( 0.15, 0.15, 0.15 );

				for ( let i = 0; i < 200; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

					object.position.x = Math.random() * 4 - 2;
					object.position.y = Math.random() * 4;
					object.position.z = Math.random() * 4 - 2;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.x = Math.random() + 0.5;
					object.scale.y = Math.random() + 0.5;
					object.scale.z = Math.random() + 0.5;

					object.userData.velocity = new THREE.Vector3();
					object.userData.velocity.x = Math.random() * 0.01 - 0.005;
					object.userData.velocity.y = Math.random() * 0.01 - 0.005;
					object.userData.velocity.z = Math.random() * 0.01 - 0.005;

					room.add( object );

				}

				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: true, colorBufferType: THREE.UnsignedByteType, multiview: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );

				//

				function onSelectStart() {

					this.userData.isSelecting = true;

				}

				function onSelectEnd() {

					this.userData.isSelecting = false;

				}

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'selectstart', onSelectStart );
				controller.addEventListener( 'selectend', onSelectEnd );
				controller.addEventListener( 'connected', function ( event ) {

					const targetRayMode = event.data.targetRayMode;

					if ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {

						this.add( buildController( event.data ) );

					}

				} );
				controller.addEventListener( 'disconnected', function () {

					this.remove( this.children[ 0 ] );

				} );
				scene.add( controller );

				const controllerModelFactory = new XRControllerModelFactory();

				controllerGrip = renderer.xr.getControllerGrip( 0 );
				controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
				scene.add( controllerGrip );

				window.addEventListener( 'resize', onWindowResize );

				//

				document.body.appendChild( XRButton.createButton( renderer ) );

			}

			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				const delta = clock.getDelta() * 60;

				if ( controller.userData.isSelecting === true ) {

					const cube = room.children[ 0 ];
					room.remove( cube );

					cube.position.copy( controller.position );
					cube.userData.velocity.x = ( Math.random() - 0.5 ) * 0.02 * delta;
					cube.userData.velocity.y = ( Math.random() - 0.5 ) * 0.02 * delta;
					cube.userData.velocity.z = ( Math.random() * 0.01 - 0.05 ) * delta;
					cube.userData.velocity.applyQuaternion( controller.quaternion );
					room.add( cube );

				}

				// find intersections

				raycaster.setFromXRController( controller );

				const intersects = raycaster.intersectObjects( room.children, false );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = undefined;

				}

				// Keep cubes inside room

				for ( let i = 0; i < room.children.length; i ++ ) {

					const cube = room.children[ i ];

					cube.userData.velocity.multiplyScalar( 1 - ( 0.001 * delta ) );

					cube.position.add( cube.userData.velocity );

					if ( cube.position.x < - 3 || cube.position.x > 3 ) {

						cube.position.x = THREE.MathUtils.clamp( cube.position.x, - 3, 3 );
						cube.userData.velocity.x = - cube.userData.velocity.x;

					}

					if ( cube.position.y < 0 || cube.position.y > 6 ) {

						cube.position.y = THREE.MathUtils.clamp( cube.position.y, 0, 6 );
						cube.userData.velocity.y = - cube.userData.velocity.y;

					}

					if ( cube.position.z < - 3 || cube.position.z > 3 ) {

						cube.position.z = THREE.MathUtils.clamp( cube.position.z, - 3, 3 );
						cube.userData.velocity.z = - cube.userData.velocity.z;

					}

					cube.rotation.x += cube.userData.velocity.x * 2 * delta;
					cube.rotation.y += cube.userData.velocity.y * 2 * delta;
					cube.rotation.z += cube.userData.velocity.z * 2 * delta;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_xr_native_layers.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - xr layers</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> vr - xr layers
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';
			import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { InteractiveGroup } from 'three/addons/interactive/InteractiveGroup.js';
			import {
				RollerCoasterGeometry,
				RollerCoasterShadowGeometry,
				RollerCoasterLiftersGeometry,
				TreesGeometry,
				SkyGeometry
			} from 'three/addons/misc/RollerCoaster.js';
			import { HTMLMesh } from 'three/addons/interactive/HTMLMesh.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let camera, scene, renderer;
			let controller1, controller2;
			let controllerGrip1, controllerGrip2;

			let room;

			let count = 0;
			const radius = 0.08;
			let normal = new THREE.Vector3();
			const relativeVelocity = new THREE.Vector3();

			const clock = new THREE.Clock();
			const funfairs = [];
			const train = new THREE.Object3D();
			const rcdelta = clock.getDelta() * 0.8; // slow down simulation
			const PI2 = Math.PI * 2;
			let rccamera = null;
			let rcscene = null;

			const tempMatrix = new THREE.Matrix4();
			let raycaster = null;

			const curve = ( function () {

				const vector = new THREE.Vector3();
				const vector2 = new THREE.Vector3();

				return {

					getPointAt: function ( t ) {

						t = t * PI2;

						const x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;
						const y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;
						const z = Math.sin( t ) * Math.sin( t * 4 ) * 50;

						return vector.set( x, y, z ).multiplyScalar( 2 );

					},

					getTangentAt: function ( t ) {

						const delta = 0.0001;
						const t1 = Math.max( 0, t - delta );
						const t2 = Math.min( 1, t + delta );

						return vector2.copy( this.getPointAt( t2 ) )
							.sub( this.getPointAt( t1 ) ).normalize();

					}

				};

			} )();

			let horseCamera = null;
			let horseScene = null;
			let horseMixer = null;
			let horseTheta = 0;
			let horseMesh = null;
			const horseRadius = 600;

			let guiScene = null;
			let guiCamera = null;
			let guiGroup = null;

			let rollercoasterLayer = null;
			let horseLayer = null;
			let guiLayer = null;

			const parameters = {
				radius: 0.6,
				tube: 0.2,
				tubularSegments: 150,
				radialSegments: 20,
				p: 2,
				q: 3,
				thickness: 0.5
			};

			init();

			function getIntersections( controller ) {

				tempMatrix.identity().extractRotation( controller.matrixWorld );

				raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
				raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

				return raycaster.intersectObjects( scene.children, false );

			}

			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x505050 );

				raycaster = new THREE.Raycaster();

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.set( 0, 1.6, 3 );

				room = new THREE.LineSegments(
					new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ),
					new THREE.LineBasicMaterial( { color: 0x808080 } )
				);
				room.geometry.translate( 0, 3, 0 );
				scene.add( room );

				scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );

				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				const geometry = new THREE.IcosahedronGeometry( radius, 3 );

				for ( let i = 0; i < 200; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

					object.position.x = Math.random() * 4 - 2;
					object.position.y = Math.random() * 4;
					object.position.z = Math.random() * 4 - 2;

					object.userData.velocity = new THREE.Vector3();
					object.userData.velocity.x = Math.random() * 0.01 - 0.005;
					object.userData.velocity.y = Math.random() * 0.01 - 0.005;
					object.userData.velocity.z = Math.random() * 0.01 - 0.005;

					room.add( object );

				}

				//

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: true, colorBufferType: THREE.UnsignedByteType, multiview: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( render );
				renderer.xr.enabled = true;
				document.body.appendChild( renderer.domElement );

				//

				document.body.appendChild( VRButton.createButton( renderer ) );

				// controllers

				function onSqueezeStart( ) {

					this.userData.isSelecting = true;

				}

				function onSqueezeEnd() {

					this.userData.isSelecting = false;

				}

				function onSelectStart( event ) {

					const controller = event.target;

					const intersections = getIntersections( controller );
					let hadSelection = false;

					for ( let x = 0; x < intersections.length; x ++ ) {

						if ( intersections[ x ].object == horseLayer ) {

							horseLayer.visible = false;
							hadSelection = true;

						}

						if ( intersections[ x ].object == rollercoasterLayer ) {

							controller.attach( rollercoasterLayer );
							hadSelection = true;

						}

						if ( intersections[ x ].object == guiLayer ) {

							const uv = intersections[ x ].uv;
							guiGroup.children[ 0 ].dispatchEvent( { type: 'mousedown', data: { x: uv.x, y: 1 - uv.y }, target: guiGroup } );
							hadSelection = true;

						}

					}

					this.userData.isSelecting = hadSelection === false;

				}

				function onSelectEnd( ) {

					horseLayer.visible = true;
					scene.attach( rollercoasterLayer );
					guiGroup.children[ 0 ].dispatchEvent( { type: 'mouseup', data: { x: 0, y: 0 }, target: guiGroup } );
					this.userData.isSelecting = false;

				}

				controller1 = renderer.xr.getController( 0 );
				controller1.addEventListener( 'selectstart', onSelectStart );
				controller1.addEventListener( 'selectend', onSelectEnd );
				controller1.addEventListener( 'squeezestart', onSqueezeStart );
				controller1.addEventListener( 'squeezeend', onSqueezeEnd );
				controller1.addEventListener( 'connected', function ( event ) {

					this.add( buildController( event.data ) );

				} );
				controller1.addEventListener( 'disconnected', function () {

					this.remove( this.children[ 0 ] );

				} );
				scene.add( controller1 );

				controller2 = renderer.xr.getController( 1 );
				controller2.addEventListener( 'selectstart', onSelectStart );
				controller2.addEventListener( 'selectend', onSelectEnd );
				controller2.addEventListener( 'squeezestart', onSqueezeStart );
				controller2.addEventListener( 'squeezeend', onSqueezeEnd );
				controller2.addEventListener( 'connected', function ( event ) {

					this.add( buildController( event.data ) );

				} );
				controller2.addEventListener( 'disconnected', function () {

					this.remove( this.children[ 0 ] );

				} );
				scene.add( controller2 );

				// The XRControllerModelFactory will automatically fetch controller models
				// that match what the user is holding as closely as possible. The models
				// should be attached to the object returned from getControllerGrip in
				// order to match the orientation of the held device.

				const controllerModelFactory = new XRControllerModelFactory();

				controllerGrip1 = renderer.xr.getControllerGrip( 0 );
				controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
				scene.add( controllerGrip1 );

				controllerGrip2 = renderer.xr.getControllerGrip( 1 );
				controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
				scene.add( controllerGrip2 );

				//

				window.addEventListener( 'resize', onWindowResize );

				// set up rollercoaster
				rollercoasterLayer = renderer.xr.createCylinderLayer( 1, Math.PI / 2, 2, new THREE.Vector3( 0, 1.5, - 0.5 ), new THREE.Quaternion(), 1500, 1000, renderRollercoaster );
				scene.add( rollercoasterLayer );

				rcscene = new THREE.Scene();
				rcscene.background = new THREE.Color( 0xf0f0ff );

				const rclight = new THREE.HemisphereLight( 0xfff0f0, 0x606066 );
				rclight.position.set( 1, 1, 1 );
				rcscene.add( rclight );

				rcscene.add( train );

				rccamera = new THREE.PerspectiveCamera( 50, 1, 0.1, 500 );
				train.add( rccamera );

				// environment

				let rcgeometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );
				rcgeometry.rotateX( - Math.PI / 2 );

				const positions = rcgeometry.attributes.position.array;
				const vertex = new THREE.Vector3();

				for ( let i = 0; i < positions.length; i += 3 ) {

					vertex.fromArray( positions, i );

					vertex.x += Math.random() * 10 - 5;
					vertex.z += Math.random() * 10 - 5;

					const distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;
					vertex.y = Math.random() * Math.max( 0, distance );

					vertex.toArray( positions, i );

				}

				rcgeometry.computeVertexNormals();

				let rcmaterial = new THREE.MeshLambertMaterial( {
					color: 0x407000
				} );

				let rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcscene.add( rcmesh );

				rcgeometry = new TreesGeometry( rcmesh );
				rcmaterial = new THREE.MeshBasicMaterial( {
					side: THREE.DoubleSide, vertexColors: true
				} );
				rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcscene.add( rcmesh );

				rcgeometry = new SkyGeometry();
				rcmaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
				rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcscene.add( rcmesh );

				//

				rcgeometry = new RollerCoasterGeometry( curve, 1500 );
				rcmaterial = new THREE.MeshPhongMaterial( {
					vertexColors: true
				} );
				rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcscene.add( rcmesh );

				rcgeometry = new RollerCoasterLiftersGeometry( curve, 100 );
				rcmaterial = new THREE.MeshPhongMaterial();
				rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcmesh.position.y = 0.1;
				rcscene.add( rcmesh );

				rcgeometry = new RollerCoasterShadowGeometry( curve, 500 );
				rcmaterial = new THREE.MeshBasicMaterial( {
					color: 0x305000, depthWrite: false, transparent: true
				} );
				rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcmesh.position.y = 0.1;
				rcscene.add( rcmesh );

				//

				rcgeometry = new THREE.CylinderGeometry( 10, 10, 5, 15 );
				rcmaterial = new THREE.MeshLambertMaterial( {
					color: 0xff8080
				} );
				rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcmesh.position.set( - 80, 10, - 70 );
				rcmesh.rotation.x = Math.PI / 2;
				rcscene.add( rcmesh );

				funfairs.push( rcmesh );

				rcgeometry = new THREE.CylinderGeometry( 5, 6, 4, 10 );
				rcmaterial = new THREE.MeshLambertMaterial( {
					color: 0x8080ff
				} );
				rcmesh = new THREE.Mesh( rcgeometry, rcmaterial );
				rcmesh.position.set( 50, 2, 30 );
				rcscene.add( rcmesh );

				funfairs.push( rcmesh );

				// set up horse animation
				horseLayer = renderer.xr.createQuadLayer( 1, 1, new THREE.Vector3( - 1.5, 1.5, - 1.5 ), new THREE.Quaternion(), 800, 800, renderQuad );
				scene.add( horseLayer );

				horseLayer.geometry = new THREE.CircleGeometry( .5, 64 );

				horseCamera = new THREE.PerspectiveCamera( 50, 1, 1, 10000 );
				horseCamera.position.y = 300;

				horseScene = new THREE.Scene();
				horseScene.background = new THREE.Color( 0xf0f0f0 );

				//

				const light1 = new THREE.DirectionalLight( 0xefefff, 1.5 );
				light1.position.set( 1, 1, 1 ).normalize();
				horseScene.add( light1 );

				const light2 = new THREE.DirectionalLight( 0xffefef, 1.5 );
				light2.position.set( - 1, - 1, - 1 ).normalize();
				horseScene.add( light2 );

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/Horse.glb', function ( gltf ) {

					horseMesh = gltf.scene.children[ 0 ];
					horseMesh.scale.set( 1.5, 1.5, 1.5 );
					horseScene.add( horseMesh );

					horseMixer = new THREE.AnimationMixer( horseMesh );

					horseMixer.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();

				} );

				function onChange() { }

				function onThicknessChange() { }

				// set up ui
				guiScene = new THREE.Scene();
				guiScene.background = new THREE.Color( 0x0 );

				guiCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				guiScene.add( guiCamera );

				const gui = new GUI( { width: 300 } );
				gui.add( parameters, 'radius', 0.0, 1.0 ).onChange( onChange );
				gui.add( parameters, 'tube', 0.0, 1.0 ).onChange( onChange );
				gui.add( parameters, 'tubularSegments', 10, 150, 1 ).onChange( onChange );
				gui.add( parameters, 'radialSegments', 2, 20, 1 ).onChange( onChange );
				gui.add( parameters, 'p', 1, 10, 1 ).onChange( onChange );
				gui.add( parameters, 'q', 0, 10, 1 ).onChange( onChange );
				gui.add( parameters, 'thickness', 0, 1 ).onChange( onThicknessChange );
				gui.domElement.style.visibility = 'hidden';

				guiGroup = new InteractiveGroup();
				guiScene.add( guiGroup );

				const mesh = new HTMLMesh( gui.domElement );
				guiGroup.add( mesh );

				const bbox = new THREE.Box3().setFromObject( guiScene );

				guiLayer = renderer.xr.createQuadLayer( 1.2, .8, new THREE.Vector3( 1.5, 1.5, - 1.5 ), new THREE.Quaternion(), 1280, 800, renderGui );
				scene.add( guiLayer );

				guiCamera.left = bbox.min.x;
				guiCamera.right = bbox.max.x;
				guiCamera.top = bbox.max.y;
				guiCamera.bottom = bbox.min.y;
				guiCamera.updateProjectionMatrix();

			}

			function renderGui() {

				renderer.render( guiScene, guiCamera );

			}

			function renderQuad() {

				horseTheta += 0.1;

				horseCamera.position.x = horseRadius * Math.sin( THREE.MathUtils.degToRad( horseTheta ) );
				horseCamera.position.z = horseRadius * Math.cos( THREE.MathUtils.degToRad( horseTheta ) );

				horseCamera.lookAt( 0, 150, 0 );

				if ( horseMixer ) {

					const time = Date.now();

					horseMixer.update( ( time - prevTime ) * 0.001 );

					prevTime = time;

				}

				renderer.render( horseScene, horseCamera );

			}

			const rcposition = new THREE.Vector3();
			const tangent = new THREE.Vector3();

			const lookAt = new THREE.Vector3();

			let rcvelocity = 0;
			let progress = 0;

			let prevTime = performance.now();

			function renderRollercoaster() {

				const time = performance.now();
				for ( let i = 0; i < funfairs.length; i ++ ) {

					funfairs[ i ].rotation.y = time * 0.0004;

				}

				//

				progress += rcvelocity;
				progress = progress % 1;

				rcposition.copy( curve.getPointAt( progress ) );
				rcposition.y += 0.3;

				train.position.copy( rcposition );

				tangent.copy( curve.getTangentAt( progress ) );

				rcvelocity -= tangent.y * 0.0000001 * rcdelta;
				rcvelocity = Math.max( 0.00004, Math.min( 0.0002, rcvelocity ) );

				train.lookAt( lookAt.copy( rcposition ).sub( tangent ) );

				//

				renderer.render( rcscene, rccamera );

			}

			function buildController( data ) {

				let geometry, material;

				switch ( data.targetRayMode ) {

					case 'tracked-pointer':

						geometry = new THREE.BufferGeometry();
						geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 1 ], 3 ) );
						geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

						material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

						return new THREE.Line( geometry, material );

					case 'gaze':

						geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
						material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
						return new THREE.Mesh( geometry, material );

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function handleController( controller ) {

				if ( controller.userData.isSelecting ) {

					const object = room.children[ count ++ ];

					object.position.copy( controller.position );
					object.userData.velocity.x = ( Math.random() - 0.5 ) * 3;
					object.userData.velocity.y = ( Math.random() - 0.5 ) * 3;
					object.userData.velocity.z = ( Math.random() - 9 );
					object.userData.velocity.applyQuaternion( controller.quaternion );

					if ( count === room.children.length ) count = 0;

				}

				const intersections = getIntersections( controller );
				for ( let x = 0; x < intersections.length; x ++ ) {

					if ( intersections[ x ].object == guiLayer ) {

						const uv = intersections[ x ].uv;
						guiGroup.children[ 0 ].dispatchEvent( { type: 'mousemove', data: { x: uv.x, y: 1 - uv.y }, target: guiGroup } );

					}


				}


			}

			//

			function render() {

				renderer.xr.renderLayers( );

				handleController( controller1 );
				handleController( controller2 );

				// rotate horse
				horseLayer.rotation.y -= 0.02;

				//
				const delta = clock.getDelta() * 0.8;

				const range = 3 - radius;

				for ( let i = 0; i < room.children.length; i ++ ) {

					const object = room.children[ i ];

					object.position.x += object.userData.velocity.x * delta;
					object.position.y += object.userData.velocity.y * delta;
					object.position.z += object.userData.velocity.z * delta;

					// keep objects inside room

					if ( object.position.x < - range || object.position.x > range ) {

						object.position.x = THREE.MathUtils.clamp( object.position.x, - range, range );
						object.userData.velocity.x = - object.userData.velocity.x;

					}

					if ( object.position.y < radius || object.position.y > 6 ) {

						object.position.y = Math.max( object.position.y, radius );

						object.userData.velocity.x *= 0.98;
						object.userData.velocity.y = - object.userData.velocity.y * 0.8;
						object.userData.velocity.z *= 0.98;

					}

					if ( object.position.z < - range || object.position.z > range ) {

						object.position.z = THREE.MathUtils.clamp( object.position.z, - range, range );
						object.userData.velocity.z = - object.userData.velocity.z;

					}

					for ( let j = i + 1; j < room.children.length; j ++ ) {

						const object2 = room.children[ j ];

						normal.copy( object.position ).sub( object2.position );

						const distance = normal.length();

						if ( distance < 2 * radius ) {

							normal.multiplyScalar( 0.5 * distance - radius );

							object.position.sub( normal );
							object2.position.add( normal );

							normal.normalize();

							relativeVelocity.copy( object.userData.velocity ).sub( object2.userData.velocity );

							normal = normal.multiplyScalar( relativeVelocity.dot( normal ) );

							object.userData.velocity.sub( normal );
							object2.userData.velocity.add( normal );

						}

					}

					object.userData.velocity.y -= 9.8 * delta;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>



================================================
FILE: RESOURCES/three.js-r181/examples/webgpu_xr_rollercoaster.html
================================================
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js vr - roller coaster</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';

			import {
				RollerCoasterGeometry,
				RollerCoasterShadowGeometry,
				RollerCoasterLiftersGeometry,
				TreesGeometry,
				SkyGeometry
			} from 'three/addons/misc/RollerCoaster.js';
			import { VRButton } from 'three/addons/webxr/VRButton.js';

			let mesh, material, geometry;

			const renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: true, colorBufferType: THREE.UnsignedByteType, multiview: false } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.xr.enabled = true;
			renderer.xr.setReferenceSpaceType( 'local' );
			document.body.appendChild( renderer.domElement );

			document.body.appendChild( VRButton.createButton( renderer ) );

			//

			const scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xf0f0ff );

			const light = new THREE.HemisphereLight( 0xfff0f0, 0x60606, 3 );
			light.position.set( 1, 1, 1 );
			scene.add( light );

			const train = new THREE.Object3D();
			scene.add( train );

			const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 500 );
			train.add( camera );

			// environment

			geometry = new THREE.PlaneGeometry( 500, 500, 15, 15 );
			geometry.rotateX( - Math.PI / 2 );

			const positions = geometry.attributes.position.array;
			const vertex = new THREE.Vector3();

			for ( let i = 0; i < positions.length; i += 3 ) {

				vertex.fromArray( positions, i );

				vertex.x += Math.random() * 10 - 5;
				vertex.z += Math.random() * 10 - 5;

				const distance = ( vertex.distanceTo( scene.position ) / 5 ) - 25;
				vertex.y = Math.random() * Math.max( 0, distance );

				vertex.toArray( positions, i );

			}

			geometry.computeVertexNormals();

			material = new THREE.MeshLambertMaterial( {
				color: 0x407000
			} );

			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new TreesGeometry( mesh );
			material = new THREE.MeshBasicMaterial( {
				side: THREE.DoubleSide, vertexColors: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new SkyGeometry();
			material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			//

			const PI2 = Math.PI * 2;

			const curve = ( function () {

				const vector = new THREE.Vector3();
				const vector2 = new THREE.Vector3();

				return {

					getPointAt: function ( t ) {

						t = t * PI2;

						const x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;
						const y = Math.sin( t * 10 ) * 2 + Math.cos( t * 17 ) * 2 + 5;
						const z = Math.sin( t ) * Math.sin( t * 4 ) * 50;

						return vector.set( x, y, z ).multiplyScalar( 2 );

					},

					getTangentAt: function ( t ) {

						const delta = 0.0001;
						const t1 = Math.max( 0, t - delta );
						const t2 = Math.min( 1, t + delta );

						return vector2.copy( this.getPointAt( t2 ) )
							.sub( this.getPointAt( t1 ) ).normalize();

					}

				};

			} )();

			geometry = new RollerCoasterGeometry( curve, 1500 );
			material = new THREE.MeshPhongMaterial( {
				vertexColors: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			geometry = new RollerCoasterLiftersGeometry( curve, 100 );
			material = new THREE.MeshPhongMaterial();
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			geometry = new RollerCoasterShadowGeometry( curve, 500 );
			material = new THREE.MeshBasicMaterial( {
				color: 0x305000, depthWrite: false, transparent: true
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.y = 0.1;
			scene.add( mesh );

			const funfairs = [];

			//

			geometry = new THREE.CylinderGeometry( 10, 10, 5, 15 );
			material = new THREE.MeshLambertMaterial( {
				color: 0xff8080
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.set( - 80, 10, - 70 );
			mesh.rotation.x = Math.PI / 2;
			scene.add( mesh );

			funfairs.push( mesh );

			geometry = new THREE.CylinderGeometry( 5, 6, 4, 10 );
			material = new THREE.MeshLambertMaterial( {
				color: 0x8080ff
			} );
			mesh = new THREE.Mesh( geometry, material );
			mesh.position.set( 50, 2, 30 );
			scene.add( mesh );

			funfairs.push( mesh );

			//

			window.addEventListener( 'resize', onWindowResize );

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			const position = new THREE.Vector3();
			const tangent = new THREE.Vector3();

			const lookAt = new THREE.Vector3();

			let velocity = 0;
			let progress = 0;

			let prevTime = performance.now();

			function animate() {

				const time = performance.now();
				const delta = time - prevTime;

				for ( let i = 0; i < funfairs.length; i ++ ) {

					funfairs[ i ].rotation.y = time * 0.0004;

				}

				//

				progress += velocity;
				progress = progress % 1;

				position.copy( curve.getPointAt( progress ) );
				position.y += 0.3;

				train.position.copy( position );

				tangent.copy( curve.getTangentAt( progress ) );

				velocity -= tangent.y * 0.0000001 * delta;
				velocity = Math.max( 0.00004, Math.min( 0.0002, velocity ) );

				train.lookAt( lookAt.copy( position ).sub( tangent ) );

				//

				renderer.render( scene, camera );

				prevTime = time;

			}

		</script>

	</body>
</html>


